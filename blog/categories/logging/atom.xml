<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id></id>
    <title>logging | Matthew Daly&apos;s Blog</title>
    <updated>2018-09-25T22:06:16Z</updated>
    <generator>grunt-blogbuilder https://github.com/matthewbdaly/grunt-blogbuilder</generator>
    <author>
        <name>Matthew Daly</name>
        <email>matthew@matthewdaly.co.uk</email>
        <uri>https://matthewdaly.co.uk</uri>
    </author>
    <link rel="alternate" href="https://matthewdaly.co.uk/blog/categories/logging/"/>
    <subtitle>logging | I&apos;m a web developer in Norfolk. This is my blog...</subtitle>
    <rights>Matthew Daly 2018</rights>
    <entry>
        <title type="html"><![CDATA[Logging to the ELK stack with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/">
        </link>
        <updated>2018-06-03T15:30:54Z</updated>
        <summary type="html"><![CDATA[<p>Logging to text files is the simplest and most common logging setup for web apps, and it works fine for relatively small and simple applications. However, it does have some downsides:</p>
<ul>
<li>It’s difficult to make the log files accessible - normally users have to SSH in to read them.</li>
<li>The tools used to filter and analyse log files have a fairly high technical barrier to access - grep and sed are not exactly easy for non-programmers to pick up, so business information can be hard to get.</li>
<li>It’s hard to visually identify trends in the data.</li>
<li>Log files don’t let you know immediately when something urgent happens</li>
<li>You can’t access logs for different applications through the same interface.</li>
</ul>
<p>For rare, urgent issues where you need to be informed immediately they occur, it’s straightforward to log to an instant messaging solution such as Slack or Hipchat. However, these aren’t easily searchable, and can only be used for the most important errors (otherwise, there’s a risk that important data will be lost in the noise). There are third-party services that allow you to search and filter your logs, but they can be prohibitively expensive.</p>
<p>The <a href="https://www.elastic.co/elk-stack">ELK stack</a> has recently gained a lot of attention as a sophisticated solution for logging application data. It consists of:</p>
<ul>
<li>Logstash for processing log data</li>
<li>Elasticsearch as a searchable storage backend</li>
<li>Kibana as a web interface</li>
</ul>
<p>By making the log data available using a powerful web interface, you can easily expose it to non-technical users. Kibana also comes with powerful tools to aggregate and filter the data. In addition, you can run your own instance, giving you a greater degree of control (as well as possibly being more cost-effective) compared to using a third-party service.</p>
<p>In this post I’ll show you how to configure a Laravel application to log to an instance of the ELK stack. Fortunately, Laravel uses the popular Monolog logging library by default, which is relatively easy to get to work with the ELK stack. First, we need to install support for the GELF logging format:</p>
<pre><code class="hljs lang-bash singleline">$ composer require graylog2/gelf-php</code></pre>
<p>Then, we create a custom logger class:</p>
<pre><code class="hljs lang-php"><table><tr><td class="linenos" data-pseudo-content="1"></td><td><span class="hljs-meta">&lt;?php</span></td><tr><td class="linenos" data-pseudo-content="2"></td><td></td><tr><td class="linenos" data-pseudo-content="3"></td><td><span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Logging</span>;</td><tr><td class="linenos" data-pseudo-content="4"></td><td></td><tr><td class="linenos" data-pseudo-content="5"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Monolog</span>\<span class="hljs-title">Logger</span>;</td><tr><td class="linenos" data-pseudo-content="6"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Monolog</span>\<span class="hljs-title">Handler</span>\<span class="hljs-title">GelfHandler</span>;</td><tr><td class="linenos" data-pseudo-content="7"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Gelf</span>\<span class="hljs-title">Publisher</span>;</td><tr><td class="linenos" data-pseudo-content="8"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Gelf</span>\<span class="hljs-title">Transport</span>\<span class="hljs-title">UdpTransport</span>;</td><tr><td class="linenos" data-pseudo-content="9"></td><td></td><tr><td class="linenos" data-pseudo-content="10"></td><td><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GelfLogger</span></td><tr><td class="linenos" data-pseudo-content="11"></td><td></span>{</td><tr><td class="linenos" data-pseudo-content="12"></td><td>    <span class="hljs-comment">/**</td><tr><td class="linenos" data-pseudo-content="13"></td><td>     * Create a custom Monolog instance.</td><tr><td class="linenos" data-pseudo-content="14"></td><td>     *</td><tr><td class="linenos" data-pseudo-content="15"></td><td>     * <span class="hljs-doctag">@param</span>  array  $config</td><tr><td class="linenos" data-pseudo-content="16"></td><td>     * <span class="hljs-doctag">@return</span> \Monolog\Logger</td><tr><td class="linenos" data-pseudo-content="17"></td><td>     */</span></td><tr><td class="linenos" data-pseudo-content="18"></td><td>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span><span class="hljs-params">(array $config)</span></td><tr><td class="linenos" data-pseudo-content="19"></td><td>    </span>{</td><tr><td class="linenos" data-pseudo-content="20"></td><td>        $handler = <span class="hljs-keyword">new</span> GelfHandler(<span class="hljs-keyword">new</span> Publisher(<span class="hljs-keyword">new</span> UdpTransport($config[<span class="hljs-string">'host'</span>], $config[<span class="hljs-string">'port'</span>])));</td><tr><td class="linenos" data-pseudo-content="21"></td><td>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'main'</span>, [$handler]);</td><tr><td class="linenos" data-pseudo-content="22"></td><td>    }</td><tr><td class="linenos" data-pseudo-content="23"></td><td>}</td></table></code></pre>
<p>Finally, we configure our application to use this as our custom driver and specify the host and port in <code>config/logging.php</code>:</p>
<pre><code class="hljs lang-php"><table><tr><td class="linenos" data-pseudo-content="1"></td><td>        <span class="hljs-string">'custom'</span> =&gt; [</td><tr><td class="linenos" data-pseudo-content="2"></td><td>            <span class="hljs-string">'driver'</span> =&gt; <span class="hljs-string">'custom'</span>,</td><tr><td class="linenos" data-pseudo-content="3"></td><td>            <span class="hljs-string">'via'</span> =&gt; App\Logging\GelfLogger::class,</td><tr><td class="linenos" data-pseudo-content="4"></td><td>            <span class="hljs-string">'host'</span> =&gt; <span class="hljs-string">'127.0.0.1'</span>,</td><tr><td class="linenos" data-pseudo-content="5"></td><td>            <span class="hljs-string">'port'</span> =&gt; <span class="hljs-number">12201</span>,</td><tr><td class="linenos" data-pseudo-content="6"></td><td>        ],</td></table></code></pre>
<p>You can then set up whatever logging channels you need for your application, and specify whatever log level you feel is appropriate.</p>
<p>Please note that this requires at least Laravel 5.6 - this file doesn’t exist in Laravel 5.5 and earlier, so you may have more work on your hands to integrate it with older versions.</p>
<p>If you already have an instance of the ELK stack set up on a remote server that’s already set up to accept input as GELF, then you should be able to point it at that and you’ll be ready to go. If you just want to try it out, I’ve been using a <a href="https://github.com/deviantony/docker-elk">Docker-based project</a> that makes it straightforward to run the whole stack locally. However, you will need to amend <code>logstash/pipeline/logstash.conf</code> as follows to allow it to accept log data:</p>
<pre><code class="hljs lang-json"><table><tr><td class="linenos" data-pseudo-content="1"></td><td>input {</td><tr><td class="linenos" data-pseudo-content="2"></td><td>    tcp {</td><tr><td class="linenos" data-pseudo-content="3"></td><td>        port =&gt; 5000</td><tr><td class="linenos" data-pseudo-content="4"></td><td>    }</td><tr><td class="linenos" data-pseudo-content="5"></td><td>   gelf {</td><tr><td class="linenos" data-pseudo-content="6"></td><td>       port =&gt; 12201</td><tr><td class="linenos" data-pseudo-content="7"></td><td>       type =&gt; gelf</td><tr><td class="linenos" data-pseudo-content="8"></td><td>       codec =&gt; "json"</td><tr><td class="linenos" data-pseudo-content="9"></td><td>   }</td><tr><td class="linenos" data-pseudo-content="10"></td><td>}</td><tr><td class="linenos" data-pseudo-content="11"></td><td></td><tr><td class="linenos" data-pseudo-content="12"></td><td>## Add your filters / logstash plugins configuration here</td><tr><td class="linenos" data-pseudo-content="13"></td><td></td><tr><td class="linenos" data-pseudo-content="14"></td><td>output {</td><tr><td class="linenos" data-pseudo-content="15"></td><td>    elasticsearch {</td><tr><td class="linenos" data-pseudo-content="16"></td><td>        hosts =&gt; "elasticsearch:9200"</td><tr><td class="linenos" data-pseudo-content="17"></td><td>    }</td><tr><td class="linenos" data-pseudo-content="18"></td><td>}</td></table></code></pre>
<p>Then you can start it up using the instructions in the repository and it should be ready to go. Now, if you run the following command from Tinker:</p>
<pre><code class="hljs lang-php singleline">Log::info(<span class="hljs-string">'Just testing'</span>);</code></pre>
<p>Then if you access the web interface, you should be able to find that log message without any difficulty.</p>
<p>Now, this only covers the Laravel application logs. You may well want to pass other logs through to Logstash, such as Apache, Nginx or MySQL logs, and a quick Google should be sufficient to find ideas on how you might log for these services. Creating visualisations with Kibana is a huge subject, and the existing documentation covers that quite well, so if you’re interested in learning more about that I’d recommend reading the documentation and having a play with the dashboard.</p>
]]></summary>
    </entry>
</feed>