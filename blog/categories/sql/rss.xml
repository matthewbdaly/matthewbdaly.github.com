<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>sql | Matthew Daly&apos;s Blog</title>
        <link>https://matthewdaly.co.uk/blog/categories/sql/</link>
        <description>sql | I&apos;m a web developer in Norfolk. This is my blog...</description>
        <lastBuildDate>Fri, 07 Dec 2018 12:13:50 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>grunt-blogbuilder https://github.com/matthewbdaly/grunt-blogbuilder</generator>
        <copyright>Matthew Daly 2018</copyright>
        <item>
            <title><![CDATA[Full-text search with MariaDB]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/05/13/full-text-search-with-mariadb/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/05/13/full-text-search-with-mariadb/</guid>
            <pubDate>Sun, 13 May 2018 13:55:42 GMT</pubDate>
            <description><![CDATA[<p>Recently I had the occasion to check out MariaDB’s implementation of full-text search. As it’s a relatively recent arrival in MySQL and MariaDB, it doesn’t seem to get all that much attention. In this post I’ll show you how to use it, with a few Laravel-specific pointers. We’ll be using the default <code>User</code> model in a new Laravel installation, which has columns for <code>name</code> and <code>email</code>.</p>
<p>Our first task is to create the fulltext index, which is necessary to perform the query. Run the following command:</p>
<pre><code class="hljs lang-sql singleline"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">ADD</span> FULLTEXT (<span class="hljs-keyword">name</span>, email);</code></pre>
<p>As you can see, we can specify multiple columns in our table to index.</p>
<p>If you’re using Laravel, you’ll want to create the following migration for this:</p>
<pre><code class="hljs lang-php"><table><tr><td class="linenos" data-pseudo-content="1"></td><td><span class="hljs-meta">&lt;?php</span></td><tr><td class="linenos" data-pseudo-content="2"></td><td></td><tr><td class="linenos" data-pseudo-content="3"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Schema</span>;</td><tr><td class="linenos" data-pseudo-content="4"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Database</span>\<span class="hljs-title">Schema</span>\<span class="hljs-title">Blueprint</span>;</td><tr><td class="linenos" data-pseudo-content="5"></td><td><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Database</span>\<span class="hljs-title">Migrations</span>\<span class="hljs-title">Migration</span>;</td><tr><td class="linenos" data-pseudo-content="6"></td><td></td><tr><td class="linenos" data-pseudo-content="7"></td><td><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddFulltextIndexForUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Migration</span></td><tr><td class="linenos" data-pseudo-content="8"></td><td></span>{</td><tr><td class="linenos" data-pseudo-content="9"></td><td>    <span class="hljs-comment">/**</td><tr><td class="linenos" data-pseudo-content="10"></td><td>     * Run the migrations.</td><tr><td class="linenos" data-pseudo-content="11"></td><td>     *</td><tr><td class="linenos" data-pseudo-content="12"></td><td>     * <span class="hljs-doctag">@return</span> void</td><tr><td class="linenos" data-pseudo-content="13"></td><td>     */</span></td><tr><td class="linenos" data-pseudo-content="14"></td><td>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span><span class="hljs-params">()</span></td><tr><td class="linenos" data-pseudo-content="15"></td><td>    </span>{</td><tr><td class="linenos" data-pseudo-content="16"></td><td>        DB::statement(<span class="hljs-string">'ALTER TABLE users ADD FULLTEXT(name, email)'</span>);</td><tr><td class="linenos" data-pseudo-content="17"></td><td>    }</td><tr><td class="linenos" data-pseudo-content="18"></td><td></td><tr><td class="linenos" data-pseudo-content="19"></td><td>    <span class="hljs-comment">/**</td><tr><td class="linenos" data-pseudo-content="20"></td><td>     * Reverse the migrations.</td><tr><td class="linenos" data-pseudo-content="21"></td><td>     *</td><tr><td class="linenos" data-pseudo-content="22"></td><td>     * <span class="hljs-doctag">@return</span> void</td><tr><td class="linenos" data-pseudo-content="23"></td><td>     */</span></td><tr><td class="linenos" data-pseudo-content="24"></td><td>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">down</span><span class="hljs-params">()</span></td><tr><td class="linenos" data-pseudo-content="25"></td><td>    </span>{</td><tr><td class="linenos" data-pseudo-content="26"></td><td>        DB::statement(<span class="hljs-string">'ALTER TABLE users DROP INDEX IF EXISTS name'</span>);</td><tr><td class="linenos" data-pseudo-content="27"></td><td>    }</td><tr><td class="linenos" data-pseudo-content="28"></td><td>}</td></table></code></pre>
<p>Note that the index is named after the first field passed to it, so when we drop it we refer to it as <code>name</code>. Then, to actually query the index, you should run a command something like this:</p>
<pre><code class="hljs lang-sql singleline"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(<span class="hljs-keyword">name</span>, email) AGAINST (<span class="hljs-string">'jeff'</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">MODE</span>);</code></pre>
<p>Note that <code>NATURAL LANGUAGE MODE</code> is actually the default, so you can leave it off if you wish. We also have to specify the columns to match against.</p>
<p>If you’re using Laravel, you may want to create a reusable local scope for it:</p>
<pre><code class="hljs lang-php"><table><tr><td class="linenos" data-pseudo-content="1"></td><td>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scopeSearch</span><span class="hljs-params">($query, $search)</span></td><tr><td class="linenos" data-pseudo-content="2"></td><td>    </span>{</td><tr><td class="linenos" data-pseudo-content="3"></td><td>        <span class="hljs-keyword">if</span> (!$search) {</td><tr><td class="linenos" data-pseudo-content="4"></td><td>            <span class="hljs-keyword">return</span> $query;</td><tr><td class="linenos" data-pseudo-content="5"></td><td>        }</td><tr><td class="linenos" data-pseudo-content="6"></td><td>        <span class="hljs-keyword">return</span> $query-&gt;whereRaw(<span class="hljs-string">'MATCH(name, email) AGAINST (?)'</span>, [$search]);</td><tr><td class="linenos" data-pseudo-content="7"></td><td>    }</td></table></code></pre>
<p>Then you can call it as follows:</p>
<pre><code class="hljs lang-php singleline">User::search(<span class="hljs-string">'jeff'</span>)-&gt;get();</code></pre>
<p>I personally have noticed that the query using the <code>MATCH</code> keywords seems to be far more performant, with the response time being between five and ten times less than a similar command using <code>LIKE</code>, however this observation isn’t very scientific (plus, we are talking about queries that still run in a fraction of a second). However, if you’re doing a particularly expensive query that currently uses a <code>LIKE</code> statement, it’s possible you may get better results by switching to a <code>MATCH</code> statement. Full-text search probably isn’t all that useful in this context - it’s only once we’re talking about longer text, such as blog posts, that some of the advantages like support for stopwords comes into play.</p>
<p>From what I’ve seen this implementation of full-text search is a lot simpler than in PostgreSQL, which has ups and downs. On the one hand, it’s a lot easier to implement, but conversely it’s less useful - there’s no obvious way to perform a full-text search against joined tables. However, it does seem to be superior to using a <code>LIKE</code> statement, so it’s probably a good fit for smaller sites where something like Elasticsearch would be overkill.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Using stored procedures in your web app]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/03/10/using-stored-procedures-in-your-web-app/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/03/10/using-stored-procedures-in-your-web-app/</guid>
            <pubDate>Sat, 10 Mar 2018 15:10:16 GMT</pubDate>
            <description><![CDATA[<p>In the last few days I’ve done something I’ve never done before, namely written a stored procedure for a web app. Like most web developers, I know enough about SQL to be able to formulate some fairly complex queries, but I hadn’t really touched on control flow functions or stored procedures, and in my experience they tend to be the province of the dedicated database administrator, not us web devs, who will typically delegate more complex functionality to our application code.</p>
<p>In this case, there were a number of factors influencing my decision to use a stored procedure for this:</p>
<ul>
<li>The application was a legacy application which had been worked on by developers of, shall we say, varying skill levels. As a result the database schema was badly designed, with no prospect of changing it without causing huge numbers of breakages</li>
<li>The query in question was used to generate a complex report that was quite time-consuming, therefore the optimisations from using a stored procedure were worthwhile.</li>
<li>The report required that data be grouped by a set of categories which were stored in a separate table, which meant the table had to be pivoted (transformed from rows to columns), resulting in an incredibly complex dynamic query that had to be constructed on the fly by concatenating different SQL strings. In PostgreSQL, this can be done fairly easily using the <code>crosstab</code> function, but MySQL doesn’t have native support for anything like this.</li>
</ul>
<p>Historically, one issue with using stored procedures has been that it kept business logic out of the application code, meaning they are not stored in version control. However, most modern frameworks provide some support for migrations, and since they are intended to be used to make changes to the database, they are the obvious place to define the stored procedure. This particular application was built with an older framework that didn’t come with migrations, so we’d installed <a href="https://phinx.org/">Phinx</a> to handle those for us. Initially, I defined the stored procedure inside a migration that ran a raw query to create the stored procedure, as in this example:</p>
<pre><code class="hljs lang-php"><table><tr><td class="linenos" data-pseudo-content="1"></td><td><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span><span class="hljs-params">()</span></td><tr><td class="linenos" data-pseudo-content="2"></td><td></span>{</td><tr><td class="linenos" data-pseudo-content="3"></td><td>   $query = <span class="hljs-string">&lt;&lt;&lt;EOF</td><tr><td class="linenos" data-pseudo-content="4"></td><td>CREATE PROCEDURE IF NOT EXISTS foo</td><tr><td class="linenos" data-pseudo-content="5"></td><td>BEGIN</span></td><tr><td class="linenos" data-pseudo-content="6"></td><td>   SELECT * FROM foo;</td><tr><td class="linenos" data-pseudo-content="7"></td><td>END</td><tr><td class="linenos" data-pseudo-content="8"></td><td>EOF;</td><tr><td class="linenos" data-pseudo-content="9"></td><td>   <span class="hljs-keyword">$this</span>-&gt;execute($query);</td><tr><td class="linenos" data-pseudo-content="10"></td><td>}</td><tr><td class="linenos" data-pseudo-content="11"></td><td></td><tr><td class="linenos" data-pseudo-content="12"></td><td><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">down</span><span class="hljs-params">()</span></td><tr><td class="linenos" data-pseudo-content="13"></td><td></span>{</td><tr><td class="linenos" data-pseudo-content="14"></td><td>   <span class="hljs-keyword">$this</span>-&gt;execute(<span class="hljs-string">'DROP PROCEDURE IF EXISTS foo'</span>);</td><tr><td class="linenos" data-pseudo-content="15"></td><td>}</td></table></code></pre>
<p>Once this is done, you can then use your framework’s particular support for raw queries to call <code>CALL foo()</code> whenever your stored procedure needs to be executed.</p>
<p>However, we soon ran into an issue. It turns out <code>mysqldump</code> doesn’t export stored procedures by default, so there was a risk that anyone working on the code base might import the database from an SQL file and not get the migrations. I’d used the Symfony Console component to create a simple command-line tool, reminiscent of Laravel’s Artisan, so I used that to create a command to set up the stored procedure, amended the migration to call that command, and placed a check in the application where the procedure was called so that if it was not defined the command would be called and the procedure would be created. In most cases this wouldn’t be an issue.</p>
<p>Having now had experience using stored procedures in a web application, there are a number of issues they raise:</p>
<ul>
<li>It’s hard to make queries flexible, whereas with something like Eloquent it’s straightforward to conditionally apply <code>WHERE</code> statements.</li>
<li>While storing them in migrations is a practical solution, if the database is likely to be imported rather than created from scratch during development it can be problematic.</li>
<li>They aren’t easily portable, not just between database management systems, but between different versions - the production server was using an older version of MySQL, and it failed to create the procedure. It’s therefore good practice for your migrations to check the procedure was created successfully and raise a noisy exception if they failed.</li>
</ul>
<p>Conversely, they do bring certain benefits:</p>
<ul>
<li>For particularly complex transactions that don’t change, such as generating reports, they are a good fit since they reduce the amount of data that needs to be sent to the database and allow the query to be pre-optimised somewhat.</li>
<li>If a particular query is unusually expensive, is called often, and can’t be cached, it may improve performance to make it a stored procedure.</li>
<li>Doing a query in a for loop is usually a very big no-no. However, if there really is no way to avoid it (and this should almost never happen), it would make sense to try to do it in a stored procedure using SQL rather than in application code since that would minimise the overhead.</li>
<li>If multiple applications need to work with the same database, using stored procedures for queries in more than one application removes the need to reimplement or copy over the code for the query in the second application - they can just call the same procedure, and if it needs to be changed it need only be done once.</li>
</ul>
<p>Honestly, I’m not sure I’m ever likely to again come across a scenario where using a stored procedure in a web application would be beneficial, but it’s been very interesting delving into aspects of SQL that I don’t normally touch on and I’ve picked up on some rarely-used SQL statements that I haven’t used before, such as <code>GROUP_CONCAT()</code> and <code>CASE</code>. With the widespread adoption of migrations in most frameworks, I think that the argument that using stored procedures keeps application logic out of version control no longer holds any water, since developers can generally be trusted to store changes to database structure in their migrations and not start messing them around, so the same applies for stored procedures. Report generation seems to be the ideal use case since this invariably involves complex queries that run regularly and don’t change often, and this is where I expect it would be most likely I’d have cause to use them again.</p>
]]></description>
        </item>
    </channel>
</rss>