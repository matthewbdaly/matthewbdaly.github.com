<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>php | Matthew Daly&apos;s Blog</title>
        <link>https://matthewdaly.co.uk/blog/categories/php/</link>
        <description>php | I&apos;m a web developer in Norfolk. This is my blog...</description>
        <lastBuildDate>Mon, 30 Dec 2019 21:13:36 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>grunt-blogbuilder https://github.com/matthewbdaly/grunt-blogbuilder</generator>
        <copyright>Matthew Daly 2019</copyright>
        <item>
            <title><![CDATA[Flexible data types with the JSON field]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/10/13/flexible-data-types-with-the-json-field/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/10/13/flexible-data-types-with-the-json-field/</guid>
            <pubDate>Sun, 13 Oct 2019 22:10:43 GMT</pubDate>
            <description><![CDATA[<p>Relational databases have many advantages over other data stores. They’re (mostly) solid, mature products, they have the means to prevent data duplication while still allowing related data to be accessed, and they allow for easy enforcement of data types. However, the latter point has also historically made them less flexible compared to document databases such as MongoDB, which allow for fields to be set dynamically, making it much easier to set content arbitrarily.</p>
<p>One area in which this has caused particular problems is with content management systems, where you might want to be able to set custom content types that need to be treated the same in some circumstances, and have some fields in common, but store different data. If you want to be able to store arbitrary data against a particular entity, historically the main way to do that is to create a meta table to contain keys and values, and set the entity ID as a foreign key in the new table.</p>
<p>Wordpress is a common example of this. Any piece of content is stored in the <code>wp_posts</code> table, which in addition to the generic structure of a post, also includes the <code>post_type</code> field. It’s possible to create and register your own post types, but it’s not possible to store additional custom data in that table. Instead, it’s stored as keys and values in the <code>wp_postmeta</code> table, meaning you need to do a join to retrieve that content at the same time, making for more complex queries.</p>
<p>Another approach is to have a generic entity table that contains the common fields, and separate tables for the rest, and then set up a one-to-one relationship between them. However, that can be fiddly too because it doesn’t allow for custom types in the same way, so it may not fit with your use case if you need to be able to create arbitrary content types, such as for a CMS that allowed for custom content types.</p>
<h2 id="introducing-json-fields">Introducing JSON fields</h2>
<p>JSON fields allow you to bring some of the flexibility of document databases to the relational world. They allow you to store whatever arbitrary text data you wish as JSON, and retrieve it as usual. More importantly, they also allow you to query by that data, so you can easily filter by fields that need not be set in stone with a database schema.</p>
<p>This means that in the above example of a CMS, instead of having a separate meta table, you can instead store the meta values in a JSON field, thus removing the need for a join and simplifying querying by those values.</p>
<p>PostgreSQL has had this capability for a long time, but it’s only comparatively recently that MySQL and MariaDB versions that support it have become widespread. Here I’ll show you how you might use it in a Laravel application.</p>
<p>The example will be a content management system with flexible content types. The first step is to create the migration to add the new content table:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateContent extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create(&#39;content&#39;, function (Blueprint $table) {
            $table-&gt;bigIncrements(&#39;id&#39;);
            $table-&gt;string(&#39;type&#39;, 20);
            $table-&gt;json(&#39;attributes&#39;);
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists(&#39;content&#39;);
    }
}
</code></pre>
<p>Here we’re specifying the following fields:</p>
<ul>
<li>An auto-incrementing ID (feel free to swap this out for a UUID if it makes sense for your application)</li>
<li>A string denoting the content type. If you want to limit the values these can accept, you can replace it with an <code>ENUM</code> field</li>
<li>The JSON field, named <code>attributes</code></li>
<li>The standard Laravel timestamp fields, <code>created_at</code> and <code>updated_at</code></li>
</ul>
<p>If there are certain fields that are common to all of your content types, it would also make sense to define them as fields in the usual way, rather than use the JSON field, since compulsory fields should be enforced by the database.</p>
<p>Next, we’ll create the model:</p>
<pre><code class="lang-php">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Content extends Model
{
    protected $table = &#39;content&#39;;

    protected $casts = [
        &#39;attributes&#39; =&gt; &#39;array&#39;
    ];
}
</code></pre>
<p>Note that we cast the <code>attributes</code> field to an array. If we didn’t do this, we’d need to manually run <code>json_encode()</code> and <code>json_decode()</code> on the field to get it back in a usable form. As it is, we can now easily retrieve fields using array access.</p>
<p>With that done, we can now set up some data:</p>
<pre><code class="lang-php">&lt;?php
$c = new App\Content;
$c-&gt;type = &#39;page&#39;;
$c-&gt;attributes = [ 
    &quot;type&quot; =&gt; &quot;info&quot;,
    &quot;title&quot; =&gt; &quot;Terms&quot;,
    &quot;content&quot; =&gt; &quot;Our Terms&quot;,
    &quot;layout&quot; =&gt; &quot;info&quot;,
];
$c-&gt;save();
$c = new App\Content;
$c-&gt;type = &#39;link&#39;;
$c-&gt;attributes = [ 
    &quot;type&quot; =&gt; &quot;external&quot;,
    &quot;link&quot; =&gt; &quot;http://example.com&quot;,
];
$c-&gt;save();
$c = new App\Content;
$c-&gt;type = &#39;page&#39;;
$c-&gt;attributes = [ 
    &quot;type&quot; =&gt; &quot;promotional&quot;,
    &quot;title&quot; =&gt; &quot;My page&quot;,
    &quot;content&quot; =&gt; &quot;This is my page&quot;,
    &quot;layout&quot; =&gt; &quot;default&quot;,
];
$c-&gt;save();
</code></pre>
<p>As you can see, we’ve been able to set out whatever arbitrary fields we wish on these items. We can then call <code>toArray()</code> on a model to get all the fields, including the attributes, or we can call <code>$c-&gt;attributes</code> to get all those attributes together. We can also get a field via array access, eg <code>$c-&gt;attributes[&#39;type&#39;]</code>.</p>
<h2 id="querying-the-data">Querying the data</h2>
<p>The syntax for querying JSON fields is a little bit fiddly:</p>
<pre><code class="lang-sql">SELECT * FROM `content` WHERE attributes -&gt; &#39;$.type&#39; = &#39;promotional&#39;;
</code></pre>
<p>Fortunately, Eloquent makes it much simpler:</p>
<pre><code class="lang-php">&lt;?php
Content::where(&#39;attributes-&gt;type&#39;, &#39;promotional&#39;)-&gt;get();
</code></pre>
<p>It’s also possible to order by a JSON field value, but at the time of writing there’s no neat syntax for it, so you have to drop down to writing it using <code>orderByRaw</code> in Eloquent:</p>
<pre><code class="lang-php">&lt;?php
Content::orderByRaw(&quot;attributes-&gt; &#39;$.type&#39;&quot;)-&gt;get();
</code></pre>
<p>Eloquent also supports a few other JSON query types, such as querying if an array contains a value, and I suggest <a href="https://laravel.com/docs/6.x/queries#json-where-clauses">referring to the documentation</a> if you want to know more.</p>
<h2 id="other-applications">Other applications</h2>
<p>There are many other scenarios where this approach can be useful. For instance, e-commerce sites often sell many different products that may have arbitrary properties, and it may be necessary to sort and filter by different properties for different types of products. A store that sells, among other things, shoes and storage containers, might need a colour and capacity field for storage containers, and a colour and size field for shoes. Using this approach, you can set up your database in such a way that those arbitrary fields can be set up when needed, and used for filtering.</p>
<p>This approach is not without its downsides. Any data that’s stored in a JSON field can’t be validated by the database in the same way, so the burden of ensuring that it remains in a consistent state is moved to your application code. However, it’s no worse than it would be if you used a document database, and unlike with a document database you can combine JSON and more traditional fields as you see fit.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Storing Wordpress configuration in environment variables]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/09/22/storing-wordpress-configuration-in-environment-variables/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/09/22/storing-wordpress-configuration-in-environment-variables/</guid>
            <pubDate>Sun, 22 Sep 2019 18:00:34 GMT</pubDate>
            <description><![CDATA[<p>Wordpress configuration can be a serious pain in the proverbial. Hard-coding configuration details in a PHP file is not a terribly safe way of storing the details for your database, as if the server is misconfigured they can be exposed. In addition, it can be a chore to copy and populate the <code>wp-config.php</code> file to a new deploy.</p>
<p>A fundamental principle of <a href="https://12factor.net/">The Twelve-Factor App</a> is that config should be stored in the environment. While Wordpress does predate this, there’s no reason why we can’t abide by this. Storing Wordpress configuration in environment variables rather than the <code>wp-config.php</code> file has the following advantages:</p>
<ul>
<li>It’s more secure since the config is not stored in a file in the web root, but in the web server config</li>
<li>It makes managing the <code>wp-config.php</code> file less of a chore - it can be safely committed to version control, and you won’t need to change it to match your local configuration, running the risk of accidentally committing and pushing to production with broken config</li>
<li>Deployment to new servers is simpler because there’s no need to update the <code>wp-config.php</code></li>
<li>The risk of neglecting to change the database details and accidentally messing up the production database when working locally is virtually eliminated</li>
</ul>
<p>I’ve seen solutions for this that use DotEnv, but you don’t actually need to install that to be able to use environment variables with Wordpress. In fact, in some way it’s better if you don’t as too many developers use <code>.env</code> files in production. PHP natively has the ability to get data from environment variables using the <code>getenv()</code> function, so it’s easier to use that than to pull in a third-party library.</p>
<p>Here’s an abbreviated example of a <code>wp-config.php</code> file that’s been updated to pull the settings from environment variables:</p>
<pre><code class="lang-php">&lt;?php
// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( &#39;DB_NAME&#39;, getenv(&#39;DB_NAME&#39;) );

/** MySQL database username */
define( &#39;DB_USER&#39;, getenv(&#39;DB_USER&#39;) );

/** MySQL database password */
define( &#39;DB_PASSWORD&#39;, getenv(&#39;DB_PASSWORD&#39;) );

/** MySQL hostname */
define( &#39;DB_HOST&#39;, getenv(&#39;DB_HOST&#39;) );

/** Database Charset to use in creating database tables. */
define( &#39;DB_CHARSET&#39;, &#39;utf8&#39; );

/** The Database Collate type. Don&#39;t change this if in doubt. */
define( &#39;DB_COLLATE&#39;, &#39;&#39; );

define( &#39;AUTH_KEY&#39;,         getenv(&#39;AUTH_KEY&#39;) );
define( &#39;SECURE_AUTH_KEY&#39;,  getenv(&#39;SECURE_AUTH_KEY&#39;) );
define( &#39;LOGGED_IN_KEY&#39;,    getenv(&#39;LOGGED_IN_KEY&#39;) );
define( &#39;NONCE_KEY&#39;,        getenv(&#39;NONCE_KEY&#39;) );
define( &#39;AUTH_SALT&#39;,        getenv(&#39;AUTH_SALT&#39;) );
define( &#39;SECURE_AUTH_SALT&#39;, getenv(&#39;SECURE_AUTH_SALT&#39;) );
define( &#39;LOGGED_IN_SALT&#39;,   getenv(&#39;LOGGED_IN_SALT&#39;) );
define( &#39;NONCE_SALT&#39;,       getenv(&#39;NONCE_SALT&#39;) );

$table_prefix = &#39;wp_&#39;;

define( &#39;WP_DEBUG&#39;, getenv(&#39;WP_DEBUG&#39;) );

/* That&#39;s all, stop editing! Happy publishing. */

/** Absolute path to the WordPress directory. */
if ( ! defined( &#39;ABSPATH&#39; ) ) {
    define( &#39;ABSPATH&#39;, dirname( __FILE__ ) . &#39;/&#39; );
}

/** Sets up WordPress vars and included files. */
require_once( ABSPATH . &#39;wp-settings.php&#39; );
</code></pre>
<p>If you’re using Lando for local development, you will need to specify a file to include that contains the environment variables you wish to set, as in this example:</p>
<pre><code class="lang-yaml">name: wordpress
recipe: wordpress
config:
  webroot: .
env_file:
  - .env
</code></pre>
<p>This filename can be any arbitrarily chosen name. Then, you define the values for those variables in the same way you normally would in a <code>.env</code> file. Here’s an abbreviated example that excludes the crypto settings (though those should be placed here too):</p>
<pre><code class="lang-env">DB_NAME=wordpress
DB_USER=wordpress
DB_PASSWORD=wordpress
DB_HOST=database
WP_DEBUG=true
...
</code></pre>
<p>This will work fine during local development, but in production, or if you’re using something like Vagrant for local development, you’ll want to set the environment variables in the server configuration. For Apache, this is best set in the Virtualhost configuration, although you should be able to set it in an <code>.htaccess</code> file if all else fails. You need to use the <code>SetEnv</code> directive, as in this example:</p>
<pre><code class="lang-apache">SetEnv DB_NAME wordpress
SetEnv DB_USER wordpress
SetEnv DB_PASSWORD wordpress
SetEnv DB_HOST database
SetEnv WP_DEBUG true
</code></pre>
<p>For Nginx, assuming you’re using FastCGI, you need to set it in the server configuration for that site using the <code>fastcgi_param</code> directive, as shown below:</p>
<pre><code class="lang-nginx">fastcgi_param DB_NAME wordpress;
fastcgi_param DB_USER wordpress;
fastcgi_param DB_PASSWORD wordpress;
fastcgi_param DB_HOST database;
fastcgi_param WP_DEBUG true;
</code></pre>
<p>Since Wordpress doesn’t ship with any kind of command-line task runner, this should be sufficient for most installs. However, if you’re using WP CLI, that will break it as it won’t have access to environment variables set by Apache or Nginx, so you’ll also need to set them for the user that runs WP CLI by adding them to their Bash config in the usual way.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Using Mix versioning outside Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/09/21/using-mix-versioning-outside-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/09/21/using-mix-versioning-outside-laravel/</guid>
            <pubDate>Sat, 21 Sep 2019 10:30:50 GMT</pubDate>
            <description><![CDATA[<p>Laravel Mix is a really convenient front end scaffold, and not just in the context of a Laravel application. Last year, I added it to a legacy application I maintain, with positive results, and I’m including it in a CMS I’m working on.</p>
<p>However, I’ve always had issues trying to implement versioning outside a Laravel application. I’ve used the timestamp technique described <a href="https://matthewdaly.co.uk/blog/2016/11/26/easy-static-asset-versioning-in-php/">here</a> a lot in the past, but nowadays I do most of my work in a Lando container, and I’ve had a lot of issues with timestamp changes not being picked up, forcing me to restart my container regularly when working on front-end assets. Switching to using Mix versioning seemed like a good way to resolve that issue, but of course the <code>mix()</code> helper isn’t available elsewhere.</p>
<p>Fortunately, its not all that hard to implement your own solution. Under the bonnet, Mix versioning works as follows:</p>
<ul>
<li>The build generates an array of compiled static assets, with the key being the path to the asset, and the value being the path with a query string appended, and then saves it as <code>mix-manifest.json</code></li>
<li>The <code>mix()</code> helper loads the <code>mix-manifest.json</code> file, converts it to JSON, fetches the array entry by path, and then returns the appropriate value for passing back from the helper</li>
</ul>
<p>With that in mind, I wrote the following Twig filter to handle assets versioned with Mix:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types=1);

namespace Project\Core\Views\Filters;

use Exception;

final class Mix
{
    public function __invoke(string $path): string
    {
        $manifest = json_decode(file_get_contents(&#39;mix-manifest.json&#39;), true);
        if (! array_key_exists(&quot;/&quot; . $path, $manifest)) {
            throw new Exception(
                &quot;Unable to locate Mix file: {$path}&quot;
            );
        }
        if (!file_exists($path)) {
            throw new Exception(&#39;Included file does not exist&#39;);
        }
        return $manifest[&quot;/&quot; . $path];
    }
}
</code></pre>
<p>This works on the basis that the web root is set in the <code>public/</code> folder, and that the compiled CSS and Javascript files are placed there - if that’s not the case you may need to adapt this accordingly.</p>
<p>You also need to add the <code>version()</code> call to your <code>webpack.mix.js</code>:</p>
<pre><code class="lang-javascript">const mix = require(&#39;laravel-mix&#39;);

/*
 |--------------------------------------------------------------------------
 | Mix Asset Management
 |--------------------------------------------------------------------------
 |
 | Mix provides a clean, fluent API for defining some Webpack build steps
 | for your Laravel application. By default, we are compiling the Sass
 | file for the application as well as bundling up all the JS files.
 |
 */

mix
  .setPublicPath(&#39;public/&#39;)
  .js(&#39;resources/js/app.js&#39;, &#39;public/js&#39;)
  .sass(&#39;resources/sass/app.scss&#39;, &#39;public/css&#39;)
  .version();
</code></pre>
<p>Then, when you instantiate Twig, you can add the new filter using something like this:</p>
<pre><code class="lang-php">$twig = new Environment($container-&gt;get(&#39;Twig\Loader\FilesystemLoader&#39;), $config);
$mix = $container-&gt;get(&#39;Project\Core\Views\Filters\Mix&#39;);
$twig-&gt;addFilter(new TwigFilter(&#39;mix&#39;, $mix));
</code></pre>
<p>Now, the filter should be usable in your Twig views as shown:</p>
<pre><code class="lang-twig">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;

    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ &#39;css/app.css&#39;| mix }}&quot; /&gt;

    &lt;title&gt;{{ title }}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {% include &#39;header.html&#39; %}
    {% block body %}
    {% endblock %}

    &lt;script src=&quot;{{ &#39;js/app.js&#39;| mix }}&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If you’re using a different framework or templating system, there should be a way to create helpers, and it should be possible to implement this technique fairly easily. I was able to do so in the context of a legacy Zend application, so it should be possible with other legacy frameworks like CodeIgniter.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Setting private properties in tests]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/09/07/setting-private-properties-in-tests/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/09/07/setting-private-properties-in-tests/</guid>
            <pubDate>Sat, 07 Sep 2019 19:16:47 GMT</pubDate>
            <description><![CDATA[<p>Sometimes when writing a test, you come across a situation where you need to set a private field that’s not accessible through any existing route. For instance, I’ve been working with Doctrine a bit lately, and since the ID on an entity is generated automatically, it should not be possible to change it via a setter, but at the same time, we sometimes have the need to set it in a test.</p>
<p>Fortunately, there is a way to do that. Using PHP’s reflection API, you can temporarily mark a property on an object as accessible, so as to be able to set it without either passing it to the constructor or creating a setter method that will only ever be used by the test. We first create a <code>ReflectionClass</code> instance from the object, then get the property. We mark it as accessible, and then set the value on the instance, as shown below:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types = 1);

namespace Tests\Unit;

use Tests\TestCase;
use Project\Document;
use ReflectionClass;

final class DocumentTest extends TestCase
{
    public function testGetId()
    {
        $doc = new Document();
        $reflect = new ReflectionClass($doc);
        $id = $reflect-&gt;getProperty(&#39;id&#39;);
        $id-&gt;setAccessible(true);
        $id-&gt;setValue($doc, 1);
        $this-&gt;assertEquals(1, $doc-&gt;getId());
    }
}
</code></pre>
<p>If you’re likely to need this in more than one place, you may want to pull this functionality out into a trait for reuse:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types = 1);

namespace Tests\Traits;

use ReflectionClass;

trait SetsPrivateProperties
{
    /**
     * Sets a private property
     *
     * @param mixed $object
     * @param string $property
     * @param mixed $value
     * @return void
     */
    public function setPrivateProperty($object, string $property, $value)
    {
        $reflect = new ReflectionClass($object);
        $prop = $reflect-&gt;getProperty($property);
        $prop-&gt;setAccessible(true);
        $prop-&gt;setValue($object, $value);
        $prop-&gt;setAccessible(false);
    }
}
</code></pre>
<p>Then your test can be simplified as follows:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types = 1);

namespace Tests\Unit;

use Tests\TestCase;
use Project\Document;
use Tests\Traits\SetsPrivateProperties;

final class DocumentTest extends TestCase
{
    use SetsPrivateProperties;

    public function testGetId()
    {
        $doc = new Document();
        $this-&gt;setPrivateProperty($doc, &#39;id&#39;, 1);
        $this-&gt;assertEquals(1, $doc-&gt;getId());
    }
}
</code></pre>
<p>While this is a slightly contrived and limited example, and this situation is quite rare, I’ve found it to be a useful technique under certain circumstances.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Skipping environment specific PHPUnit tests]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/07/28/skipping-environment-specific-phpunit-tests/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/07/28/skipping-environment-specific-phpunit-tests/</guid>
            <pubDate>Sun, 28 Jul 2019 19:55:14 GMT</pubDate>
            <description><![CDATA[<p>If you’re doing client work, you don’t generally have to worry too much about working with any services other than those that will be installed in your production environment. For instance, if you’re using Memcached as your cache backend, you needn’t go to the trouble of checking that it works with Redis too unless the project actively switches. However, for more general purpose software that may be deployed to a variety of different environments, you may have to test it in all of those environments, which can be a chore.</p>
<p>Lately I’ve been working on a micro CMS for a personal project, and ran into a bit of an issue. This CMS uses the Stash caching library, and I wanted it to actively support all of the cache backends Stash provides. The CMS is configured using YAML, and I’d written a factory class that takes in the cache configuration and returns an adapter. The problem was that there are three adapters that require additional software to be installed, namely the APC, Redis and Memcached adapters. Installing all the packages to use all three of the adapters is onerous, and while it’s a good idea to test them all, it’s generally not worth the bother of adding all of them to your local development environment where you need your tests to run as fast as possible. Instead you’re better off deferring those tests that require additional dependencies to your continuous integration server, which can afford to be a lot slower.</p>
<p>Fortunately, PHPUnit allows you to mark a test as skipped by calling <code>markTestSkipped()</code>. In the past I’ve used this or the similar <code>markTestIncomplete()</code> method when a test wasn’t finished, but it’s also useful for skipping tests based on the environment. We can either test for the presence of the dependency and mark the test as skipped if it’s not present, or set the test up inside a try…catch block and call <code>markTestSkipped()</code> if the test throws an exception due to a missing dependency, as in this example:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types = 1);

namespace Tests\Unit\Factories;

use Tests\TestCase;
use App\Factories\CacheFactory;
use Stash\Exception\RuntimeException;
use Mockery as m;

final class CacheFactoryTest extends TestCase
{
    public function testRedis()
    {
        $factory = new CacheFactory;
        try {
            $pool = $factory-&gt;make([
                &#39;driver&#39; =&gt; &#39;redis&#39;,
                &#39;servers&#39; =&gt; [[
                    &#39;127.0.0.1&#39;,
                    &#39;6379&#39;
                ]]
            ]);
        } catch (RuntimeException $e) {
            $this-&gt;markTestSkipped(&#39;Dependency not installed&#39;);
        }
        $this-&gt;assertInstanceOf(&#39;Stash\Pool&#39;, $pool);
        $this-&gt;assertInstanceOf(&#39;Stash\Driver\Redis&#39;, $pool-&gt;getDriver());
    }
}
</code></pre>
<p>As a general rule of thumb, when running your tests locally, it’s more important that your test suite run quickly than provide 100% coverage. Tests that are slower or require multiple services to be installed can still be run by your continuous integration server, which can afford to be slower since it’s not a blocker in the same way. In addition, I’m only ever really interested in coverage stats on the CI server, since enabling that slows PHPUnit down a lot, so since coverage is a non-issue locally we can happily leave covering that dependency to our CI server. In this case, the project is hosted on Github and uses Travis CI for running the tests and Coveralls for recording coverage, so we can leave the full test suite to be run on Travis CI, ensuring full coverage, while skipping those tests that require Redis, Memcached or APC locally.</p>
<p>Having a comprehensive test suite, and running it regularly during development, is important, but that doesn’t mean it’s compulsory you run every test regularly. In a case like this, where there are multiple adapters for the same basic functionality, you can often afford to avoid running those that test adapters with more exacting requirements.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Writing golden master tests for Laravel applications]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/05/14/writing-golden-master-tests-for-laravel-applications/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/05/14/writing-golden-master-tests-for-laravel-applications/</guid>
            <pubDate>Tue, 14 May 2019 11:15:17 GMT</pubDate>
            <description><![CDATA[<p>Last year I wrote <a href="https://matthewdaly.co.uk/blog/2018/10/08/an-approach-to-writing-golden-master-tests-for-php-web-applications/">a post illustrating how to write golden master tests for PHP applications in general</a>. This approach works, but has a number of issues:</p>
<ul>
<li>Because it uses a headless browser such as Goutte, it’s inevitably slow (a typical test run for the legacy application I wrote those tests for is 3-4 minutes)</li>
<li>It can’t allow for differing content, so any changes to the content will break the tests</li>
</ul>
<p>These factors limit its utility for many PHP applications. However, for a Laravel application you’re in a much better position:</p>
<ul>
<li>You can use Browserkit rather than a headless browser, resulting in much faster response times</li>
<li>You can set up a testing database, and populate it with the same data each time, ensuring that the only thing that can change is how that data is processed to create the required HTML</li>
</ul>
<p>Here I’ll show you how to adapt that approach to work with a Laravel application.</p>
<p>We rely on Browserkit testing for this approach, so you need to install that:</p>
<pre><code class="lang-bash">$ composer require --dev laravel/browser-kit-testing
</code></pre>
<p>Next, we need to create our base golden master test case:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests;

use Tests\BrowserTestCase;

class GoldenMasterTestCase extends BrowserTestCase
{
    use CreatesApplication;

    public $baseUrl = &#39;http://localhost&#39;;

    protected $snapshotDir = &quot;tests/snapshots/&quot;;

    protected $response;

    protected $path;

    public function goto($path)
    {
        $this-&gt;path = $path;
        $this-&gt;response = $this-&gt;call(&#39;GET&#39;, $path);
        $this-&gt;assertNotEquals(404, $this-&gt;response-&gt;status());
        return $this;
    }

    public function saveHtml()
    {
        if (!$this-&gt;snapshotExists()) {
            $this-&gt;saveSnapshot();
        }
        return $this;
    }

    public function assertSnapshotsMatch()
    {
        $path = $this-&gt;getPath();
        $newHtml = $this-&gt;processHtml($this-&gt;getHtml());
        $oldHtml = $this-&gt;getOldHtml();
        $diff = &quot;&quot;;
        if (function_exists(&#39;xdiff_string_diff&#39;)) {
            $diff = xdiff_string_diff($oldHtml, $newHtml);
        }
        $message = &quot;The path $path does not match the snapshot\n$diff&quot;;
        self::assertThat($newHtml == $oldHtml, self::isTrue(), $message);
    }

    protected function getHtml()
    {
        return $this-&gt;response-&gt;getContent();
    }

    protected function getPath()
    {
        return $this-&gt;path;
    }

    protected function getEscapedPath()
    {
        return $this-&gt;snapshotDir.str_replace(&#39;/&#39;, &#39;_&#39;, $this-&gt;getPath()).&#39;.snap&#39;;
    }

    protected function snapshotExists()
    {
        return file_exists($this-&gt;getEscapedPath());
    }

    protected function processHtml($html)
    {
        return preg_replace(&#39;/(&lt;input type=&quot;hidden&quot;[^&gt;]+\&gt;|&lt;meta name=&quot;csrf-token&quot; content=&quot;([a-zA-Z0-9]+)&quot;&gt;)/i&#39;, &#39;&#39;, $html);
    }

    protected function saveSnapshot()
    {
        $html = $this-&gt;processHtml($this-&gt;getHtml());
        file_put_contents($this-&gt;getEscapedPath(), $html);
    }

    protected function getOldHtml()
    {
        return file_get_contents($this-&gt;getEscapedPath());
    }
}
</code></pre>
<p>The <code>goto()</code> method sets the current path on the object, then fetches the page. It verifies the page was found, and then returns an instance of the object, to allow for method chaining.</p>
<p>Another method of note is the <code>saveHtml()</code> method. This checks to see if the snapshot exists - if not, it saves it. The snapshot is essentially just the HTML returned from that route, but certain content may need to be stripped out, which is done in the <code>processHtml()</code> method. In this case we’ve stripped out hidden fields and the CSRF token meta tag, as CSRF tokens are generated anew each time and will break the snapshots.</p>
<p>The last method we’ll look at is the <code>assertSnapshotsMatch()</code> method. This will get the current HTML, and that for any snapshot for that route, and then compare them. If they differ, it will fail the assertion. In addition, if <code>xdiff_string_diff</code> is available, it will show a diff of the two files - be warned, these can sometimes be large, but they can be helpful in debugging.</p>
<p>Also, note our snapshots directory - <code>tests/snapshots</code>. If you do make a breaking change and want to delete a snapshot, then you can find it in there - the format replaces forward slashes with underscores, and appends a file extension of <code>.snap</code>,  but feel free to customise this to your needs.</p>
<p>Next, we’ll create a test for routes that don’t require authentication, at <code>tests/GoldenMaster/ExampleTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\GoldenMaster;

use Tests\GoldenMasterTestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\User;

class ExampleTest extends GoldenMasterTestCase
{
    use RefreshDatabase;

    /**
     * @dataProvider nonAuthDataProvider
     */
    public function testNonAuthPages($data)
    {
        $this-&gt;goto($data)
            -&gt;saveHtml()
            -&gt;assertSnapshotsMatch();
    }

    public function nonAuthDataProvider()
    {
        return [
            [&#39;/register&#39;],
            [&#39;/login&#39;],
        ];
    }
}
</code></pre>
<p>Note the use of the data provider. We want to be able to step through a list of routes, and verify each in turn, so it makes sense to set up a data provider method as <code>nonAuthDataProvider()</code>, which will return an array of routes. If you haven’t used data providers before, they are an easy way to reduce boilerplate in your tests when you need to test the same thing over and over with different data, and you can learn more <a href="https://tighten.co/blog/tidying-up-your-phpunit-tests-with-data-providers">here</a>.</p>
<p>Now, having seen the methods used, it should be easy to understand <code>testNonAuthPages()</code>. It goes through the following steps:</p>
<ul>
<li>Visit the route passed through, eg <code>/register</code></li>
<li>Save the HTML to a snapshot, if not already saved</li>
<li>Assert that the current content matches the snapshot</li>
</ul>
<p>Using this method, you can test a lot of routes for unexpected changes quite easily. If you’ve used snapshot tests with something like Jest, this is a similar approach.</p>
<h2 id="authenticated-routes">Authenticated routes</h2>
<p>This won’t quite work with authenticated routes, so a few more changes are required. You’ll get a response, but if you look at the HTML it will clearly show the user is being redirected for all of them, so there’s not much point in testing them.</p>
<p>If your content does not differ between users, you can add the trait <code>Illuminate\Foundation\Testing\WithoutMiddleware</code> to your test to disable the authentication and allow the test to get the content without being redirected.</p>
<p>If, however, your content does differ between users, you need to instead create a user object, and use the <code>actingAs()</code> method already available in Laravel tests to set the user, as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\GoldenMaster;

use Tests\GoldenMasterTestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\User;

class ExampleTest extends GoldenMasterTestCase
{
    use RefreshDatabase;

    /**
     * @dataProvider authDataProvider
     */
    public function testAuthPages($data)
    {
        $user = factory(User::class)-&gt;create([
            &#39;email&#39; =&gt; &#39;eric@example.com&#39;,
            &#39;name&#39; =&gt; &#39;Eric Smith&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;
        ]);
        $this-&gt;actingAs($user)
            -&gt;goto($data)
            -&gt;saveHtml()
            -&gt;assertSnapshotsMatch();
    }

    public function authDataProvider()
    {
        return [
            [&#39;/&#39;],
        ];
    }
}
</code></pre>
<p>This will allow us to visit a specific page as a user, without being redirected.</p>
<h2 id="summary">Summary</h2>
<p>This can be a useful technique to catch unexpected breakages in applications, particularly ones which have little or no conventional test coverage. While I originated this technique on a Zend 1 legacy code base, leveraging the tools available in Laravel makes this technique much faster and more useful. If your existing Laravel application is not as well tested as you’d like, and you have some substantial changes to make that risk breaking some of the functionality, having these sorts of golden master tests set up can be a quick and easy way of catching any problems as soon as possible.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating your own dependency injection container in PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/02/02/creating-your-own-dependency-injection-container-in-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/02/02/creating-your-own-dependency-injection-container-in-php/</guid>
            <pubDate>Sat, 02 Feb 2019 20:45:52 GMT</pubDate>
            <description><![CDATA[<p>Dependency injection can be a difficult concept to understand in the early stages. Even when you’re using it all the time, it can often seem like magic. However, it’s really not all that complicated once you actually get into the nuts and bolts of it, and building your own container is a good way to learn more about how it works and how to use it.</p>
<p>In this tutorial, I’ll walk you through creating a simple, minimal dependency injection container, using PHPSpec as part of a TDD workflow. While the end result isn’t necessarily something I’d be happy using in a production environment, it’s sufficient to understand the basic concept and make it feel less like a black box. Our container will be called Ernie (if you want to know why, it’s a reference to a 90’s era video game that had a character based on Eric Cantona called Ernie Container).</p>
<p>The first thing we need to do is set up our dependencies. Our container will implement PSR-11, so we need to include the interface that defines that. We’ll also use PHP CodeSniffer to ensure code quality, and PHPSpec for testing. Your <code>composer.json</code> should look something like this:</p>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;matthewbdaly/ernie&quot;,
    &quot;description&quot;: &quot;Simple DI container&quot;,
    &quot;type&quot;: &quot;library&quot;,
    &quot;require-dev&quot;: {
        &quot;squizlabs/php_codesniffer&quot;: &quot;^3.3&quot;,
        &quot;phpspec/phpspec&quot;: &quot;^5.0&quot;,
        &quot;psr/container&quot;: &quot;^1.0&quot;
    },
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;authors&quot;: [
        {
            &quot;name&quot;: &quot;Matthew Daly&quot;,
            &quot;email&quot;: &quot;450801+matthewbdaly@users.noreply.github.com&quot;
        }
    ],
    &quot;require&quot;: {},
    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;Matthewbdaly\\Ernie\\&quot;: &quot;src/&quot;
        }
    }
}
</code></pre>
<p>We also need to put this in our <code>phpspec.yml</code> file:</p>
<pre><code class="lang-yml">suites:
    test_suite:
        namespace: Matthewbdaly\Ernie
        psr4_prefix: Matthewbdaly\Ernie
</code></pre>
<p>With that done, we can start working on our implementation.</p>
<h1 id="creating-the-exceptions">Creating the exceptions</h1>
<p>The PSR-11 specification defines two interfaces for exceptions, which we will implement before actually moving on to the container itself. The first of these is <code>Psr\Container\ContainerExceptionInterface</code>. Run the following command to create a basic spec for the exception:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Exceptions/ContainerException
</code></pre>
<p>The generated specification for it at <code>spec/Exceptions/ContainerExceptionSpec.php</code> will look something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Ernie;

use Matthewbdaly\Ernie\ContainerException;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ContainerExceptionSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(ContainerException::class);
    }
}
</code></pre>
<p>This is not sufficient for our needs. Our exception must also implement two interfaces:</p>
<ul>
<li><code>Throwable</code></li>
<li><code>Psr\Container\ContainerExceptionInterface</code></li>
</ul>
<p>The former can be resolved by inheriting from <code>Exception</code>, while the latter doesn’t require any additional methods. Let’s expand our spec to check for these:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Ernie\Exceptions;

use Matthewbdaly\Ernie\Exceptions\ContainerException;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ContainerExceptionSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(ContainerException::class);
    }

    function it_implements_interface()
    {
        $this-&gt;shouldImplement(&#39;Psr\Container\ContainerExceptionInterface&#39;);
    }

    function it_implements_throwable()
    {
        $this-&gt;shouldImplement(&#39;Throwable&#39;);
    }
}
</code></pre>
<p>Now run the spec and PHPSpec will generate the boilerplate exception for you:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Ernie/Exceptions/ContainerException                                
  11  - it is initializable
      class Matthewbdaly\Ernie\Exceptions\ContainerException does not exist.

Matthewbdaly/Ernie/Exceptions/ContainerException                                  
  16  - it implements interface
      class Matthewbdaly\Ernie\Exceptions\ContainerException does not exist.

Matthewbdaly/Ernie/Exceptions/ContainerException                                
  21  - it implements throwable
      class Matthewbdaly\Ernie\Exceptions\ContainerException does not exist.

                                      100%                                       3
1 specs
3 examples (3 broken)
23ms


  Do you want me to create `Matthewbdaly\Ernie\Exceptions\ContainerException`   
  for you?                                                                      
                                                                         [Y/n]
y
Class Matthewbdaly\Ernie\Exceptions\ContainerException created in /home/matthew/Projects/ernie-clone/src/Exceptions/ContainerException.php.

Matthewbdaly/Ernie/Exceptions/ContainerException                                
  16  - it implements interface
      expected an instance of Psr\Container\ContainerExceptionInterface, but got
      [obj:Matthewbdaly\Ernie\Exceptions\ContainerException].

Matthewbdaly/Ernie/Exceptions/ContainerException                                
  21  - it implements throwable
      expected an instance of Throwable, but got
      [obj:Matthewbdaly\Ernie\Exceptions\ContainerException].

            33%                                     66%                          3
1 specs
3 examples (1 passed, 2 failed)
36ms
</code></pre>
<p>It’s failing, but we expect that. We need to update our exception to extend the base PHP exception, and implement <code>Psr\Container\ContainerExceptionInterface</code>. Let’s do that now:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Ernie\Exceptions;

use Psr\Container\ContainerExceptionInterface;
use Exception;

class ContainerException extends Exception implements ContainerExceptionInterface
{
}
</code></pre>
<p>Let’s re-run the spec:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       3
1 specs
3 examples (3 passed)
24ms
</code></pre>
<p>The second exception we need to implement is <code>Psr\Container\NotFoundExceptionInterface</code> and it’s a similar story. Run the following command to create the spec:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Exceptions/NotFoundException
</code></pre>
<p>Again, the spec needs to be amended to verify that it’s a throwable and implements the required interface:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Ernie\Exceptions;

use Matthewbdaly\Ernie\Exceptions\NotFoundException;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class NotFoundExceptionSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(NotFoundException::class);
    }

    function it_implements_interface()
    {
        $this-&gt;shouldImplement(&#39;Psr\Container\NotFoundExceptionInterface&#39;);
    }

    function it_implements_throwable()
    {
        $this-&gt;shouldImplement(&#39;Throwable&#39;);
    }
}
</code></pre>
<p>For the sake of brevity I’ve left out the output, but if you run <code>vendor/bin/phpspec run</code> you’ll see it fail due to the fact that the generated class doesn’t implement the required interfaces. Amend <code>src/Exceptions/NotFoundException</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Ernie\Exceptions;

use Psr\Container\NotFoundExceptionInterface;
use Exception;

class NotFoundException extends Exception implements NotFoundExceptionInterface
{
}
</code></pre>
<p>Running <code>vendor/bin/phpspec run</code> should now see it pass. Now let’s move on to the container class…</p>
<h1 id="building-the-container">Building the container</h1>
<p>Run the following command to create the container spec:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec desc Matthewbdaly/Ernie/Container
</code></pre>
<p>However, the default generated spec isn’t sufficient. We need to check it implements the required interface:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Ernie;

use Matthewbdaly\Ernie\Container;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ContainerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Container::class);
    }

    function it_implements_interface()
    {
        $this-&gt;shouldImplement(&#39;Psr\Container\ContainerInterface&#39;);
    }
}
</code></pre>
<p>Now, if we run PHPSpec, we’ll generate our class:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Ernie/Container                                                    
  11  - it is initializable
      class Matthewbdaly\Ernie\Container does not exist.

Matthewbdaly/Ernie/Container                                                      
  16  - it implements interface
      class Matthewbdaly\Ernie\Container does not exist.

                            75%                                     25%          8
3 specs
8 examples (6 passed, 2 broken)
404ms


  Do you want me to create `Matthewbdaly\Ernie\Container` for you?              
                                                                         [Y/n] 
y
Class Matthewbdaly\Ernie\Container created in /home/matthew/Projects/ernie-clone/src/Container.php.

Matthewbdaly/Ernie/Container                                                      
  16  - it implements interface
      expected an instance of Psr\Container\ContainerInterface, but got
      [obj:Matthewbdaly\Ernie\Container].

                                 87%                                     12%     8
3 specs
8 examples (7 passed, 1 failed)
40ms
</code></pre>
<p>Now, as we can see, this class doesn’t implement the interface. Let’s remedy that:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Ernie;

use Psr\Container\ContainerInterface;

class Container implements ContainerInterface
{
}
</code></pre>
<p>Now, if we run the tests, they should fail because the class needs to add the required methods:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
✘ Fatal error happened while executing the following 
    it is initializable 
    Class Matthewbdaly\Ernie\Container contains 2 abstract methods and must therefore be declared abstract or implement the remaining methods (Psr\Container\ContainerInterface::get, Psr\Container\ContainerInterface::has) in /home/matthew/Projects/ernie-clone/src/Container.php on line 7 
</code></pre>
<p>If you use an editor or IDE that allows you to implement an interface automatically, you can run it to add the required methods. I use PHPActor with Neovim, and used the option in the Transform menu to implement the contract:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Ernie;

use Psr\Container\ContainerInterface;

class Container implements ContainerInterface
{
    /**
     * {@inheritDoc}
     */
    public function get($id)
    {
    }

    /**
     * {@inheritDoc}
     */
    public function has($id)
    {
    }
}
</code></pre>
<p>Running <code>vendor/bin/phpspec run</code> should now make the spec pass, but the methods don’t actually do anything yet. If you read the spec for PSR-11, you’ll see that <code>has()</code> returns a boolean to indicate whether a class can be instantiated or not, while <code>get()</code> will either return an instance of the specified class, or throw an exception. We will add specs that check that built-in classes can be returned by both, and unknown classes display the expected behaviour. We’ll do both at once, because in both cases, the functionality to actually resolve the required class will be deferred to a single resolver method, and these methods will not do all that much as a result:</p>
<pre><code class="lang-php">    function it_has_simple_classes()
    {
        $this-&gt;has(&#39;DateTime&#39;)-&gt;shouldReturn(true);
    }

    function it_does_not_have_unknown_classes()
    {
        $this-&gt;has(&#39;UnknownClass&#39;)-&gt;shouldReturn(false);
    }

    function it_can_get_simple_classes()
    {
        $this-&gt;get(&#39;DateTime&#39;)-&gt;shouldReturnAnInstanceOf(&#39;DateTime&#39;);
    }

    function it_returns_not_found_exception_if_class_cannot_be_found()
    {
        $this-&gt;shouldThrow(&#39;Matthewbdaly\Ernie\Exceptions\NotFoundException&#39;)
            -&gt;duringGet(&#39;UnknownClass&#39;);
    }
</code></pre>
<p>These tests verify that:</p>
<ul>
<li><code>has()</code> returns <code>true</code> when called with the always-present <code>DateTime</code> class</li>
<li><code>has()</code> returns <code>false</code> for the undefined <code>UnknownClass</code></li>
<li><code>get()</code> successfully instantiates an instance of <code>DateTime</code></li>
<li><code>get()</code> throws an exception if you try to instantiate the undefined <code>UnknownClass</code></li>
</ul>
<p>Running the specs will raise errors:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Ernie/Container                                                      
  21  - it has simple classes
      expected true, but got null.

Matthewbdaly/Ernie/Container                                                    
  26  - it does not have unknown classes
      expected false, but got null.

Matthewbdaly/Ernie/Container                                                    
  31  - it can get simple classes
      expected an instance of DateTime, but got null.

Matthewbdaly/Ernie/Container                                                    
  36  - it returns not found exception if class cannot be found
      expected to get exception / throwable, none got.

                         66%                                     33%             12
3 specs
12 examples (8 passed, 4 failed)
98ms
</code></pre>
<p>Let’s populate these empty methods:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Ernie;

use Psr\Container\ContainerInterface;
use Matthewbdaly\Ernie\Exceptions\NotFoundException;
use ReflectionClass;
use ReflectionException;

class Container implements ContainerInterface
{
    /**
     * {@inheritDoc}
     */
    public function get($id)
    {
        $item = $this-&gt;resolve($id);
        return $this-&gt;getInstance($item);
    }

    /**
     * {@inheritDoc}
     */
    public function has($id)
    {
        try {
            $item = $this-&gt;resolve($id);
        } catch (NotFoundException $e) {
            return false;
        }
        return $item-&gt;isInstantiable();
    }

    private function resolve($id)
    {
        try {
            return (new ReflectionClass($id));
        } catch (ReflectionException $e) {
            throw new NotFoundException($e-&gt;getMessage(), $e-&gt;getCode(), $e);
        }
    }

    private function getInstance(ReflectionClass $item)
    {
        return $item-&gt;newInstance();
    }
}
</code></pre>
<p>As you can see, both the <code>has()</code> and <code>get()</code> methods need to resolve a string ID to an actual class, so that common functionality is stored in a private method called <code>resolve()</code>. This uses the <a href="http://php.net/manual/en/book.reflection.php">PHP Reflection API</a> to resolve the class name to an actual class. We pass the string ID into a constructor of <code>ReflectionClass</code>, and the <code>resolve()</code> method will either return the created instance of <code>ReflectionClass</code>, or throw an exception.</p>
<p>For the uninitiated, <code>ReflectionClass</code> allows you to reflect on the object whose fully qualified class name is passed to the constructor, in order to interact with that class programmatically. The methods we will use include:</p>
<ul>
<li><code>isInstantiable</code> - confirms whether or not the class can be instantiated (for instance, traits and abstract classes can’t)</li>
<li><code>newInstance</code> - creates a new instance of the item in question, as long as it has no dependencies in the constructor</li>
<li><code>newInstanceArgs</code> - creates a new instance, using the arguments passed in</li>
<li><code>getConstructor</code> - allows you to get information about the constructor</li>
</ul>
<p>The Reflection API is pretty comprehensive, and I would recommend reading the documentation linked to above if you want to know more.</p>
<p>For the <code>has()</code> method, we check that the resolved class is instantiable, and return the result of that. For the <code>get()</code> method, we use <code>getInstance()</code> to instantiate the item and return that, throwing an exception if that fails.</p>
<h1 id="registering-objects">Registering objects</h1>
<p>In its current state, the container doesn’t allow you to set an item. To be useful, we need to be able to specify that an interface or string should be resolved to a given class, or for cases where we need to pass in scalar parameters, such as a database object, to specify how a concrete instance of that class should be instantiated. To that end, we’ll create a new <code>set()</code> public method that will allow a dependency to be set. Here are the revised specs including this:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Ernie;

use Matthewbdaly\Ernie\Container;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use DateTime;

class ContainerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Container::class);
    }

    function it_implements_interface()
    {
        $this-&gt;shouldImplement(&#39;Psr\Container\ContainerInterface&#39;);
    }

    function it_has_simple_classes()
    {
        $this-&gt;has(&#39;DateTime&#39;)-&gt;shouldReturn(true);
    }

    function it_does_not_have_unknown_classes()
    {
        $this-&gt;has(&#39;UnknownClass&#39;)-&gt;shouldReturn(false);
    }

    function it_can_get_simple_classes()
    {
        $this-&gt;get(&#39;DateTime&#39;)-&gt;shouldReturnAnInstanceOf(&#39;DateTime&#39;);
    }

    function it_returns_not_found_exception_if_class_cannot_be_found()
    {
        $this-&gt;shouldThrow(&#39;Matthewbdaly\Ernie\Exceptions\NotFoundException&#39;)
            -&gt;duringGet(&#39;UnknownClass&#39;);
    }

    function it_can_register_dependencies()
    {
        $toResolve = new class {
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve)-&gt;shouldReturn($this);
    }

    function it_can_resolve_registered_dependencies()
    {
        $toResolve = new class {
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf($toResolve);
    }

    function it_can_resolve_registered_invokable()
    {
        $toResolve = new class {
            public function __invoke() {
                return new DateTime;
            }
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf(&#39;DateTime&#39;);
    }

    function it_can_resolve_registered_callable()
    {
        $toResolve = function () {
            return new DateTime;
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf(&#39;DateTime&#39;);
    }

    function it_can_resolve_if_registered_dependencies_instantiable()
    {
        $toResolve = new class {
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;has(&#39;Foo\Bar&#39;)-&gt;shouldReturn(true);
    }
}
</code></pre>
<p>This needs to handle quite a few scenarios, so there are several tests we have in place. These verify that:</p>
<ul>
<li>The <code>set()</code> method returns an instance of the container class, to allow for method chaining</li>
<li>When a dependency is set, calling <code>get()</code> returns an instance of that class</li>
<li>When a concrete class that has the <code>__invoke()</code> magic method set is passed to <code>set()</code>, it is invoked and the response returned.</li>
<li>When the value passed through is a callback, the callback is resolved and the response returned</li>
<li>When a dependency is set, calling <code>has()</code> for it returns the right value</li>
</ul>
<p>Note that we use anonymous classes for testing - I’ve written about these before and they’re very useful in this context because they allow us to create a simple class inline for testing purposes.</p>
<p>Running the specs should result in us being prompted to generate the <code>set()</code> method, and failing afterwards:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Ernie/Container                                                    
  42  - it can register dependencies
      method Matthewbdaly\Ernie\Container::set not found.

Matthewbdaly/Ernie/Container                                                    
  49  - it can resolve registered dependencies
      method Matthewbdaly\Ernie\Container::set not found.

Matthewbdaly/Ernie/Container                                                    
  57  - it can resolve registered invokable
      method Matthewbdaly\Ernie\Container::set not found.

Matthewbdaly/Ernie/Container                                                    
  68  - it can resolve registered callable
      method Matthewbdaly\Ernie\Container::set not found.

Matthewbdaly/Ernie/Container                                                    
  77  - it can resolve if registered dependencies instantiable
      method Matthewbdaly\Ernie\Container::set not found.

                          70%                                     29%            17
3 specs
17 examples (12 passed, 5 broken)
316ms

  Do you want me to create `Matthewbdaly\Ernie\Container::set()` for you?       
                                                                         [Y/n]
y
  Method Matthewbdaly\Ernie\Container::set() has been created.

Matthewbdaly/Ernie/Container                                                    
  42  - it can register dependencies
      expected [obj:Matthewbdaly\Ernie\Container], but got null.

Matthewbdaly/Ernie/Container                                                    
  49  - it can resolve registered dependencies
      exception [exc:Matthewbdaly\Ernie\Exceptions\NotFoundException(&quot;Class Foo\Bar does not exist&quot;)] has been thrown.

Matthewbdaly/Ernie/Container                                                    
  57  - it can resolve registered invokable
      exception [exc:Matthewbdaly\Ernie\Exceptions\NotFoundException(&quot;Class Foo\Bar does not exist&quot;)] has been thrown.

Matthewbdaly/Ernie/Container                                                    
  68  - it can resolve registered callable
      exception [exc:Matthewbdaly\Ernie\Exceptions\NotFoundException(&quot;Class Foo\Bar does not exist&quot;)] has been thrown.

Matthewbdaly/Ernie/Container                                                    
  77  - it can resolve if registered dependencies instantiable
      expected true, but got false.

                          70%                              11%        17%        17
3 specs
17 examples (12 passed, 2 failed, 3 broken)
90ms
</code></pre>
<p>First, we need to set up the <code>set()</code> method properly, and define a property to contain the stored services:</p>
<pre><code class="lang-php">    private $services = [];

    public function set(string $key, $value)
    {
        $this-&gt;services[$key] = $value;
        return $this;
    }
</code></pre>
<p>This fixes the first spec, but the resolver needs to be amended to handle cases where the ID is set manually:</p>
<pre><code class="lang-php">    private function resolve($id)
    {
        try {
            $name = $id;
            if (isset($this-&gt;services[$id])) {
                $name = $this-&gt;services[$id];
                if (is_callable($name)) {
                    return $name();
                }
            }
            return (new ReflectionClass($name));
        } catch (ReflectionException $e) {
            throw new NotFoundException($e-&gt;getMessage(), $e-&gt;getCode(), $e);
        }
    }
</code></pre>
<p>This will allow us to resolve classes set with <code>set()</code>. However, we also want to resolve any callables, such as callbacks or classes that implement the <code>__invoke()</code> magic method, which means that sometimes <code>resolve()</code> will return the result of the callable instead of an instance of <code>ReflectionClass</code>. Under those circumstances we should return the item directly:</p>
<pre><code class="lang-php">    public function get($id)
    {
        $item = $this-&gt;resolve($id);
        if (!($item instanceof ReflectionClass)) {
            return $item;
        }
        return $this-&gt;getInstance($item);
    }
</code></pre>
<p>Note that because the <code>__invoke()</code> method is automatically called in any concrete class specified in the second argument to <code>set()</code>, it’s only possible to resolve classes that define an <code>__invoke()</code> method if they are passed in as string representations. The following PsySh session should make it clear what this means:</p>
<pre><code class="lang-php">&gt;&gt;&gt; use Matthewbdaly\Ernie\Container;
&gt;&gt;&gt; $c = new Container;
=&gt; Matthewbdaly\Ernie\Container {#2307}
&gt;&gt;&gt; class TestClass { public function __invoke() { return &quot;Called&quot;; }}
&gt;&gt;&gt; $c-&gt;get(&#39;TestClass&#39;);
=&gt; TestClass {#2319}
&gt;&gt;&gt; $c-&gt;set(&#39;Foo\Bar&#39;, &#39;TestClass&#39;);
=&gt; Matthewbdaly\Ernie\Container {#2307}
&gt;&gt;&gt; $c-&gt;get(&#39;Foo\Bar&#39;);
=&gt; TestClass {#2309}
&gt;&gt;&gt; $c-&gt;set(&#39;Foo\Bar&#39;, new TestClass);
=&gt; Matthewbdaly\Ernie\Container {#2307}
&gt;&gt;&gt; $c-&gt;get(&#39;Foo\Bar&#39;);
=&gt; &quot;Called&quot;
</code></pre>
<p>As you can see, if we pass in the fully qualified class name of a class that defines an <code>__invoke()</code> method, it can be resolved as expected. However, if we pass a concrete instance of it to <code>set()</code>, it will be called and will return the response from that. This may not be the behaviour you want for your own container.</p>
<p>According to <a href="https://github.com/thephpleague/container/issues/113">this issue on the PHP League’s Container implementation</a>, it was also an issue for them, so seeing as this is just a toy example I’m not going to lose any sleep over it. Just something to be aware of if you use this post as the basis for writing your own container.</p>
<h1 id="resolving-dependencies">Resolving dependencies</h1>
<p>One thing is missing from our container. Right now it should be able to instantiate pretty much any class that has no dependencies, but these are quite firmly in the minority. To be useful, a container should be able to resolve all of the dependencies for a class automatically.</p>
<p>Let’s add a spec for that:</p>
<pre><code class="lang-php">    function it_can_resolve_dependencies()
    {
        $toResolve = get_class(new class(new DateTime) {
            public $datetime;
            public function __construct(DateTime $datetime)
            {
                $this-&gt;datetime = $datetime;
            }
        });
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf($toResolve);
    }
</code></pre>
<p>Here we have to be a bit crafty. Anonymous classes are defined and instantiated at the same time, so we can’t pass it in as an anonymous class in the test. Instead, we call the anonymous class and get its name, then set that as the second argument to <code>set()</code>. Then we can verify that the returned object is an instance of the same class.</p>
<p>Running this throws an error:</p>
<pre><code class="lang-php">$ vendor/bin/phpspec run
Matthewbdaly/Ernie/Container                                                    
  86  - it can resolve dependencies
      exception [err:ArgumentCountError(&quot;Too few arguments to function class@anonymous::__construct(), 0 passed and exactly 1 expected&quot;)] has been thrown.

                                    94%                                          18
3 specs
18 examples (17 passed, 1 broken)
60ms
</code></pre>
<p>This is expected. Our test class accepts an instance of <code>DateTime</code> in the constructor as a mandatory dependency, so instantiating it fails. We need to update the <code>getInstance()</code> method so that it can handle pulling in any dependencies:</p>
<pre><code class="lang-php">    private function getInstance(ReflectionClass $item)
    {
        $constructor = $item-&gt;getConstructor();
        if (is_null($constructor) || $constructor-&gt;getNumberOfRequiredParameters() == 0) {
            return $item-&gt;newInstance();
        }
        $params = [];
        foreach ($constructor-&gt;getParameters() as $param) {
            if ($type = $param-&gt;getType()) {
                $params[] = $this-&gt;get($type-&gt;getName());
            }
        }
        return $item-&gt;newInstanceArgs($params);
    }
</code></pre>
<p>Here, we use the Reflection API to get the constructor. If there’s no constructor, or it has no required parameters, we just return a new instance of the reflected class as before.</p>
<p>Otherwise, we loop through the required parameters. For each parameter, we get the string representation of the type specified for that parameter, and retrieve an instance of it from the container. Afterwards, we use those parameters to instantiate the object.</p>
<p>Let’s run the specs again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       18
3 specs
18 examples (18 passed)
51ms
</code></pre>
<p>Our container is now complete. We can:</p>
<ul>
<li>Resolve simple classes out of the box</li>
<li>Set arbitrary keys to resolve to particular classes, or the result of callables, so as to enable mapping interfaces to concrete implementations, or resolve classes that require specific non-object parameters, such as PDO</li>
<li>Resolve complex classes with multiple dependencies</li>
</ul>
<p>Not too bad for just over 100 lines of PHP…</p>
<h1 id="final-thoughts">Final thoughts</h1>
<p>As I’ve said, this is a pretty minimal example of a dependency injection container, and I wouldn’t advise using this in production when there are so many existing, mature solutions available. I have no idea how the performance would stack up against existing solutions, or whether there are any issues with it, and quite frankly that’s besides the point - this is intended as a learning exercise to understand how dependency injection containers in general work, not as an actual useful piece of code for production. If you want an off-the-shelf container, I’d point you in the direction of <code>league/container</code>, which has served me well.</p>
<p>You can find the code for this tutorial on <a href="https://github.com/matthewbdaly/ernie">GitHub</a>, so if you have any problems, you should take a look there to see where the problem lies. Of course, if you go on to create your own kick-ass container based on this, do let me know!</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Understanding query objects]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/01/27/understanding-query-objects/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/01/27/understanding-query-objects/</guid>
            <pubDate>Sun, 27 Jan 2019 23:10:39 GMT</pubDate>
            <description><![CDATA[<p>The project I’ve been maintaining for the last year has inherited a rather dubious database structure that would currently be very difficult to refactor, which also makes many queries more convoluted than they should be. At present, I’m involved in building a whole new home page, which has necessitated adding some new queries. Since some of these involve carrying out unions between several similar tables (that should have been one table, grr…), they can involve some quite large chunks for each query.</p>
<p>As a result, it’s made sense to break those queries down further. Since Zend 1 doesn’t have anything analogous to scopes in Eloquent, I don’t really have an easy way to break these queries up in the models (and I’m trying to get the query logic out of the models at present anyway), so I opted to make them into query objects instead, which is a pattern I hadn’t used before (but probably should have).</p>
<p>A query object is pretty much what it says on the tin - it’s a PHP object that executes a single, very specific query. This may seem like overkill, but it’s only really useful for the most complex and convoluted of queries. It can accept parameters, as you’d expect, and some parts of the query may be optional based on that, but fundamentally it should build and run only one single query.</p>
<p>In this post I’ll go through how you might create one, how it relates to the repository pattern, and when to create one.</p>
<h1 id="creating-a-query-object-class">Creating a query object class</h1>
<p>I’m a big fan of the <code>__invoke()</code> magic method in PHP. For the uninitiated, it lets you instantiate the class, and then use it in the same way you would a function, making it very useful for callbacks. This also brings some other advantages:</p>
<ul>
<li>Unlike with a function, you can create private methods to do other parts of the work, making it easier to understand the main method.</li>
<li>It can have a constructor, and can therefore both accept dependencies via the constructor, and be instantiated via dependency injection, simplifying setup and testing when compared to using a callback.</li>
<li>Since <code>__invoke()</code> is an innate part of the PHP language, it makes more sense for classes that have a single responsibility to use that method name to do that, rather than picking something like <code>handle()</code> or <code>run()</code>.</li>
</ul>
<p>As a result, my query objects generally use the <code>__invoke()</code> method to trigger the query.</p>
<p>Since Zend 1 is no longer supported, I won’t bother displaying how I’d write the query in that specific context. I have yet to use this pattern with Laravel, but if I did, it would look something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Queries;

use Illuminate\Database\DatabaseManager;

final class DashboardItems
{
    protected $db;

    public function __construct(DatabaseManager $db)
    {
        $this-&gt;db = $db;
    }

    public function __invoke(int $days = 7)
    {
        return $this-&gt;fooTable()
            -&gt;union($this-&gt;barTable())
            -&gt;whereRaw(&#39;start_date &gt;= (NOW() - INTERVAL ? DAY)&#39;, [$days]);
            -&gt;get();
    }

    private function fooTable()
    {
        return $this-&gt;db-&gt;table(&#39;foo&#39;)
            -&gt;where(&#39;type&#39;, &#39;=&#39;, &#39;fooType&#39;);
    }

    private function barTable(int $days)
    {
        return $this-&gt;db-&gt;table(&#39;bar&#39;)
            -&gt;where(&#39;type&#39;, &#39;=&#39;, &#39;barType&#39;);
    }
}
</code></pre>
<p>Note that we break each one of the tables we want to perform a <code>UNION</code> on into a private method. This is probably the biggest advantage of query objects - it lets you break particularly unwieldy queries up into logical steps, making them more readable. You could do this by adding private methods on a repository class too, but I’d be reluctant to add private methods to a repository that were only used in one query - to my mind, a query object is a better home for that.</p>
<h1 id="what-about-repositories-">What about repositories?</h1>
<p>I regularly use the repository pattern in my code bases, whether that’s for Laravel projects or the current Zend 1-based legacy project. It’s an ongoing effort to refactor it so that all the queries are called from repository classes, leaving the models to act as containers for the data. So how do query objects fit in here?</p>
<p>It’s important to note that while a repository represents all queries relating to a table, a query object represents only a single query, and so the repository should still be the place where the query is called from. However, the repository should just defer the actual querying to the query object. The relevant parts of the application structure for my current application look a bit like this:</p>
<pre><code class="lang-bash">└── app
    ├── Queries
    │   └── DashboardItems.php
    └── Repositories
        └── DashboardRepository.php
</code></pre>
<p>And the repository might call the query object as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories;

use App\Queries\DashboardItems;

final class DashboardRepository
{
    public static function dashboardItems(int $days = 7)
    {
        $query = new DashboardItems;
        return $query($days);
    }
}
</code></pre>
<p>At present my repositories all use static methods as I’m still in the process of migrating the queries over to the repository classes. That also means I can’t easily use dependency injection. For a Laravel application, a similar call might look like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories;

use App\Queries\DashboardItems;

final class DashboardRepository
{
    protected $dashboardQuery;

    public function __construct(DashboardItems $dashboardQuery)
    {
        $this-&gt;dashboardQuery = $dashboardQuery;
    }

    public function dashboardItems(int $days = 7)
    {
        return $this-&gt;dashboardQuery($days);
    }
}
</code></pre>
<p>The only real difference is that we can instantiate the query object out of the container, simplifying setup.</p>
<h1 id="when-to-use-query-objects">When to use query objects</h1>
<p>I think it probably goes without saying, but it should be a rare query that actually needs to be implemented as a query object, especially if you’re using an ORM like Eloquent that provides features like scopes, and as yet I only have two using this pattern, as well as two others that were implemented as “reporter” classes, but could be query objects instead. So far, my experience has been that the sort of queries that are large enough to be worth considering include:</p>
<ul>
<li>Queries that generate reports, particularly if they have various options</li>
<li>Queries that use unions, as in the above example, since it makes sense to use a private method to fetch each table</li>
<li>Queries with multiple complex joins</li>
</ul>
<p>Smaller queries will typically fit happily inside a single method in your repository classes. If that’s the case, then they can live there without trouble. However, if you have a query that’s becoming too big to fit inside a single method, rather than adding private methods to your repository class, it may make more sense to refactor it out into a query object in its own right. You can still call it via the same method on your repository class, but the repository can just defer to the query object. As I usually use decorators to cache the responses from my repository classes anyway, then it makes sense to stick with this approach to keep caching consistent too.</p>
<p>Query objects only really offer any value for particularly large queries. However, they can be invaluable in those circumstances. By enabling you to break those big queries up into a series of steps, they help make them easier to understand.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Writing a custom sniff for PHP CodeSniffer]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/01/13/writing-a-custom-sniff-for-php-codesniffer/</guid>
            <pubDate>Sun, 13 Jan 2019 18:50:45 GMT</pubDate>
            <description><![CDATA[<p>I’ve recently come around to the idea that <a href="https://matthiasnoback.nl/2018/09/final-classes-by-default-why/">in PHP all classes should be final by default</a>, and have started doing so as a matter of course. However, when you start doing something like this it’s easy to miss a few files that haven’t been updated, or forget to do it, so I wanted a way to detect PHP classes that are not set as either abstract or final, and if possible, set them as final automatically. I’ve mentioned before that I use PHP CodeSniffer extensively, and that has the capability to both find and resolve deviations from a coding style, so last night I started looking into the possibility of creating a coding standard for this. It took a little work to understand how to do this so I thought I’d use this sniff as a simple example.</p>
<p>The first part is to set out the directory structure. There’s a very specific layout you have to follow for PHP CodeSniffer:</p>
<ul>
<li>The folder for the standard must have the name of the standard, and be in the source folder set by Composer (in this case, <code>src/AbstractOrFinalClassesOnly</code>.</li>
<li>This folder must contain a <code>ruleset.xml</code> file defining the name and description of the standard, and any other required content.</li>
<li>Any defined sniffs must be in a <code>Sniffs</code> folder.</li>
</ul>
<p>The <code>ruleset.xml</code> file was fairly simple in this case, as this is a very simple standard:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ruleset name=&quot;AbstractOrFinalClassesOnly&quot;&gt;
    &lt;description&gt;Checks all classes are marked as either abstract or final.&lt;/description&gt;
&lt;/ruleset&gt;
</code></pre>
<p>The sniff is intended to do the following:</p>
<ul>
<li>Check all classes have either the <code>final</code> keyword or the <code>abstract</code> keyword set</li>
<li>When running the fixer, make all classes without the <code>abstract</code> keyword final</li>
</ul>
<p>First of all, our class must implement the interface <code>PHP_CodeSniffer\Sniffs\Sniff</code>, which requires the following methods:</p>
<pre><code class="lang-php">    public function register(): array;

    public function process(File $file, $position): void;
</code></pre>
<p>Note that <code>File</code> here is an instance of <code>PHP_CodeSniffer\Files\File</code>. The first method registers the code the sniff should operate on. Here we’re only interested in classes, so we return an array containing <code>T_CLASS</code>. This is defined in the <a href="https://secure.php.net/manual/en/tokens.php">list of parser tokens used by PHP</a>, and represents classes and objects:</p>
<pre><code class="lang-php">    public function register(): array
    {
        return [T_CLASS];
    }
</code></pre>
<p>For the <code>process()</code> method, we receive two arguments, the file itself, and the position. We need to keep a record of the tokens we check for, so we do so in a private property:</p>
<pre><code class="lang-php">    private $tokens = [
        T_ABSTRACT,
        T_FINAL,
    ];
</code></pre>
<p>Then, we need to find the error:</p>
<pre><code class="lang-php">        if (!$file-&gt;findPrevious($this-&gt;tokens, $position)) {
            $file-&gt;addFixableError(
                &#39;All classes should be declared using either the &quot;abstract&quot; or &quot;final&quot; keyword&#39;,
                $position - 1,
                self::class
            );
        }
</code></pre>
<p>We use <code>$file</code> to get the token before <code>class</code>, and pass the <code>$tokens</code> property as a list of acceptable values. If the preceding token is not either <code>abstract</code> or <code>final</code>, we add a fixable error. The first argument is the string error message, the second is the location, and the third is the class of the sniff that has failed.</p>
<p>That will catch the issue, but won’t actually fix it. To do that, we need to get the fixer from the file object, and call its <code>addContent()</code> method to add the <code>final</code> keyword. We amend <code>process()</code> to extract the fixer, add it as a property, and then call the <code>fix()</code> method when we come across a fixable error:</p>
<pre><code class="lang-php">    public function process(File $file, $position): void
    {
        $this-&gt;fixer = $file-&gt;fixer;
        $this-&gt;position = $position;

        if (!$file-&gt;findPrevious($this-&gt;tokens, $position)) {
            $file-&gt;addFixableError(
                &#39;All classes should be declared using either the &quot;abstract&quot; or &quot;final&quot; keyword&#39;,
                $position - 1,
                self::class
            );
            $this-&gt;fix();
        }
    }
</code></pre>
<p>Then we define the <code>fix()</code> method:</p>
<pre><code class="lang-php">    private function fix(): void
    {
        $this-&gt;fixer-&gt;addContent($this-&gt;position - 1, &#39;final &#39;);
    }
</code></pre>
<p>Here’s the finished class:</p>
<pre><code class="lang-php">&lt;?php declare(strict_types=1);

namespace Matthewbdaly\AbstractOrFinalClassesOnly\Sniffs;

use PHP_CodeSniffer\Sniffs\Sniff;
use PHP_CodeSniffer\Files\File;

/**
 * Sniff for catching classes not marked as abstract or final
 */
final class AbstractOrFinalSniff implements Sniff
{
    private $tokens = [
        T_ABSTRACT,
        T_FINAL,
    ];

    private $fixer;

    private $position;

    public function register(): array
    {
        return [T_CLASS];
    }

    public function process(File $file, $position): void
    {
        $this-&gt;fixer = $file-&gt;fixer;
        $this-&gt;position = $position;

        if (!$file-&gt;findPrevious($this-&gt;tokens, $position)) {
            $file-&gt;addFixableError(
                &#39;All classes should be declared using either the &quot;abstract&quot; or &quot;final&quot; keyword&#39;,
                $position - 1,
                self::class
            );
            $this-&gt;fix();
        }
    }

    private function fix(): void
    {
        $this-&gt;fixer-&gt;addContent($this-&gt;position - 1, &#39;final &#39;);
    }
}
</code></pre>
<p>I’ve made the resulting standard <a href="https://github.com/matthewbdaly/abstract-or-final-sniff">available via Github</a>.</p>
<p>This is a bit rough and ready and I’ll probably refactor it a bit when I have time. In addition, it’s not quite displaying the behaviour I want as it should, since ideally it should only be looking for the <code>abstract</code> and <code>final</code> keywords in classes that implement an interface. However, it’s proven fairly easy to create this sniff, except for the fact I had to go rooting around various tutorials that weren’t all that clear. Hopefully this example is a bit simpler and easier to follow.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[You don't need that module package]]></title>
            <link>https://matthewdaly.co.uk/blog/2019/01/03/you-dont-need-that-module-package/</link>
            <guid>https://matthewdaly.co.uk/blog/2019/01/03/you-dont-need-that-module-package/</guid>
            <pubDate>Thu, 03 Jan 2019 23:55:49 GMT</pubDate>
            <description><![CDATA[<p>Lately I’ve seen a number of Laravel packages being posted on places like Reddit that offer ways to make your project more modular by letting you break their classes out of the usual structure and place them in a separate folder called something like <code>packages/</code> or <code>modules/</code>. However, these packages are completely redundant, and it requires very little work to achieve the same thing with Composer alone. In addition, much of it is not specific to Laravel and can also be applied to any other framework that uses Composer.</p>
<p>There are two main approaches I’m aware of - keeping it in a single project, and moving the modules to separate Composer packages.</p>
<h1 id="single-project">Single project</h1>
<p>Suppose we have a brand new Laravel project with the namespace left as the default <code>App</code>. This is what the <code>autoload</code> section of the <code>composer.json</code> file will look like:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;App\\&quot;: &quot;app/&quot;
        },
        &quot;classmap&quot;: [
            &quot;database/seeds&quot;,
            &quot;database/factories&quot;
        ]
    },
</code></pre>
<p>Composer allows for numerous ways to autoload classes and you can add additional namespaces as you wish. Probably the best approach is to use PSR-4 autoloading, as in this example:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;App\\&quot;: &quot;app/&quot;,
            &quot;Packages\\&quot;: &quot;packages&quot;
        },
        &quot;classmap&quot;: [
            &quot;database/seeds&quot;,
            &quot;database/factories&quot;
        ]
    },
</code></pre>
<p>Now, if you put the model <code>Post.php</code> in the folder, <code>packages/Blog/Models/</code>, then this will map to the namespace <code>Packages\Blog\Models\Post</code>, and if you set the namespace to this in the file, and run <code>composer dump-autoload</code>, you should be able to import it from that namespace without trouble. As with the <code>App\</code> namespace, because it’s using PSR-4 you’re only specifying the top-level namespace and the folders and files underneath have to mirror the namespace, so for instance, <code>Packages\Foo\Bar</code> maps to <code>packages/Foo/Bar.php</code>. If for some reason PSR-4 autoloading doesn’t map well to what you want to do, then there are other methods you can use - refer to the <a href="https://getcomposer.org/doc/04-schema.md#autoload">relevant section of the Composer documentation</a> for the other methods available.</p>
<p>The controllers are the toughest part, because by default Laravel’s routing works on the assumption that the controllers are all under the <code>App\Http\Controllers</code> namespace, so you can shorten the namespace used. There are two ways around this I’m aware of. One is to specify the full namespace when referencing each controller:</p>
<pre><code class="lang-php">Route::get(&#39;/&#39;, &#39;\App\Modules\Http\Controllers\FooController@index&#39;);
</code></pre>
<p>The other option is to update the <code>RouteServiceProvider.php</code>‘s namespace property. It defaults to this:</p>
<pre><code class="lang-php">protected $namespace = &#39;App\Http\Controllers&#39;;
</code></pre>
<p>If there’s a more convenient namespace you want to place all your controllers under, then you can replace this, and it will become the default namespace applied in your route files.</p>
<p>Other application components such as migrations, routes and views can be loaded from a service provider very easily. Just create a service provider for your module, register it in <code>config/app.php</code>, and set up the <code>boot()</code> method to load whichever components you want from the appropriate place, as in this example:</p>
<pre><code class="lang-php">        $this-&gt;loadMigrationsFrom(__DIR__.&#39;/../database/migrations&#39;);
        $this-&gt;loadRoutesFrom(__DIR__.&#39;/../routes.php&#39;);
        $this-&gt;loadViewsFrom(__DIR__.&#39;/../views&#39;, &#39;comments&#39;);
</code></pre>
<h1 id="separate-packages">Separate packages</h1>
<p>The above approach works particularly well in the initial stages of a project, when you may need to jump around a lot to edit different parts of the project. However, later on, once many parts of the project have stabilised, it may make more sense to pull the modules out into separate repositories and use Composer to pull them in as dependencies, using its support for private repositories. I’ve also often taken this approach right from the start without issue.</p>
<p>This approach has a number of advantages. It makes it easier to reuse parts of the project in other projects if need be. Also, if you put your tests in the packages containing the components they test, it means that rather than running one monolithic test suite for the whole project, you can instead run each module’s tests each time you change it, and limit the test suite of the main project to those integration and acceptance tests that verify the whole thing, along with any unit tests for code that remains in the main repository, resulting in quicker test runs.</p>
<p>Don’t get me wrong, making your code more modular is definitely a good thing and I’m wholly in favour of it. However, it only takes a little knowledge of Composer to be able to achieve this without any third party package at all, which is good because you’re no longer dependent on a package that may at any time fall behind the curve or be abandoned.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Decorating service classes]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/12/06/decorating-service-classes/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/12/06/decorating-service-classes/</guid>
            <pubDate>Thu, 06 Dec 2018 18:34:16 GMT</pubDate>
            <description><![CDATA[<p>I’ve written before about using decorators to extend the functionality of existing classes, in the context of the repository pattern when working with Eloquent. However, the same practice is applicable in many other contexts.</p>
<p>Recently, I was asked to add RSS feeds to the home page of the legacy project that is my main focus these days. The resulting service class looked something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services;

use Rss\Feed\Reader;
use App\Contracts\Services\FeedFetcher;

class RssFetcher implements FeedFetcher
{
    public function fetch($url)
    {
        return Reader::import($url);
    }
}
</code></pre>
<p>In accordance with the principle of loose coupling, I also created an interface for it:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts\Services;

interface FeedFetcher
{
    public function fetch($url);
}
</code></pre>
<p>I was recently able to add dependency injection to the project using PHP-DI, so now I can inject an instance of the feed fetcher into the controller by typehinting the interface and having it resolve to the <code>RssFetcher</code> class.</p>
<p>However, there was an issue. I didn’t want the application to make multiple HTTP requests to fetch those feeds every time the page loads. At the same time, it was also a bit much to have a scheduled task running to fetch those feeds and store them in the database, since many times that would be unnecessary. The obvious solution was to cache the feed content for a specified length of time, in this case five minutes.</p>
<p>I <em>could</em> have integrated the caching into the service class itself, but that wasn’t the best practice, because it would be tied to that implementation. If in future we needed to switch to a different feed handler, we’d have to re-implement the caching functionality. So I decided it made sense to decorate the service class.</p>
<p>The decorator class implemented the same interface as the feed fetcher, and accepted another instance of that interface in the constructor, along with a PSR6-compliant caching library. It looked something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services;

use App\Contracts\Services\FeedFetcher;
use Psr\Cache\CacheItemPoolInterface;

class FetcherCachingDecorator implements FeedFetcher
{
    protected $fetcher;

    protected $cache;

    public function __construct(FeedFetcher $fetcher, CacheItemPoolInterface $cache)
    {
        $this-&gt;fetcher = $fetcher;
        $this-&gt;cache = $cache;
    }

    public function fetch($url)
    {
        $item = $this-&gt;cache-&gt;getItem(&#39;feed_&#39;.$url);
        if (!$item-&gt;isHit()) {
            $item-&gt;set($this-&gt;fetcher-&gt;fetch($url));
            $this-&gt;cache-&gt;save($item);
        }
        return $item-&gt;get();
    }
}
</code></pre>
<p>Now, when you instantiate the feed fetcher, you wrap it in the decorator as follows:</p>
<pre><code class="lang-php">&lt;?php

$fetcher = new FetcherCachingDecorator(
        new App\Services\RssFetcher,
        $cache
);
</code></pre>
<p>As you can see, this solves our problem quite nicely. By wrapping our feed fetcher in this decorator, we keep the caching layer completely separate from any one implementation of the fetcher, so in the event we need to swap the current one out for another implementation, we don’t have to touch the caching layer at all. As long as we’re using dependency injection to resolve this interface, we’re only looking at a little more code to instantiate it.</p>
<p>In addition, this same approach can be applied for other purposes, and you can wrap the service class as many times as necessary. For instance, if we wanted to log all the responses we got, we could write a logging decorator something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services;

use App\Contracts\Services\FeedFetcher;
use Psr\Log\LoggerInterface;

class FeedLoggingDecorator implements FeedFetcher
{
    protected $fetcher;

    protected $logger;

    public function __construct(FeedFetcher $fetcher, LoggerInterface $logger)
    {
        $this-&gt;fetcher = $fetcher;
        $this-&gt;logger = $logger;
    }

    public function fetch($url)
    {
        $response = $this-&gt;fetcher-&gt;fetch($url);
        $this-&gt;logger-&gt;info($response);
        return $response;
    }
}
</code></pre>
<p>The same idea can be applied to an API client. For instance, say we have the following interface for an API client:</p>
<pre><code class="lang-php">&lt;?php

namespace Foo\Bar\Contracts;

use Foo\Bar\Objects\Item;
use Foo\Bar\Objects\ItemCollection;

interface Client
{
    public function getAll(): ItemCollection;

    public function find(int $id): Item;

    public function create(array $data): Item;

    public function update(int $id, array $data): Item;

    public function delete(int $id);
}
</code></pre>
<p>Now, of course any good API client should respect HTTP headers and use those to do some caching itself, but depending on the use case, you may also want to cache these requests yourself. For instance, if the only changes to the entities stored by the third party API will be ones you’ve made, or they don’t need to be 100% up to date, you may be better off caching those responses before they reach the actual API client. Under those circumstances, you might write a decorator like this to do the caching:</p>
<pre><code class="lang-php">&lt;?php

namespace Foo\Bar\Services;

use Foo\Bar\Contracts\Client;
use Psr\Cache\CacheItemPoolInterface;

class CachingDecorator implements Client
{
    protected $client;

    protected $cache;

    public function __construct(Client $client, CacheItemPoolInterface $cache)
    {
        $this-&gt;client = $client;
        $this-&gt;cache = $cache;
    }

    public function getAll(): ItemCollection
    {
        $item = $this-&gt;cache-&gt;getItem(&#39;item_all&#39;);
        if (!$item-&gt;isHit()) {
            $item-&gt;set($this-&gt;client-&gt;getAll());
            $this-&gt;cache-&gt;save($item);
        }
        return $item-&gt;get();
    }

    public function find(int $id): Item
    {
        $item = $this-&gt;cache-&gt;getItem(&#39;item_&#39;.$id);
        if (!$item-&gt;isHit()) {
            $item-&gt;set($this-&gt;client-&gt;find($id));
            $this-&gt;cache-&gt;save($item);
        }
        return $item-&gt;get();

    }

    public function create(array $data): Item
    {
        $this-&gt;cache-&gt;clear();
        return $this-&gt;client-&gt;create($data);
    }

    public function update(int $id, array $data): Item
    {
        $this-&gt;cache-&gt;clear();
        return $this-&gt;client-&gt;update($id, $data);
    }

    public function delete(int $id)
    {
        $this-&gt;cache-&gt;clear();
        return $this-&gt;client-&gt;delete($id);
    }
}
</code></pre>
<p>Any methods that change the state of the data on the remote API will clear the cache, while any that fetch data will first check the cache, only explicitly fetching data from the API when the cache is empty, and caching it again. I won’t go into how you might write a logging decorator for this, but it should be straightforward to figure out for yourself.</p>
<p>The decorator pattern is a very powerful way of adding functionality to a class without tying it to a specific implementation. If you’re familiar with how middleware works, decorators work in a very similar fashion in that you can wrap your service in as many layers as you wish in order to accomplish specific tasks, and they adhere to the single responsibility principle by allowing you to use different decorators for different tasks.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Simplify your tests with anonymous classes]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/10/20/simplify-your-tests-with-anonymous-classes/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/10/20/simplify-your-tests-with-anonymous-classes/</guid>
            <pubDate>Sat, 20 Oct 2018 13:48:05 GMT</pubDate>
            <description><![CDATA[<p>Anonymous classes were added in PHP7, but so far I haven’t made all that much use of them. However, recently I’ve been working on building a simple dependency injection container for learning purposes. This uses the PHP Reflection API to determine how to resolve dependencies. For instance, if it’s asked for a class for which one of the dependencies required by the constructor is an instance of the <code>DateTime</code> class, it should create an instance, and then pass it into the constructor automatically when instantiating the class. Then it should return the newly created class.</p>
<p>Mocking isn’t really a suitable approach for this use case because the container needs to return a concrete class instance to do its job properly. You could just create a series of fixture classes purely for testing purposes, but that would mean either defining more than one class in a file (violating PSR-2), or defining a load of fixture classes in separate files, meaning you’d have to write a lot of boilerplate, and you’d have to move between several different files to understand what’s going on in the test.</p>
<p>Anonymous classes allow you a means to write simple classes for tests inline, as in this example for retrieving a very basic class. The tests use PHPSpec:</p>
<pre><code class="lang-php7">&lt;?php

namespace spec\Vendor\Package;

use Vendor\Package\MyClass;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use DateTime;

class MyClassSpec extends ObjectBehavior
{
    function it_can_resolve_registered_dependencies()
    {
        $toResolve = new class {
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf($toResolve);
    }
}
</code></pre>
<p>You can also define your own methods inline. Here we implement the <code>invoke()</code> magic method so that the class is a callable:</p>
<pre><code class="lang-php7">&lt;?php

class MyClassSpec extends ObjectBehavior
{
    function it_can_resolve_registered_invokable()
    {
        $toResolve = new class {
            public function __invoke() {
                return new DateTime;
            }
        };
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf(&#39;DateTime&#39;);
    }
}
</code></pre>
<p>You can also define a constructor. Here, we’re getting the class name of a newly created anonymous class that accepts an instance of <code>DateTime</code> as an argument to the constructor. Then, we can resolve a new instance out of the container:</p>
<pre><code class="lang-php7">&lt;?php

class MyClassSpec extends ObjectBehavior
{
    function it_can_resolve_dependencies()
    {
        $toResolve = get_class(new class(new DateTime) {
            public $datetime;
            public function __construct(DateTime $datetime)
            {
                $this-&gt;datetime = $datetime;
            }
        });
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf($toResolve);
    }
}
</code></pre>
<p>For classes that will extend an existing class or implement an interface, you can define those inline too. Or you can include a trait:</p>
<pre><code class="lang-php7">&lt;?php

class MyClassSpec extends ObjectBehavior
{
    function it_can_resolve_dependencies()
    {
        $toResolve = get_class(new class(new DateTime) extends Foo implements Bar {
            public $datetime;
            public function __construct(DateTime $datetime)
            {
                $this-&gt;datetime = $datetime;
            }

            use MyTrait;
        });
        $this-&gt;set(&#39;Foo\Bar&#39;, $toResolve);
        $this-&gt;get(&#39;Foo\Bar&#39;)-&gt;shouldReturnAnInstanceOf($toResolve);
    }
}
</code></pre>
<p>In cases where the functionality is contained in a trait or abstract class, and you might need to add little or no additional functionality, this is a lot less verbose than creating a class the conventional way.</p>
<p>None of this is stuff you can’t do without anonymous classes, but by defining these sort of disposable fixture classes inline in your tests, you’re writing the minimum amount of code necessary to implement your test, and it’s logical to define it inline since it’s only ever used in the tests. One thing to bear in mind is that anonymous classes are created and instantiated at the same time, so you can’t easily create a class and then instantiate an instance of it separately. However, you can instantiate one, then use the <code>get_class()</code> function to get its class name and use that to resolve it, which worked well for my use case.</p>
<p>Another use case for anonymous classes is testing traits or abstract classes. I generally use Mockery as my mocking solution with PHPUnit tests, but I’ve sometimes missed the <code>getMockForTrait()</code> method from PHPUnit. However, another option is to instantiate an anonymous class that includes that trait for testing purposes:</p>
<pre><code class="lang-php7">&lt;?php

$item = new class() {
    use MyTrait;
};
</code></pre>
<p>This way, your test class is as minimal as possible, and you can test the trait/abstract class in a fairly isolated fashion.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[An approach to writing golden master tests for PHP web applications]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/10/08/an-approach-to-writing-golden-master-tests-for-php-web-applications/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/10/08/an-approach-to-writing-golden-master-tests-for-php-web-applications/</guid>
            <pubDate>Mon, 08 Oct 2018 10:20:53 GMT</pubDate>
            <description><![CDATA[<p>Apologies if some of the spelling or formatting on this post is off - I wrote it on a long train journey down to London, with sunlight at an inconvenient angle.</p>
<p>Recently I had to carry out some substantial changes to the legacy web app I maintain as the lion’s share of my current job. The client has several channels that represent different parts of the business that would expect to see different content on the home page, and access to content is limited first by channel, and then by location. The client wanted an additional channel added. Due to bad design earlier in the application’s lifetime that isn’t yet practical to refactor away, each type of location has its own model, so it was necessary to add a new location model. It also had to work seamlessly, in the same way as the other location types. Unfortunately, these branch types didn’t use polymorphism, and instead used large switch statements, and it wasn’t practical to refactor all that away in one go. This was therefore quite a high-risk job, especially considering the paucity of tests on a legacy code base.</p>
<p>I’d heard of the concept of a <em>golden master test</em> before. If you haven’t heard of it before, the idea is that it works by running a process, capturing the output, and then comparing the output of that known good version against future runs. It’s very much a test of last resort since, in the context of a web app, it’s potentially very brittle since it depends on the state of the application remaining the same between runs to avoid false positives. I needed a set of simple “snapshot tests”, similar to how snapshot testing works with Jest, to catch unexpected breakages in a large number of pages, and this approach seemed to fit the bill. Unfortunately, I hadn’t been able to find a good example of how to do this for PHP applications, so it took a while to figure out something that worked.</p>
<p>Here is an example base test case I used for this approach:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests;

use PHPUnit_Framework_TestCase as BaseTestCase;
use Behat\Mink\Driver\GoutteDriver;
use Behat\Mink\Session;

class GoldenMasterTestCase extends BaseTestCase
{
    protected $driver;

    protected $session;

    protected $baseUrl = &#39;http://localhost:8000&#39;;

    protected $snapshotDir = &quot;tests/snapshots/&quot;;

    public function setUp()
    {
        $this-&gt;driver = new GoutteDriver();
        $this-&gt;session = new Session($this-&gt;driver);
    }

    public function tearDown()
    {
        $this-&gt;session = null;
        $this-&gt;driver = null;
    }

    public function loginAs($username, $password)
    {
        $this-&gt;session-&gt;visit($this-&gt;baseUrl.&#39;/login&#39;);
        $page = $this-&gt;session-&gt;getPage();
        $page-&gt;fillField(&quot;username&quot;, $username);
        $page-&gt;fillField(&quot;password&quot;, $password);
        $page-&gt;pressButton(&quot;Sign In&quot;);
        return $this;
    }

    public function goto($path)
    {
        $this-&gt;session-&gt;visit($this-&gt;baseUrl.$path);
        $this-&gt;assertNotEquals(404, $this-&gt;session-&gt;getStatusCode());
        return $this;
    }

    public function saveHtml()
    {
        if (!$this-&gt;snapshotExists()) {
            $this-&gt;saveSnapshot();
        }
        return $this;
    }

    public function assertSnapshotsMatch()
    {
        $path = $this-&gt;getPath();
        $newHtml = $this-&gt;processHtml($this-&gt;getHtml());
        $oldHtml = $this-&gt;getOldHtml();
        $diff = &quot;&quot;;
        if (function_exists(&#39;xdiff_string_diff&#39;)) {
            $diff = xdiff_string_diff($oldHtml, $newHtml);
        }
        $message = &quot;The path $path does not match the snapshot\n$diff&quot;;
        self::assertThat($newHtml == $oldHtml, self::isTrue(), $message);
    }

    protected function getHtml()
    {
        return $this-&gt;session-&gt;getPage()-&gt;getHtml();
    }

    protected function getPath()
    {
        $url = $this-&gt;session-&gt;getCurrentUrl();
        $path = parse_url($url, PHP_URL_PATH);
        $query = parse_url($url, PHP_URL_QUERY);
        $frag = parse_url($url, PHP_URL_FRAGMENT);
        return $path.$query.$frag;
    }

    protected function getEscapedPath()
    {
        return $this-&gt;snapshotDir.str_replace(&#39;/&#39;, &#39;_&#39;, $this-&gt;getPath()).&#39;.snap&#39;;
    }

    protected function snapshotExists()
    {
        return file_exists($this-&gt;getEscapedPath());
    }

    protected function processHtml($html)
    {
        return preg_replace(&#39;/&lt;input type=&quot;hidden&quot;[^&gt;]+\&gt;/i&#39;, &#39;&#39;, $html);
    }

    protected function saveSnapshot()
    {
        $html = $this-&gt;processHtml($this-&gt;getHtml());
        file_put_contents($this-&gt;getEscapedPath(), $html);
    }

    protected function getOldHtml()
    {
        return file_get_contents($this-&gt;getEscapedPath());
    }
}
</code></pre>
<p>Because this application is built with Zend 1 and doesn’t have an easy way to get the HTML response without actually running the application, I was forced to use an actual HTTP client to fetch the content while the web server is running. I’ve used Mink together with Behat many times in the past, and the Goutte driver is fast and doesn’t rely on Javascript, so that was the best bet for a simple way of retrieving the HTML. Had I been taking this approach with a Laravel application, I could have populated the testing database with a common set of fixtures, and passed a request object through the application and captured the response object’s output rather than using an HTTP client, thereby eliminating the need to run a web server and making the tests faster and less brittle.</p>
<p>Another issue was CSRF handling. A CSRF token is, by definition, generated randomly each time the page is loaded, and so it broke those pages that had forms with CSRF tokens. The solution I came up with was to strip out the hidden input fields.</p>
<p>When each page is tested, the first step is to fetch the content of that page. The test case then checks to see if there’s an existing snapshot. If not, the content is saved as a new snapshot file. Otherwise, the two snapshots are compared, and the test fails if they do not match.</p>
<p>Once that base test case was in place, it was then straightforward to extend it to test multiple pages. I wrote one test to check pages that did not require login, and another to check pages that did require login, and the paths for those pages were passed through using a data provider method, as shown below:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\GoldenMaster;

use Tests\GoldenMasterTestCase;

class GoldenMasterTest extends GoldenMasterTestCase
{
    /**
     * @dataProvider nonAuthDataProvider
     */
    public function testNonAuthPages($data)
    {
        $this-&gt;goto($data)
            -&gt;saveHtml()
            -&gt;assertSnapshotsMatch();
    }

    public function nonAuthDataProvider()
    {
        return [
            [&#39;/login&#39;],
        ];
    }

    /**
     * @dataProvider dataProvider
     */
    public function testPages($data)
    {
        $this-&gt;loginAs(&#39;foo&#39;, &#39;bar&#39;)
            -&gt;goto($data)
            -&gt;saveHtml()
            -&gt;assertSnapshotsMatch();
    }

    public function dataProvider()
    {
        return [
            [&#39;/foo&#39;],
            [&#39;/bar&#39;],
        ];
    }
}
</code></pre>
<p>Be warned, this is <em>not</em> an approach I would advocate as a matter of course, and it should only ever be a last resort as an alternative to onerous manual testing for things that can’t be tested in their current form. It’s extremely brittle, and I’ve had to deal with a lot of false positives, although that would be easier if I could populate a testing database beforehand and use that as the basis of the tests. It’s also very slow, with each test taking three or four seconds to run, although again this would be less of an issue if I could pass through a request object and get the response HTML directly. Nonetheless, I’ve found it to be a useful technique as a test of last resort for legacy applications.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Understanding the pipeline pattern]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/10/05/understanding-the-pipeline-pattern/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/10/05/understanding-the-pipeline-pattern/</guid>
            <pubDate>Fri, 05 Oct 2018 18:36:16 GMT</pubDate>
            <description><![CDATA[<p>In a previous post, I used the pipeline pattern to demonstrate processing letters using optical recognition and machine learning. The pipeline pattern is something I’ve found very useful in recent months. For a sequential series of tasks, this approach can make your code easier to understand by allowing you to break it up into simple, logical steps which are easy to test and understand individually. If you’re familiar with pipes and redirection in Unix, you’ll be aware of how you can chain together multiple, relatively simple commands to carry out some very complex transformations on data.</p>
<p>A few months back, I was asked to build a webhook for a Facebook lead form at work. One of my colleagues was having to manually export CSV data from Facebook for the data, and then import it into a MySQL database and a Campaign Monitor mailing list, which was an onerous task, so they asked me to look at more automated solutions. I wound up building a webhook with Lumen that would go through the following steps:</p>
<ul>
<li>Get the lead ID’s from the webhook</li>
<li>Pull the leads from the Facebook API using those ID’s</li>
<li>Process the raw data into a more suitable format</li>
<li>Save the data to the database</li>
<li>Push the data to Campaign Monitor</li>
</ul>
<p>Since this involved a number of discrete steps, I chose to implement each step as a separate stage. That way, each step was easy to test in isolation, and it was easily reusable. As it turned out, this approach saved us because Facebook needed to approve this app (and ended up rejecting it - their documentation at the time wasn’t clear on implementing server-to-server apps, making it hard to meet their guidelines), so we needed an interim solution. I instead wrote an Artisan task for importing the file from a CSV, which involved the following steps:</p>
<ul>
<li>Read the rows from the CSV file</li>
<li>Format the CSV data into the desired format</li>
<li>Save the data to the database</li>
<li>Push the data to Campaign Monitor</li>
</ul>
<p>This meant that two of the existing steps could be reused, as is, without touching the code or tests. I just added two new classes to read the data and format the data, and the Artisan command, which simply called the various pipeline stages, <em>and that was all</em>. In this post, I’ll demonstrate how I implemented this.</p>
<p>While there is more than one implementation of this available, and it wouldn’t be hard to roll your own, I generally use the PHP League’s <a href="https://pipeline.thephpleague.com/">Pipeline package</a>, since it’s simple, solid and well-tested. Let’s say our application has three steps:</p>
<ul>
<li>Format the request data</li>
<li>Save the data</li>
<li>Push it to a third party service.</li>
</ul>
<p>We therefore need to write a stage for each step in the process. Each one must be a callable, such as a closure, a callback, or a class that implements the <code>__invoke()</code> magic method. I usually go for the latter as it allows you to more easily inject dependencies into the stage via its constructor, making it easier to use and test. Here’s what our first stage might look like:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Stages;

use Illuminate\Support\Collection;

class FormatData
{
    public function __invoke(Collection $data): Collection
    {
        return $data-&gt;map(function ($item) {
            return [
                &#39;name&#39; =&gt; $item-&gt;fullname,
                &#39;email&#39; =&gt; $item-&gt;email
            ];
        });
    }
}
</code></pre>
<p>This class does nothing more than receive a collection, and format the data as expected. We could have it accept a request object instead, but I opted not to because I felt it made more sense to pass the data in as a collection so it’s not tied to an HTTP request. That way, it can also handle data passed through from a CSV file using an Artisan task, and the details of how it receives the data in the first place are deferred to the class that calls the pipeline in the first place. Note this stage also returns a collection, for handling by the next step:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Stages;

use App\Lead;
use Illuminate\Support\Collection;

class SaveData
{
    public function __invoke(Collection $data): Collection
    {
        return $data-&gt;map(function ($item) {
            $lead = new Lead;
            $lead-&gt;name = $item-&gt;name;
            $lead-&gt;email = $item-&gt;email;
            $lead-&gt;save();
            return $lead;
        }
    }
}
</code></pre>
<p>This step saves each lead as an Eloquent model, and returns a collection of the saved models, which are passed to the final step:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Stages;

use App\Contracts\Services\MailingList;
use Illuminate\Support\Collection;

class AddDataToList
{
    protected $list;

    public function __construct(MailingList $list)
    {
        $this-&gt;list = $list;
    }

    public function __invoke(Collection $data)
    {
        return $data-&gt;each(function ($item) {
            $this-&gt;list-&gt;add([
                &#39;name&#39; =&gt; $item-&gt;name,
                &#39;email&#39; =&gt; $item-&gt;email
            ]);
        });
    }
}
</code></pre>
<p>This step uses a wrapper class for a mailing service, which is passed through as a dependency in the constructor. The <code>__invoke()</code> method then loops through each Eloquent model and uses it to fetch the data, which is then added to the list. With our stages complete, we can now put them together in our controller:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Stages\FormatData;
use App\Stages\SaveData;
use App\Stages\AddDataToList;
use League\Pipeline\Pipeline;
use Illuminate\Support\Collection;

class WebhookController extends Controller
{
    public function store(Request $request, Pipeline $pipeline, FormatData $formatData, SaveData $savedata, AddDataToList $addData)
    {
        try {
            $data = Collection::make($request-&gt;get(&#39;data&#39;));
            $pipe = $pipeline-&gt;pipe($formatData)
                -&gt;pipe($saveData)
                -&gt;pipe($addData);
            $pipe-&gt;process($data);
        } catch (\Exception $e) {
            // Handle exception
        }
    }
}
</code></pre>
<p>As mentioned above, we extract the request data (assumed to be an array of data for a webhook), and convert it into a collection. Then, we put together our pipeline. Note that we use dependency injection to fetch the steps - feel free to use method or constructor injection as appropriate. We instantiate our pipeline, and call the <code>pipe()</code> method multiple times to add new stages.</p>
<p>Finally we pass the data through to our pipe for processing by calling the <code>process()</code> method, passing in the initial data. Note that we can wrap the whole thing in a <code>try...catch</code> statement to handle exceptions, so if something happens that would mean we would want to cease processing at that point, we can throw an exception in the stage and handle it outside the pipeline.</p>
<p>This means that our controller is kept very simple. It just gets the data as a collection, then puts the pipeline together and passes the data through. If we subsequently had to write an Artisan task to do something similar from the command line, we could fetch the data via a CSV reader class, and then pass it to the same pipeline. If we needed to change the format of the initial data, we could replace the <code>FormatData</code> class with a single separate class with very little trouble.</p>
<p>Another thing you can do with the League pipeline package, but I haven’t yet had the occasion to try, is use <code>League\Pipeline\PipelineBuilder</code> to build pipelines in a more dynamic fashion. You can make steps conditional, as in this example:</p>
<pre><code class="lang-php">&lt;?php

use League\Pipeline\PipelineBuilder;

$builder = (new PipelineBuilder)
    -&gt;add(new FormatData);
if ($data[&#39;type&#39;] = &#39;foo&#39;) {
    $builder-&gt;add(new HandleFooType);
}
$builder-&gt;add(new SaveData);
$pipeline = $builder-&gt;build();
$pipeline-&gt;process($data);
</code></pre>
<p>The pipeline pattern isn’t appropriate for every situation, but for anything that involves a set of operations on the same data, it makes a lot of sense, and can make it easy to break larger operations into smaller steps that are easier to understand, test, and re-use.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Replacing switch statements with polymorphism in PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/10/03/replacing-switch-statements-with-polymorphism-in-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/10/03/replacing-switch-statements-with-polymorphism-in-php/</guid>
            <pubDate>Wed, 03 Oct 2018 22:07:33 GMT</pubDate>
            <description><![CDATA[<p>For the last few months, I’ve been making a point of picking up on certain antipatterns, and ways to avoid or remove them. One I’ve seen a lot recently is unnecessary large switch-case or if-else statements. For instance, here is a simplified example of one of these, which renders links to different objects:</p>
<pre><code class="lang-php">&lt;?php

switch ($item-&gt;getType()) {
    case &#39;audio&#39;:
        $media = new stdClass;
        $media-&gt;type = &#39;audio&#39;;
        $media-&gt;duration = $item-&gt;getLength();
        $media-&gt;name = $item-&gt;getName();
        $media-&gt;url = $item-&gt;getUrl();
    case &#39;video&#39;:
        $media = new stdClass;
        $media-&gt;type = &#39;video&#39;;
        $media-&gt;duration = $item-&gt;getVideoLength();
        $media-&gt;name = $item-&gt;getTitle();
        $media-&gt;url = $item-&gt;getUrl();
}
return &#39;&lt;a href=&quot;&#39;.$media-&gt;url.&#39;&quot; class=&quot;&#39;.$media-&gt;type.&#39;&quot; data-duration=&quot;&#39;.$media-&gt;duration.&#39;&quot;&gt;&#39;.$media-&gt;name.&#39;&lt;/a&gt;&#39;;
</code></pre>
<p>There are a number of problems with this, most notably the fact that it’s doing a lot of work to try and create a new set of objects that behave consistently. Instead, your objects should be polymorphic - in other words, you should be able to treat the original objects the same.</p>
<p>While strictly speaking you don’t need one, it’s a good idea to create an interface that defines the required methods. That way, you can have those objects implement that interface, and be certain that they have all the required methods:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts;

interface MediaItem
{
    public function getLength(): int;

    public function getName(): string;

    public function getType(): string;

    public function getUrl(): string;
}
</code></pre>
<p>Then, you need to implement that interface in your objects. It doesn’t matter if the implementations are different, as long as the methods exist. That way, objects can define how they return a particular value, which is simpler and more logical than defining it in a large switch-case statement elsewhere. It also helps to prevent duplication. Here’s what the audio object might look like:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Models;

use App\Contracts\MediaItem;

class Audio implements MediaItem
{
    public function getLength(): int
    {
        return $this-&gt;length;
    }

    public function getName(): string
    {
        return $this-&gt;name;
    }

    public function getType(): string
    {
        return $this-&gt;type;
    }

    public function getUrl(): string
    {
        return $this-&gt;url;
    }
}
</code></pre>
<p>And here’s a similar example of the video object:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Models;

use App\Contracts\MediaItem;

class Video implements MediaItem
{
    public function getLength(): int
    {
        return $this-&gt;getVideoLength();
    }

    public function getName(): string
    {
        return $this-&gt;getTitle();
    }

    public function getType(): string
    {
        return $this-&gt;type;
    }

    public function getUrl(): string
    {
        return $this-&gt;url;
    }
}
</code></pre>
<p>With that done, the code to render the links can be greatly simplified:</p>
<pre><code class="lang-php">&lt;?php
return &#39;&lt;a href=&quot;&#39;.$item-&gt;getUrl().&#39;&quot; class=&quot;&#39;.$item-&gt;getType().&#39;&quot; data-duration=&quot;&#39;.$item-&gt;getLength().&#39;&quot;&gt;&#39;.$media-&gt;getName().&#39;&lt;/a&gt;&#39;;
</code></pre>
<p>Because we can use the exact same methods and get consistent responses, yet also allow for the different implementations within the objects, this approach allows for much more elegant and readable code. Different objects can be treated in the same way without the need for writing extensive if or switch statements.</p>
<p>I haven’t had the occasion to do so, but in theory this approach is applicable in other languages, such as Javascript or Python (although these languages don’t have the concept of interfaces). Since discovering the switch statement antipattern and how to replace it with polymorphism, I’ve been able to remove a lot of overly complex code.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[How I'm refactoring a Zend 1 legacy project]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/09/24/how-i&apos;m-refactoring-a-zend-1-legacy-project/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/09/24/how-i&apos;m-refactoring-a-zend-1-legacy-project/</guid>
            <pubDate>Mon, 24 Sep 2018 21:30:46 GMT</pubDate>
            <description><![CDATA[<p>In my current job I’ve been maintaining and developing a Zend 1 legacy project for the best part of a year. It has to be said, it’s the worst code base I have ever seen, with textbook examples of many antipatterns, spaghetti jQuery, copy-pasted code and overly complex methods. It’s a fairly typical example of a project built on an older MVC framework by inexperienced developers (I’ve been responsible for building similar things in my CodeIgniter days).</p>
<p>In this article I’ll go through some of the steps I’ve taken to help bring this legacy project under control. Not all of them are complete as at time of writing, but they’ve all helped to make this decidedly crappy project somewhat better. In working with this legacy project, I’ve found Paul Jones’ book <em>Modernizing Legacy Applications in PHP</em> to be very useful, and if you’re working on a similar legacy project, I highly recommend investing in a copy. I’ve also found <a href="https://sourcemaking.com/">Sourcemaking</a> to be a useful resource in identifying antipatterns in use, refactoring strategies, and applicable design patterns.</p>
<h1 id="moving-to-git">Moving to Git</h1>
<p>When I first started working on the project, the repository was in Subversion, and was absolutely colossal - checking it out took two hours! Needless to say, my first action was to migrate it to Git. I used <a href="https://john.albin.net/git/convert-subversion-to-git">this post</a> as a guide, and it was pretty straightforward, but took all of my first day.</p>
<h1 id="adding-migrations">Adding migrations</h1>
<p>The next job involved making some changes to the database. Unfortunately, Zend 1 doesn’t include migrations, and no-one had added a third party solution. I therefore did some research and wound up stumbling across <a href="https://phinx.org/">Phinx</a>, which is a standalone migration package with a command-line runner. Using that, it was straightforward to start adding migrations to make any necessary changes to the database structure and fixtures.</p>
<h1 id="moving-dependencies-to-composer">Moving dependencies to Composer</h1>
<p>The project was using Composer, but only to a limited degree - the framework itself was in the <code>library/</code> folder, and several other dependencies were also stored here. The <code>vendor/</code> directory was also checked into version control. I therefore took the vendor folder out of Git, and added <code>zendframework/zendframework1</code> as a dependency. This drastically reduced the size of the repository.</p>
<h1 id="cleaning-up-commented-code">Cleaning up commented code</h1>
<p>There was an awful lot of commented code. Some of it was even commented out incorrectly (PHP code commented out with HTML comments). I’m of the school of thought that commented code is best deleted without a second thought, since it can be retrieved from version control, and it can be confusing, so I’ve been removing any commented code I come across.</p>
<h1 id="refactoring-duplicate-code">Refactoring duplicate code</h1>
<p>One of the biggest problems with the code base was the high level of duplication - a lot of code, particularly in the view layer, had been copied and pasted around. Running PHPCPD on the repository showed that, not including the views, around 12% of the code base was copied-and-pasted, which is a horrific amount. I therefore started aggressively refactoring duplicate code out into helpers and traits. As at today, the amount of duplication excluding the views is around 2.6%, which is obviously a big improvement.</p>
<h1 id="refactoring-object-creation-code-into-persisters">Refactoring object creation code into persisters</h1>
<p>There was some extremely complex code for creating and updating various objects that was jammed into the controllers, and involved a lot of duplicate code. I’ve used dedicated persister classes in the past with great effect, so I pulled that code out into persisters to centralise the logic about the creation of different objects. It’s still a lot more convoluted than I’d like, but at least now it’s out of the controllers and can be tested to some extent.</p>
<h1 id="creating-repositories">Creating repositories</h1>
<p>One of the most problematic parts of the code base is the models. Whoever was responsible for them couldn’t seem to decide whether they represented a single domain object, or a container for methods for getting those objects, so both responsibilities were mixed up in the same class. This means you had to instantiate an object, then use it to call one of the methods to get another instance of that object, as in this example:</p>
<pre><code class="lang-php">$media = new Application_Model_Media;
$media = $media-&gt;find(1);
</code></pre>
<p>I’ve therefore resolved to pull those methods out into separate repository classes, leaving the models as pure domain objects. Unfortunately, the lack of dependency injection makes it problematic to instantiate the repositories. For that reason, right now the repositories only implement static methods - it’s not ideal, but it’s better than what we have now.</p>
<p>I started out by creating interfaces for the methods I wanted to migrate, and had the models implement them. Then, I moved those methods from the model to the repository classes and amended all references to them, before removing the interfaces from the models. Now, a typical find request looks like this:</p>
<pre><code class="lang-php">$media = App\Repository\Media::find(1);
</code></pre>
<p>It’s not done yet, but over half of them have been migrated.</p>
<p>Once that’s done, I’ll then be in a position to look at refactoring the logic in the models to make them easier to work with - right now each model has dedicated setters and getters (as well as some horrific logic to populate them), and I’m considering amending them to allow access to the properties via the <code>__get()</code> and <code>__set()</code> magic methods. Another option is to consider migrating the database layer to Doctrine, since that way we can reuse the getters and setters, but I haven’t yet made a firm decision about that.</p>
<h1 id="adding-tests">Adding tests</h1>
<p>The poor design of this application makes it difficult to test, so right now the coverage is poor. I’ve been using Behat to produce a basic set of acceptance tests for some of the most fundamental functionality, but they’re brittle and can be broken by database changes. I’ve also added some (even more brittle) golden master tests using a technique I’ll mention in a later blog post. I have got unit tests for three of the persister classes and some utility classes I’ve added, but nowhere near the level I want.</p>
<h1 id="refactoring-code-out-of-the-fat-controllers">Refactoring code out of the fat controllers</h1>
<p>Fat controllers are an antipattern I’ve seen, and indeed been responsible for myself, in the past, and this project has them in spades - running PHP Mess Detector on them is pretty sobering. The overwhelming majority of the code base is concentrated in the controllers, and it’s going to take a long time to refactor it into other classes.</p>
<p>Zend 1 does have the concept of controller helpers, and that’s been useful for removing some duplicate code, while more shared code has been refactored out into traits. In addition, the utilities I’ve added include a Laravel-style collection class, and using that I’ve been able to refactor a lot of quite complex array handling into much simpler chained collection handling. However, this is still going to take a lot of effort.</p>
<h1 id="adding-events">Adding events</h1>
<p>The lack of a decent event system caused particular problems when I was asked to add tracking of when a user views certain resources, so I used the <a href="http://event.thephpleague.com/2.0/">PHP League’s Event package</a> for this. I’ve started moving some other functionality to event listeners too, but this is another thing that will take a long time.</p>
<h1 id="refactoring-the-front-end">Refactoring the front end</h1>
<p>Like many legacy projects, the front end is a horrible mess of jQuery spaghetti code, with some Handlebars templates thrown in here and there for good measure. It’s easily complex enough that it would benefit from a proper front-end framework, but a full rewrite is out of the question.</p>
<p>I was recently asked to add two new modals in the admin interface, and decided that it was worth taking a new approach rather than adding yet more jQuery spaghetti. Angular 1 is on its way out, so that wasn’t an option, and Angular 2+ would necessitate using Typescript, which would likely be problematic in the context of a legacy app, as well as the complexity being an issue. Vue was a possibility, but I always feel like Vue tries to do too much. Instead, I decided to go for React, because:</p>
<ul>
<li>I’ve always enjoyed working with React, even though I haven’t had much chance to do so in the past.</li>
<li>We’re using Laravel Mix for processing the CSS and JS files (it can be used on non-Laravel projects), and it has a preset for React</li>
<li>React is well-suited to being added incrementally to existing projects without the need for a full rewrite (after all, it works for Facebook…), so it was straightforward to do a single modal with it</li>
<li>It’s easy to test - you can use snapshot tests to check it remains consistent, and using Enzyme it’s straightforward to navigate the rendered component for other tests</li>
</ul>
<p>Both modals turned out very well, and went live recently. The first one took a fair while to write, and then when I wrote the second one, I had to spend some time making the sub-components more generic and pulling some functionality out into a higher order component, but now that that’s done it should be straightforward to write more.</p>
<p>In the longer term I plan to migrate more and more of the admin to React over time. The front end also has a new home page on the cards, and the plan is to use React for that too. Once the whole UI is using React, that will have eliminated most, if not all, of the problems with duplicate code in the view layer, as well as allowing for eventually turning the application into a single-page web app.</p>
<h1 id="upgrading-the-php-version-and-migrating-to-a-new-server">Upgrading the PHP version and migrating to a new server</h1>
<p>When I started work on the project, it was running on an old server running PHP 5.4, but there were plans to migrate to a new server running PHP 5.6. The lack of tests made it difficult to verify it wouldn’t break in 5.6, but using PHP Compatibility and CodeSniffer I was able to find most of the problems. I ran it on PHP 5.6 locally during development so that any new development would be done on a more modern version. In the end, the migration to the new server was fairly seamless.</p>
<p>We will have to consider migrating to a newer PHP version again, since 5.6 is no longer supported as at the end of this year, but it may be too risky for now.</p>
<h1 id="namespacing-the-code">Namespacing the code</h1>
<p>As Zend 1 predates PHP namespaces, the code wasn’t namespaced. This is something I do plan to remedy - the form and model classes should be straightforward to namespace, but the controllers are a bit more problematic. I’m waiting on completing the repositories before I look at this.</p>
<h1 id="adding-psr-3-logging">Adding PSR-3 logging</h1>
<p>The existing logging solution was not all that great. It had drivers for several different logging solutions, but nothing terribly modern - one was for the now-discontinued Firebug extension for Firefox. However, it was fairly similar to PSR-3, so it wasn’t too much work to replace it. I installed Monolog, and amended the bootstrap file to store that as the logger in the Zend registry - that way, we could set up many different handlers. I now have it logging to a dedicated Slack channel when an error occurs in staging or production, which makes it much easier to detect problems. This would also make it easy to set up many other logging handlers, such as the ELK stack.</p>
<h1 id="debugging">Debugging</h1>
<p><a href="https://underground.works/clockwork/">Clockwork</a> is my usual PHP debugging solution, and the absence of support for it in Zend 1 made it difficult to work with. Fortunately, it’s quite straightforward to implement your own <a href="https://underground.works/clockwork/extending-data-sources?#content">data sources</a> for Clockwork. I set it up to use the aforementioned logger as a data source, as well as the <a href="https://framework.zend.com/manual/1.12/en/zend.db.profiler.html">Zend 1 profiler</a>. I also added a data source for the events implementation, and added a global <code>clock()</code> helper function, as well as one for the Symfony VarDumper component. Together these give me a reasonably good debugging experience.</p>
<h1 id="adding-console-commands">Adding console commands</h1>
<p>I’ve mentioned before that I’ve been using Symfony’s console component a lot lately, and this project is why. Zend 1 does not come with any sort of console task runner, and we needed an easy way to carry out certain tasks, such as:</p>
<ul>
<li>Setting up a stored procedure</li>
<li>Anonymizing user data with Faker</li>
<li>Regenerating durations for audio and video files</li>
</ul>
<p>In addition, I wanted a Laravel Tinker-style interactive shell. I was able to accomplish this with PsySh and the console components. For legacy projects that lack a console task runner, it’s worth considering adding one.</p>
<h1 id="configuration">Configuration</h1>
<p>The configuration system in Zend 1 is downright painful - it requires that you define multiple environments in there. I have integrated DotEnv, but only part of the configuration has been migrated over, so there’s still plenty of work there.</p>
<h1 id="what-s-left-to-do">What’s left to do</h1>
<p>The code base is in a much better state than it was, but there’s still an awful lot to do. Zend 1 does apparently still work with PHP 7.1, but not with 7.2, so at some point we’ll likely need to leave Zend 1 behind entirely. This process has already started with us ditching Zend_Log for Monolog, and over time I plan to replace the various components of Zend 1 with other packages, either ones from newer versions of Zend Framework, or elsewhere. While there are many articles about migrating Zend 1 to later versions, very few of them actually seem to go into much detail - certainly nothing as useful as a step-by-step guide.</p>
<p>The database layer is particularly bad, and refactoring some of the methods into repository classes is only the first step in bringing that under control. Once that’s finished, I’m going to start going through the models and seeing if any more methods would make more sense as static methods on the repository, and possibly rename some of them. Then, we can think about the possibility of either incrementally migrating to another database interface (either a newer version of Zend DB, or Doctrine), or refactoring the existing models to have less boilerplate by using magic methods instead of getters and setters.</p>
<p>Dependency injection is a must at some point, but isn’t practical right now - Zend 1 controllers implement an interface that defines the constructor arguments, so you can’t pass in any additional parameters, so that will need to wait until the controllers no longer use Zend 1. I have been using the Zend Registry as a poor man’s DI container, since it allows sharing of a single object throughout the application, but it’s not a good solution in the long term.</p>
<p>The routing is also painful - Zend 1’s routes are all stored in the bootstrap file. I’d prefer to use something like <code>league/route</code>, which would allow for handling different HTTP methods to the same route using different controller methods, making it easier to separate out handling of GET and POST requests.</p>
<p>I also want at some point to set up a queue system for processing video and audio content - at present it’s handled by running a shell command from PHP, which means you can’t easily get feedback if something goes wrong. Migrating that to a queue system, backed with something like Redis, would help a great deal.</p>
<h1 id="share-your-stories">Share your stories</h1>
<p>I’d love to hear any similar stories about refactoring legacy applications - how you’ve solved various problems with those legacy apps (or how you’d solve the ones I’ve had), tools you’ve used, and so on. Feel free to provide details in the comments.</p>
<p>A legacy project like this can be very frustrating to work with, but it can also feel quite rewarding to bring it under control over a period of time. My experience has been that you get the best results by working in small, regular steps, and over time your experience working with the code base will improve.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Mutation testing with Infection]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/09/13/mutation-testing-with-infection/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/09/13/mutation-testing-with-infection/</guid>
            <pubDate>Thu, 13 Sep 2018 19:10:09 GMT</pubDate>
            <description><![CDATA[<p>Writing automated tests is an excellent way of catching bugs during development and maintenance of your application, not to mention the other benefits. However, it’s hard to gauge the quality of your tests, particularly when you first start out. Coverage will give you a good idea of what code was actually run during the test, but it won’t tell you if the test itself actually tests anything worthwhile.</p>
<p><a href="https://infection.github.io/">Infection</a> is a mutation testing framework. The documentation defines mutation testing as follows:</p>
<blockquote>
<p>Mutation testing involves modifying a program in small ways. Each mutated version is called a Mutant. To assess the quality of a given test set, these mutants are executed against the input test set to see if the seeded faults can be detected. If mutated program produces failing tests, this is called a killed mutant. If tests are green with mutated code, then we have an escaped mutant.</p>
</blockquote>
<p>Infection works by running the test suite, carrying out a series of mutations on the source code in order to try to break the tests, and then collecting the results. The actual mutations carried out are not random - there is a set of mutations that get carried out every time, so results should be consistent. Ideally, all mutants should be killed by your tests - escaped mutants can indicate that either the line of mutated code is not tested, or the tests for that line are not very useful.</p>
<p>I decided to add mutation testing to my <a href="https://github.com/matthewbdaly/laravel-cart">Laravel shopping cart package</a>. In order to use Infection, you need to be able to generate code coverage, which means having either XDebug or phpdbg installed. Once Infection is installed (refer to the documentation for this), you can run this command in the project directory to configure it:</p>
<pre><code class="lang-bash">$ infection
</code></pre>
<p>Infection defaults to using PHPUnit for the tests, but it also supports PHPSpec. If you’re using PHPSpec, you will need to specify the testing framework like this:</p>
<pre><code class="lang-bash">$ infection --test-framework=phpspec
</code></pre>
<p>Since PHPSpec doesn’t support code coverage out of the box, you’ll need to install a package for that - I used <code>leanphp/phpspec-code-coverage</code>.</p>
<p>On first run, you’ll be prompted to create a configuration file. Your source directory should be straightforward to set up, but at the next step, if your project uses interfaces in the source directory, you should exclude them. The rest of the defaults should be fine.</p>
<p>I found that the first run gave a large number of uncovered results, but the second and later ones were more consistent - not sure if it’s an issue with my setup or not. Running it gave me this:</p>
<pre><code class="lang-bash">$ infection
You are running Infection with xdebug enabled.
    ____      ____          __  _
   /  _/___  / __/__  _____/ /_(_)___  ____ 
   / // __ \/ /_/ _ \/ ___/ __/ / __ \/ __ \
 _/ // / / / __/  __/ /__/ /_/ / /_/ / / / /
/___/_/ /_/_/  \___/\___/\__/_/\____/_/ /_/

    0 [&gt;---------------------------] &lt; 1 secRunning initial test suite...

PHPUnit version: 6.5.13

   27 [============================] 3 secs

Generate mutants...

Processing source code files: 5/5
Creating mutated files and processes: 43/43
.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out

...................MMM...M.......M.........          (43 / 43)

43 mutations were generated:
      38 mutants were killed
       0 mutants were not covered by tests
       5 covered mutants were not detected
       0 errors were encountered
       0 time outs were encountered

Metrics:
         Mutation Score Indicator (MSI): 88%
         Mutation Code Coverage: 100%
         Covered Code MSI: 88%

Please note that some mutants will inevitably be harmless (i.e. false positives).

Time: 21s. Memory: 12.00MB
</code></pre>
<p>Our test run shows 5 escaped mutants, and the remaining 38 were killed. We can view the results by looking at the generated <code>infection-log.txt</code>:</p>
<pre><code class="lang-txt">Escaped mutants:
================


1) /home/matthew/Projects/laravel-cart/src/Services/Cart.php:132    [M] DecrementInteger

--- Original
+++ New
@@ @@
     {
         $content = Collection::make($this-&gt;all())-&gt;map(function ($item) use($rowId) {
             if ($item[&#39;row_id&#39;] == $rowId) {
-                if ($item[&#39;qty&#39;] &gt; 0) {
+                if ($item[&#39;qty&#39;] &gt; -1) {
                     $item[&#39;qty&#39;] -= 1;
                 }
             }


2) /home/matthew/Projects/laravel-cart/src/Services/Cart.php:132    [M] OneZeroInteger

--- Original
+++ New
@@ @@
     {
         $content = Collection::make($this-&gt;all())-&gt;map(function ($item) use($rowId) {
             if ($item[&#39;row_id&#39;] == $rowId) {
-                if ($item[&#39;qty&#39;] &gt; 0) {
+                if ($item[&#39;qty&#39;] &gt; 1) {
                     $item[&#39;qty&#39;] -= 1;
                 }
             }


3) /home/matthew/Projects/laravel-cart/src/Services/Cart.php:132    [M] GreaterThan

--- Original
+++ New
@@ @@
     {
         $content = Collection::make($this-&gt;all())-&gt;map(function ($item) use($rowId) {
             if ($item[&#39;row_id&#39;] == $rowId) {
-                if ($item[&#39;qty&#39;] &gt; 0) {
+                if ($item[&#39;qty&#39;] &gt;= 0) {
                     $item[&#39;qty&#39;] -= 1;
                 }
             }


4) /home/matthew/Projects/laravel-cart/src/Services/Cart.php:133    [M] Assignment

--- Original
+++ New
@@ @@
         $content = Collection::make($this-&gt;all())-&gt;map(function ($item) use($rowId) {
             if ($item[&#39;row_id&#39;] == $rowId) {
                 if ($item[&#39;qty&#39;] &gt; 0) {
-                    $item[&#39;qty&#39;] -= 1;
+                    $item[&#39;qty&#39;] = 1;
                 }
             }
             return $item;


5) /home/matthew/Projects/laravel-cart/src/Services/Cart.php:197    [M] OneZeroInteger

--- Original
+++ New
@@ @@
      */
     private function hasStringKeys(array $items)
     {
-        return count(array_filter(array_keys($items), &#39;is_string&#39;)) &gt; 0;
+        return count(array_filter(array_keys($items), &#39;is_string&#39;)) &gt; 1;
     }
     /**
      * Validate input

Timed Out mutants:
==================

Not Covered mutants:
====================
</code></pre>
<p>This displays the mutants that escaped, and include a diff of the changed code, so we can see that all of these involve changing the comparison operators.</p>
<p>The last one can be resolved easily because the comparison is superfluous - the result of <code>count()</code> can be evaluated as true or false by itself, so removing the <code>&gt; 0</code> at the end in the test solves the problem quite neatly.</p>
<p>The other four mutations are somewhat harder. They all amend the <code>decrement</code> method’s conditions, showing that a single assertion doesn’t really fully check the behaviour. Here’s the current test for that method:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\Unit\Services;

use Tests\TestCase;
use Matthewbdaly\LaravelCart\Services\Cart;
use Mockery as m;

class CartTest extends TestCase
{
    /**
     * @dataProvider arrayProvider
     */
    public function testCanDecrementQuantity($data)
    {
        $data[0][&#39;row_id&#39;] = &#39;my_row_id_1&#39;;
        $data[1][&#39;row_id&#39;] = &#39;my_row_id_2&#39;;
        $newdata = $data;
        $newdata[1][&#39;qty&#39;] = 1;
        $session = m::mock(&#39;Illuminate\Contracts\Session\Session&#39;);
        $session-&gt;shouldReceive(&#39;get&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;)-&gt;once()-&gt;andReturn($data);
        $session-&gt;shouldReceive(&#39;put&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;, $newdata)-&gt;once();
        $uniqid = m::mock(&#39;Matthewbdaly\LaravelCart\Contracts\Services\UniqueId&#39;);
        $cart = new Cart($session, $uniqid);
        $this-&gt;assertEquals(null, $cart-&gt;decrement(&#39;my_row_id_2&#39;));
    }
}
</code></pre>
<p>It should be possible to decrement it if the quantity is more than zero, but not to go any lower. However, our current test does not catch anything but decrementing it from 2 to 1, which doesn’t fully demonstrate this. We therefore need to add a few more assertions to cover taking it down to zero, and then trying to decrement it again. Here’s how we might do that.</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\Unit\Services;

use Tests\TestCase;
use Matthewbdaly\LaravelCart\Services\Cart;
use Mockery as m;

class CartTest extends TestCase
{
    /**
     * @dataProvider arrayProvider
     */
    public function testCanDecrementQuantity($data)
    {
        $data[0][&#39;row_id&#39;] = &#39;my_row_id_1&#39;;
        $data[1][&#39;row_id&#39;] = &#39;my_row_id_2&#39;;
        $newdata = $data;
        $newdata[1][&#39;qty&#39;] = 1;
        $session = m::mock(&#39;Illuminate\Contracts\Session\Session&#39;);
        $session-&gt;shouldReceive(&#39;get&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;)-&gt;once()-&gt;andReturn($data);
        $session-&gt;shouldReceive(&#39;put&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;, $newdata)-&gt;once();
        $uniqid = m::mock(&#39;Matthewbdaly\LaravelCart\Contracts\Services\UniqueId&#39;);
        $cart = new Cart($session, $uniqid);
        $this-&gt;assertEquals(null, $cart-&gt;decrement(&#39;my_row_id_2&#39;));
        $newerdata = $newdata;
        $newerdata[1][&#39;qty&#39;] = 0;
        $session-&gt;shouldReceive(&#39;get&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;)-&gt;once()-&gt;andReturn($newdata);
        $session-&gt;shouldReceive(&#39;put&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;, $newerdata)-&gt;once();
        $this-&gt;assertEquals(null, $cart-&gt;decrement(&#39;my_row_id_2&#39;));
        $session-&gt;shouldReceive(&#39;get&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;)-&gt;once()-&gt;andReturn($newerdata);
        $session-&gt;shouldReceive(&#39;put&#39;)-&gt;with(&#39;Matthewbdaly\LaravelCart\Services\Cart&#39;, $newerdata)-&gt;once();
        $this-&gt;assertEquals(null, $cart-&gt;decrement(&#39;my_row_id_2&#39;));
    }
}
</code></pre>
<p>If we re-run Infection, we now get a much better result:</p>
<pre><code class="lang-bash">$ infection
You are running Infection with xdebug enabled.
    ____      ____          __  _
   /  _/___  / __/__  _____/ /_(_)___  ____ 
   / // __ \/ /_/ _ \/ ___/ __/ / __ \/ __ \
 _/ // / / / __/  __/ /__/ /_/ / /_/ / / / /
/___/_/ /_/_/  \___/\___/\__/_/\____/_/ /_/

Running initial test suite...

PHPUnit version: 6.5.13

   22 [============================] 3 secs

Generate mutants...

Processing source code files: 5/5
Creating mutated files and processes: 41/41
.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out

.........................................            (41 / 41)

41 mutations were generated:
      41 mutants were killed
       0 mutants were not covered by tests
       0 covered mutants were not detected
       0 errors were encountered
       0 time outs were encountered

Metrics:
         Mutation Score Indicator (MSI): 100%
         Mutation Code Coverage: 100%
         Covered Code MSI: 100%

Please note that some mutants will inevitably be harmless (i.e. false positives).

Time: 19s. Memory: 12.00MB
</code></pre>
<p>Code coverage only tells you what lines of code are actually executed - it doesn’t tell you much about how effectively that line of code is tested. Infection gives you a different insight into the quality of your tests, helping to write better ones. I’ve so far found it very useful for getting feedback on the quality of my tests. It’s interesting that PHPSpec tests seem to have a consistently lower proportion of escaped mutants than PHPUnit ones - perhaps the more natural workflow when writing specs with PHPSpec makes it easier to write good tests.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Better strings in PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/07/25/better-strings-in-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/07/25/better-strings-in-php/</guid>
            <pubDate>Wed, 25 Jul 2018 21:25:17 GMT</pubDate>
            <description><![CDATA[<p>One of the weaknesses of PHP as a programming language is the limitations of some of the fundamental types. For instance, a string in PHP is a simple value, rather than an object, and doesn’t have any methods associated with it. Instead, to manipulate a string, you have to call all manner of functions. By comparison, in Python, not only can you call methods on a string, and receive a new string as the response, making them easily chainable, but you can also iterate through a string, as in this example:</p>
<pre><code class="lang-python">&gt;&gt;&gt; a = &#39;foo&#39;
&gt;&gt;&gt; a.upper()
&#39;FOO&#39;
&gt;&gt;&gt; a.lower()
&#39;foo&#39;
&gt;&gt;&gt; for letter in a:
...   print(letter)
... 
f
o
o
</code></pre>
<p>A little while back, I read Adam Wathan’s excellent book <em>Refactoring to Collections</em>, which describes how you can use a collection implementation (such as the one included with Laravel) to replace convoluted array manipulation with simpler, chainable calls to a collection object. Using this approach, you can turn something like this:</p>
<pre><code class="lang-php">$result = array_filter(
    array_map(function ($item) {
        return $item-&gt;get(&#39;foo&#39;);
    }, $items),
    function ($item) {
        return $item-&gt;bar == true;
});
</code></pre>
<p>Or, even worse, this:</p>
<pre><code class="lang-php">$result1 = array_map(function ($item) {
    return $item-&gt;get(&#39;foo&#39;);
}, $items);
$result2 = array_filter($result1, function ($item) {
    return $item-&gt;bar == true;
});
</code></pre>
<p>Into this:</p>
<pre><code class="lang-php">$result = Collection::make($items)
    -&gt;map(function ($item) {
        return $item-&gt;get(&#39;foo&#39;);
    })-&gt;filter(function ($item) {
        return $item-&gt;bar == true;
    })-&gt;toArray();
</code></pre>
<p>Much cleaner, more elegant, and far easier to understand.</p>
<p>A while back, after some frustration with PHP’s native strings, I started wondering how practical it would be to produce a string implementation that was more like the string objects in languages like Python and Javascript, with inspiration from collection implementations such as that used by Laravel. I soon discovered that it was very practical, and with a bit of work it’s not hard to produce your own, more elegant string class.</p>
<p>The most fundamental functionality required is to be able to create a string object, either by passing a string to the constructor or calling a static method. Our string class should be able to do both:</p>
<pre><code class="lang-php">&lt;?php

class Str
{
    protected $string;

    public function __construct(string $string = &#39;&#39;)
    {
        $this-&gt;string = $string;
    }

    public static function make(string $string)
    {
        return new static($string);
    }
}
</code></pre>
<h2 id="making-it-iterable">Making it iterable</h2>
<p>To be able to get the length of a string, it needs to implement the <a href="http://php.net/manual/en/class.countable.php"><code>Countable</code></a> interface:</p>
<pre><code class="lang-php">use Countable;

class Str implements Countable
{
    ...
    public function count()
    {
        return strlen($this-&gt;string);
    }
}
</code></pre>
<p>To access it as an array, it needs to implement the <a href="http://php.net/manual/en/class.arrayaccess.php"><code>ArrayAccess</code></a> interface:</p>
<pre><code class="lang-php">...
use ArrayAccess;

class Str implements Countable, ArrayAccess
{
    ...
    public function offsetExists($offset)
    {
        return isset($this-&gt;string[$offset]);
    }

    public function offsetGet($offset)
    {
        return isset($this-&gt;string[$offset]) ? $this-&gt;string[$offset] : null;
    }

    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this-&gt;string[] = $value;
        } else {
            $this-&gt;string[$offset] = $value;
        }
    }

    public function offsetUnset($offset)
    {
        $this-&gt;string = substr_replace($this-&gt;string, &#39;&#39;, $offset, 1);
    }
}
</code></pre>
<p>And to make it iterable, it needs to implement the <a href="http://php.net/manual/en/class.iterator.php"><code>Iterator</code></a> interface:</p>
<pre><code class="lang-php">use Iterator;

class Str implements Countable, ArrayAccess, Iterator
{
    ...
    public function current()
    {
        return $this-&gt;string[$this-&gt;position];
    }

    public function key()
    {
        return $this-&gt;position;
    }

    public function next()
    {
        ++$this-&gt;position;
    }

    public function rewind()
    {
        $this-&gt;position = 0;
    }

    public function valid()
    {
        return isset($this-&gt;string[$this-&gt;position]);
    }
}
</code></pre>
<h2 id="making-it-work-as-a-string">Making it work as a string</h2>
<p>To be useful, it also needs to be possible to actually use it as a string - for instance, you should be able to do this:</p>
<pre><code class="lang-php">$foo = Str::make(&#39;I am the very model of a modern major general&#39;);
echo $foo;
</code></pre>
<p>Fortunately, the <a href="http://php.net/manual/en/language.oop5.magic.php#object.tostring"><code>__toString()</code></a> magic method allows this:</p>
<pre><code class="lang-php">    public function __toString()
    {
        return $this-&gt;string;
    }
</code></pre>
<h2 id="adding-methods">Adding methods</h2>
<p>With that functionality in place, you can then start adding support for the methods you need in your string objects. If you’re looking to be able to use the same functionality as existing PHP methods, you can call those functions inside your methods. However, be sure to return a new instance of your string object from each method - that way, you can continually chain them:</p>
<pre><code class="lang-php">    public function replace($find, $replace)
    {
        return new static(str_replace($find, $replace, $this-&gt;string));
    }

    public function toUpper()
    {
        return new static(strtoupper($this-&gt;string));
    }

    public function toLower()
    {
        return new static(strtolower($this-&gt;string));
    }

    public function trim()
    {
        return new static(trim($this-&gt;string));
    }

    public function ltrim()
    {
        return new static(ltrim($this-&gt;string));
    }

    public function rtrim()
    {
        return new static(rtrim($this-&gt;string));
    }
</code></pre>
<p>Now, you can write something like this:</p>
<pre><code class="lang-php">return Str::make(&#39;I am the very model of a modern major general  &#39;)
    -&gt;trim()
    -&gt;replace(&#39;modern major general&#39;, &#39;scientist Salarian&#39;)
    -&gt;toLower();
</code></pre>
<p>While you could do this with PHP’s native string functions alone, it would be a lot less elegant. In addition, if you have other, more complex string manipulations that you often do in a particular application, it may make sense to write a method for that so that your string objects can encapsulate that functionality for easier reuse.</p>
<p>As our string objects are iterable, we can also do this:</p>
<pre><code class="lang-php">&gt;&gt;&gt; $foo = Str::make(&#39;foo&#39;);
&gt;&gt;&gt; foreach ($foo as $letter) { echo &quot;$letter\n&quot;; }
f
o
o
</code></pre>
<p>If you have an application that does some complex string manipulation, having a string utility class like this can make for much more expressive, elegant and easy-to-comprehend code than PHP’s native string functions. If you want to see a working implementation for this, check out my proof of concept collection and string utility library <a href="https://github.com/matthewbdaly/proper">Proper</a>.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Forcing SSL in CodeIgniter]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/06/23/forcing-ssl-in-codeigniter/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/06/23/forcing-ssl-in-codeigniter/</guid>
            <pubDate>Sat, 23 Jun 2018 12:03:28 GMT</pubDate>
            <description><![CDATA[<p>I haven’t started a new CodeIgniter project since 2014, and don’t intend to, but on occasion I’ve been asked to do maintenance work on legacy CodeIgniter projects. This week I was asked to help out with a situation where a CodeIgniter site was being migrated to HTTPS and there were issues resulting from the migration.</p>
<p>Back in 2012, when working on my first solo project, I’d built a website using CodeIgniter that used HTTPS, but also needed to support an affiliate marketing system that did not support it, so certain pages had to force HTTP, and others had to force HTTPS, so I’d used the hook system to create hooks to enforce this. This kind of requirement is unlikely to reoccur now because HTTPS is becoming more prevalent, but sometimes it may be easier to enforce HTTPS at application level than in the web server configuration or using htaccess. It’s relatively straightforward to do that in CodeIgniter.</p>
<p>The first step is to create the hook. Save this as <code>application/hooks/ssl.php</code>:</p>
<pre><code class="lang-php">&lt;?php
function force_ssl()
{
    $CI =&amp; get_instance();
    $CI-&gt;config-&gt;config[&#39;base_url&#39;] = str_replace(&#39;http://&#39;, &#39;https://&#39;, $CI-&gt;config-&gt;config[&#39;base_url&#39;]);
    if ($_SERVER[&#39;SERVER_PORT&#39;] != 443) redirect($CI-&gt;uri-&gt;uri_string());
}
?&gt;
</code></pre>
<p>Next, we register the hook. Update <code>application/configs/hooks.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php  if ( ! defined(&#39;BASEPATH&#39;)) exit(&#39;No direct script access allowed&#39;);
/*
| -------------------------------------------------------------------------
| Hooks
| -------------------------------------------------------------------------
| This file lets you define &quot;hooks&quot; to extend CI without hacking the core
| files.  Please see the user guide for info:
|
|    http://codeigniter.com/user_guide/general/hooks.html
|
*/

$hook[&#39;post_controller_constructor&#39;][] = array(
                                &#39;function&#39; =&gt; &#39;force_ssl&#39;,
                                &#39;filename&#39; =&gt; &#39;ssl.php&#39;,
                                &#39;filepath&#39; =&gt; &#39;hooks&#39;
                                );

/* End of file hooks.php */
/* Location: ./application/config/hooks.php */
</code></pre>
<p>This tells CodeIgniter that it should looks in the <code>application/hooks</code> directory for a file called <code>ssl.php</code>, and return the function <code>force_ssl</code>.</p>
<p>Finally, we enable hooks. Update <code>application/config/config.php</code>:</p>
<pre><code class="lang-php">$config[&#39;enable_hooks&#39;] = TRUE;
</code></pre>
<p>If you only want to force SSL in production, not development, you may want to amend the <code>ssl.php</code> file to only perform the redirect in non-development environments, perhaps by using an environment variable via DotEnv.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Logging to the ELK stack with Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/</guid>
            <pubDate>Sun, 03 Jun 2018 15:30:54 GMT</pubDate>
            <description><![CDATA[<p>Logging to text files is the simplest and most common logging setup for web apps, and it works fine for relatively small and simple applications. However, it does have some downsides:</p>
<ul>
<li>It’s difficult to make the log files accessible - normally users have to SSH in to read them.</li>
<li>The tools used to filter and analyse log files have a fairly high technical barrier to access - grep and sed are not exactly easy for non-programmers to pick up, so business information can be hard to get.</li>
<li>It’s hard to visually identify trends in the data.</li>
<li>Log files don’t let you know immediately when something urgent happens</li>
<li>You can’t access logs for different applications through the same interface.</li>
</ul>
<p>For rare, urgent issues where you need to be informed immediately they occur, it’s straightforward to log to an instant messaging solution such as Slack or Hipchat. However, these aren’t easily searchable, and can only be used for the most important errors (otherwise, there’s a risk that important data will be lost in the noise). There are third-party services that allow you to search and filter your logs, but they can be prohibitively expensive.</p>
<p>The <a href="https://www.elastic.co/elk-stack">ELK stack</a> has recently gained a lot of attention as a sophisticated solution for logging application data. It consists of:</p>
<ul>
<li>Logstash for processing log data</li>
<li>Elasticsearch as a searchable storage backend</li>
<li>Kibana as a web interface</li>
</ul>
<p>By making the log data available using a powerful web interface, you can easily expose it to non-technical users. Kibana also comes with powerful tools to aggregate and filter the data. In addition, you can run your own instance, giving you a greater degree of control (as well as possibly being more cost-effective) compared to using a third-party service.</p>
<p>In this post I’ll show you how to configure a Laravel application to log to an instance of the ELK stack. Fortunately, Laravel uses the popular Monolog logging library by default, which is relatively easy to get to work with the ELK stack. First, we need to install support for the GELF logging format:</p>
<pre><code class="lang-bash">$ composer require graylog2/gelf-php
</code></pre>
<p>Then, we create a custom logger class:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Logging;

use Monolog\Logger;
use Monolog\Handler\GelfHandler;
use Gelf\Publisher;
use Gelf\Transport\UdpTransport;

class GelfLogger
{
    /**
     * Create a custom Monolog instance.
     *
     * @param  array  $config
     * @return \Monolog\Logger
     */
    public function __invoke(array $config)
    {
        $handler = new GelfHandler(new Publisher(new UdpTransport($config[&#39;host&#39;], $config[&#39;port&#39;])));
        return new Logger(&#39;main&#39;, [$handler]);
    }
}
</code></pre>
<p>Finally, we configure our application to use this as our custom driver and specify the host and port in <code>config/logging.php</code>:</p>
<pre><code class="lang-php">        &#39;custom&#39; =&gt; [
            &#39;driver&#39; =&gt; &#39;custom&#39;,
            &#39;via&#39; =&gt; App\Logging\GelfLogger::class,
            &#39;host&#39; =&gt; &#39;127.0.0.1&#39;,
            &#39;port&#39; =&gt; 12201,
        ],
</code></pre>
<p>You can then set up whatever logging channels you need for your application, and specify whatever log level you feel is appropriate.</p>
<p>Please note that this requires at least Laravel 5.6 - this file doesn’t exist in Laravel 5.5 and earlier, so you may have more work on your hands to integrate it with older versions.</p>
<p>If you already have an instance of the ELK stack set up on a remote server that’s already set up to accept input as GELF, then you should be able to point it at that and you’ll be ready to go. If you just want to try it out, I’ve been using a <a href="https://github.com/deviantony/docker-elk">Docker-based project</a> that makes it straightforward to run the whole stack locally. However, you will need to amend <code>logstash/pipeline/logstash.conf</code> as follows to allow it to accept log data:</p>
<pre><code class="lang-json">input {
    tcp {
        port =&gt; 5000
    }
   gelf {
       port =&gt; 12201
       type =&gt; gelf
       codec =&gt; &quot;json&quot;
   }
}

## Add your filters / logstash plugins configuration here

output {
    elasticsearch {
        hosts =&gt; &quot;elasticsearch:9200&quot;
    }
}
</code></pre>
<p>Then you can start it up using the instructions in the repository and it should be ready to go. Now, if you run the following command from Tinker:</p>
<pre><code class="lang-php">Log::info(&#39;Just testing&#39;);
</code></pre>
<p>Then if you access the web interface, you should be able to find that log message without any difficulty.</p>
<p>Now, this only covers the Laravel application logs. You may well want to pass other logs through to Logstash, such as Apache, Nginx or MySQL logs, and a quick Google should be sufficient to find ideas on how you might log for these services. Creating visualisations with Kibana is a huge subject, and the existing documentation covers that quite well, so if you’re interested in learning more about that I’d recommend reading the documentation and having a play with the dashboard.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a letter classifier in PHP with Tesseract OCR and PHP ML]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/05/10/building-a-letter-classifier-in-php-with-tesseract-ocr-and-php-ml/</guid>
            <pubDate>Thu, 10 May 2018 22:50:08 GMT</pubDate>
            <description><![CDATA[<p>PHP isn’t the first language that springs to mind when it comes to machine learning. However, it is practical to use PHP for machine learning purposes. In this tutorial I’ll show you how to build a pipeline for classifying letters.</p>
<h2 id="the-brief">The brief</h2>
<p>Before I was a web dev, I was a clerical worker for an FTSE-100 insurance company, doing a lot of work that nowadays is possible to automate away, if you know how. When they received a letter or other communication from a client, it would be sent to be scanned on. Once scanned, a human would have to look at it to classify it, eg was it a complaint, a request for information, a request for a quote, or something else, as well as assign it to a policy number. Let’s imagine we’ve been asked to build a proof of concept for automating this process. This is a good example of a real-world problem that machine learning can help with.</p>
<p>As this is a proof of concept we aren’t looking to build a web app for this - for simplicity’s sake this will be a command-line application. Unlike emails, letters don’t come in an easily machine-readable format, so we will be receiving them as PDF files (since they would have been scanned on, this is a reasonable assumption). Feel free to mock up your own example letters using your own classifications, but I will be classifying letters into four groups:</p>
<ul>
<li><strong>Complaints</strong> - letters expressing dissatisfaction</li>
<li><strong>Information requests</strong> - letters requesting general information</li>
<li><strong>Surrender quotes</strong> - letters requesting a surrender quote</li>
<li><strong>Surrender forms</strong> - letters requesting surrender forms</li>
</ul>
<p>Our application will therefore take in a PDF file at one end, and perform the following actions on it:</p>
<ul>
<li>Convert the PDF file to a PNG file</li>
<li>Use OCR (optical character recognition) to convert the letter to plain text</li>
<li>Strip out unwanted whitespace</li>
<li>Extract any visible policy number from the text</li>
<li>Use a machine learning library to classify the letter, having taught it using prior examples</li>
</ul>
<p>Sound interesting? Let’s get started…</p>
<h2 id="introducing-pipelines">Introducing pipelines</h2>
<p>As our application will be carrying out a series of discrete steps on our data, it makes sense to use the pipeline pattern for this project. Fortunately, the PHP League have produced a excellent <a href="http://pipeline.thephpleague.com/">package</a> implementing this. We can therefore create a single class for each step in the process and have it handle that in isolation.</p>
<p>We’ll also use the Symfony Console component to implement our command-line application. For our machine learning library we will be using <a href="https://php-ml.readthedocs.io/en/latest/">PHP ML</a>, which requires PHP 7.1 or greater. For OCR, we will be using <a href="https://github.com/thiagoalessio/tesseract-ocr-for-php">Tesseract</a>, so you will need to install the underlying Tesseract OCR library, as well as support for your language. On Ubuntu you can install these as follows:</p>
<pre><code class="lang-bash">$ sudo apt-get install tesseract-ocr tesseract-ocr-eng
</code></pre>
<p>This assumes you are using English, however you should be able to find packages to support many other languages. Finally, we need ImageMagick to be installed in order to convert PDF files to PNG’s.</p>
<p>Your <code>composer.json</code> should look something like this:</p>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;matthewbdaly/letter-classifier&quot;,
    &quot;description&quot;: &quot;Demo of classifying letters in PHP&quot;,
    &quot;type&quot;: &quot;project&quot;,
    &quot;require&quot;: {
        &quot;league/pipeline&quot;: &quot;^0.3.0&quot;,
        &quot;thiagoalessio/tesseract_ocr&quot;: &quot;^2.2&quot;,
        &quot;php-ai/php-ml&quot;: &quot;^0.6.2&quot;,
        &quot;symfony/console&quot;: &quot;^4.0&quot;
    },
    &quot;require-dev&quot;: {
        &quot;phpspec/phpspec&quot;: &quot;^4.3&quot;,
        &quot;psy/psysh&quot;: &quot;^0.8.17&quot;
    },
    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;Matthewbdaly\\LetterClassifier\\&quot;: &quot;src/&quot;
        }
    },
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;authors&quot;: [
        {
            &quot;name&quot;: &quot;Matthew Daly&quot;,
            &quot;email&quot;: &quot;matthewbdaly@gmail.com&quot;
        }
    ]
}
</code></pre>
<p>Next, let’s write the outline of our command-line client. We’ll load a single class for our processor command. Save this as <code>app</code>:</p>
<pre><code class="lang-php">#!/usr/bin/env php
&lt;?php

require __DIR__.&#39;/vendor/autoload.php&#39;;

use Symfony\Component\Console\Application;
use Matthewbdaly\LetterClassifier\Commands\Processor;

$application = new Application();
$application-&gt;add(new Processor());
$application-&gt;run();
</code></pre>
<p>Next, we create our command. Save this as <code>src/Commands/Processor.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Commands;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputArgument;
use League\Pipeline\Pipeline;
use Matthewbdaly\LetterClassifier\Stages\ConvertPdfToPng;
use Matthewbdaly\LetterClassifier\Stages\ReadFile;
use Matthewbdaly\LetterClassifier\Stages\Classify;
use Matthewbdaly\LetterClassifier\Stages\StripTabs;
use Matthewbdaly\LetterClassifier\Stages\GetPolicyNumber;

class Processor extends Command
{
    protected function configure()
    {
        $this-&gt;setName(&#39;process&#39;)
            -&gt;setDescription(&#39;Processes a file&#39;)
            -&gt;setHelp(&#39;This command processes a file&#39;)
            -&gt;addArgument(&#39;file&#39;, InputArgument::REQUIRED, &#39;File to process&#39;);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $file = $input-&gt;getArgument(&#39;file&#39;);
        $pipeline = (new Pipeline)
            -&gt;pipe(new ConvertPdfToPng)
            -&gt;pipe(new ReadFile)
            -&gt;pipe(new StripTabs)
            -&gt;pipe(new GetPolicyNumber)
            -&gt;pipe(new Classify);
        $response = $pipeline-&gt;process($file);
        $output-&gt;writeln(&quot;Classification is &quot;.$response[&#39;classification&#39;]);
        $output-&gt;writeln(&quot;Policy number is &quot;.$response[&#39;policy&#39;]);
    }
}
</code></pre>
<p>Note how our command accepts the file name as an argument. We then instantiate our pipeline and pass it through a series of classes, each of which has a single role. Finally, we retrieve our response and output it.</p>
<p>With that done, we can move on to implementing our first step. Save this as <code>src/Stages/ConvertPdfToPng.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Stages;

use Imagick;

class ConvertPdfToPng
{
    public function __invoke($file)
    {
        $tmp = tmpfile();
        $uri = stream_get_meta_data($tmp)[&#39;uri&#39;];
        $img = new Imagick();
        $img-&gt;setResolution(300, 300);
        $img-&gt;readImage($file);
        $img-&gt;setImageDepth(8);
        $img-&gt;setImageFormat(&#39;png&#39;);
        $img-&gt;writeImage($uri);
        return $tmp;
    }
}
</code></pre>
<p>This stage fetches the file passed through, and converts it into a PNG file, stores it as a temporary file, and returns a reference to it. The output of this stage will then form the input of the next. This is how pipelines work, and it makes it easy to break up a complex process into multiple steps that can be reused in different places, facilitating easier code reuse and making your code simpler to understand and reason about.</p>
<p>Our next step carries out optical character recognition. Save this as <code>src/Stages/ReadFile.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Stages;

use thiagoalessio\TesseractOCR\TesseractOCR;

class ReadFile
{
    public function __invoke($file)
    {
        $uri = stream_get_meta_data($file)[&#39;uri&#39;];
        $ocr = new TesseractOCR($uri);
        return $ocr-&gt;lang(&#39;eng&#39;)-&gt;run();
    }
}
</code></pre>
<p>As you can see, this accepts the link to the temporary file as an argument, and runs Tesseract on it to retrieve the text. Note that we specify a language of <code>eng</code> - if you want to use a language other than English, you should specify it here.</p>
<p>At this point, we should have some usable text, but there may be unknown amounts of whitespace, so our next step uses a regex to strip them out. Save this as <code>src/Stages/StripTabs.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Stages;

class StripTabs
{
    public function __invoke($content)
    {
        return trim(preg_replace(&#39;/\s+/&#39;, &#39; &#39;, $content));
    }
}
</code></pre>
<p>With our whitespace issue sorted out, we now need to retrieve the policy number the communication should be filed under. These are generally regular alphanumeric patterns, so regexes are a suitable way of matching them. As this is a proof of concept, we’ll assume a very simple pattern for policy numbers in that they will consist of between seven and nine digits. Save this as <code>src/Stages/GetPolicyNumber.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Stages;

class GetPolicyNumber
{
    public function __invoke($content)
    {
        $matches = [];
        $policyNumber = &#39;&#39;;
        preg_match(&#39;/\d{7,9}/&#39;, $content, $matches);
        if (count($matches)) {
            $policyNumber = $matches[0];
        }
        return [
            &#39;content&#39; =&gt; $content,
            &#39;policy&#39; =&gt; $policyNumber
        ];
    }
}
</code></pre>
<p>Finally, we’re onto the really tough part - using machine learning to classify the letters. Save this as <code>src/Stages/Classify.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\LetterClassifier\Stages;

use Phpml\Dataset\CsvDataset;
use Phpml\Dataset\ArrayDataset;
use Phpml\FeatureExtraction\TokenCountVectorizer;
use Phpml\Tokenization\WordTokenizer;
use Phpml\CrossValidation\StratifiedRandomSplit;
use Phpml\FeatureExtraction\TfIdfTransformer;
use Phpml\Metric\Accuracy;
use Phpml\Classification\SVC;
use Phpml\SupportVectorMachine\Kernel;

class Classify
{
    protected $classifier;

    protected $vectorizer;

    protected $tfIdfTransformer;

    public function __construct()
    {
        $this-&gt;dataset = new CsvDataset(&#39;data/letters.csv&#39;, 1);
        $this-&gt;vectorizer = new TokenCountVectorizer(new WordTokenizer());
        $this-&gt;tfIdfTransformer = new TfIdfTransformer();
        $samples = [];
        foreach ($this-&gt;dataset-&gt;getSamples() as $sample) {
                $samples[] = $sample[0];
        }
        $this-&gt;vectorizer-&gt;fit($samples);
        $this-&gt;vectorizer-&gt;transform($samples);
        $this-&gt;tfIdfTransformer-&gt;fit($samples);
        $this-&gt;tfIdfTransformer-&gt;transform($samples);
        $dataset = new ArrayDataset($samples, $this-&gt;dataset-&gt;getTargets());
        $randomSplit = new StratifiedRandomSplit($dataset, 0.1);
        $this-&gt;classifier = new SVC(Kernel::RBF, 10000);
        $this-&gt;classifier-&gt;train($randomSplit-&gt;getTrainSamples(), $randomSplit-&gt;getTrainLabels());
        $predictedLabels = $this-&gt;classifier-&gt;predict($randomSplit-&gt;getTestSamples());
        echo &#39;Accuracy: &#39;.Accuracy::score($randomSplit-&gt;getTestLabels(), $predictedLabels);
    }

    public function __invoke(array $message)
    {
        $newSample = [$message[&#39;content&#39;]];
        $this-&gt;vectorizer-&gt;transform($newSample);
        $this-&gt;tfIdfTransformer-&gt;transform($newSample);
        $message[&#39;classification&#39;] = $this-&gt;classifier-&gt;predict($newSample)[0];
        return $message;
    }
}
</code></pre>
<p>In our constructor, we train up our model by passing our sample data through the following steps:</p>
<ul>
<li>First, we use the token count vectorizer to convert our samples to a vector of token counts - replacing every word with a number and keeping track of how often that word occurs.</li>
<li>Next, we use <code>TfIdfTransformer</code> to get statistics about how important a word is in a document.</li>
<li>Then we instantiate our classifier and train it on a random subset of our data.</li>
<li>Finally, we pass our message to our now-trained classifier and see what it tells us.</li>
</ul>
<p>Now, bear in mind I don’t have a background in machine learning and this is the first time I’ve done anything with machine learning, so I can’t tell you much more than that - if you want to know more I suggest you investigate on your own. In figuring this out I was helped a great deal by <a href="https://www.sitepoint.com/how-to-analyze-tweet-sentiments-with-php-machine-learning/">this article on Sitepoint</a>, so you might want to start there.</p>
<p>The finished application is <a href="https://github.com/matthewbdaly/letter-classifier">on GitHub</a>, and the repository includes a CSV file of training data, as well as the <code>examples</code> folder, which contains some example PDF files. You can run it as follows:</p>
<pre><code class="lang-bash">$ php app process examples/Quote.pdf
</code></pre>
<p>I found that once I had trained it up using the CSV data from the repository, it was around 70-80% accurate, which isn’t bad at all considering the comparatively small size of the dataset. If this were genuinely being used in production, there would be an extremely large dataset of historical scanned letters to use for training purposes, so it wouldn’t be unreasonable to expect much better results under those circumstances.</p>
<h2 id="exercises-for-the-reader">Exercises for the reader</h2>
<p>If you want to develop this concept further, here are some ideas:</p>
<ul>
<li>We should be able to correct the model when it’s wrong. Add a separate command to train the model by passing through a file and specifying how it should be categorised, eg <code>php app train File.pdf quote</code>.</li>
<li>Try processing information from different sources. For instance, you could replace the first two stages with a stage that pulls all unread emails from a specified mailbox using PHP’s IMAP support, or fetching data from the Twitter API. Or you could have a telephony service such as Twilio set up as your voicemail, and automatically transcribe them, then pass the text to PHP ML for classification.</li>
<li>If you’re multilingual, you could try adding a step to sort letters by language and have separate models for classifying in each language</li>
</ul>
<h2 id="summary">Summary</h2>
<p>It’s actually quite a sobering thought that <em>already</em> it’s possible to use techniques like these to produce tools that replace people in various jobs, and as the tooling matures more and more tasks involving classification are going to become amenable to automation using machine learning.</p>
<p>This was my first experience with machine learning and it’s been very interesting for me to solve a real-world problem with it. I hope it gives you some ideas about how you could use it too.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Console applications with the Symfony Console component]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/04/29/console-applications-with-the-symfony-console-component/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/04/29/console-applications-with-the-symfony-console-component/</guid>
            <pubDate>Sun, 29 Apr 2018 19:59:27 GMT</pubDate>
            <description><![CDATA[<p>Recently I’ve had the occasion to add a series of console commands to a legacy application. This can be made straightforward by using the Symfony console component. In this post I’ll demonstrate how to write a simple console command for clearing a cache folder.</p>
<p>The first step is to install the Console component:</p>
<pre><code class="lang-bash">$ composer require symfony/console
</code></pre>
<p>Then we write the main script for the application. I usually save mine as <code>console</code> - note that we don’t want to have to type out a file extension, so instead we use the shebang:</p>
<pre><code class="lang-php">#!/user/bin/env php
&lt;?php

require __DIR__.&#39;/vendor/autoload.php&#39;;

use Symfony\Component\Console\Application;

define(&#39;CONSOLE_ROOT&#39;, __DIR__);
$app = new Application();

$app-&gt;run();
</code></pre>
<p>In this case, I’ve defined <code>CONSOLE_ROOT</code> as the directory in which the console command is run - that way, the commands can use it to refer to the application root.</p>
<p>We can then run our console application as follows:</p>
<pre><code class="lang-bash">$ php console
Console Tool

Usage:
  command [options] [arguments]

Options:
  -h, --help            Display this help message
  -q, --quiet           Do not output any message
  -V, --version         Display this application version
      --ansi            Force ANSI output
      --no-ansi         Disable ANSI output
  -n, --no-interaction  Do not ask any interactive question
  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug

Available commands:
  help  Displays help for a command
  list  Lists commands
</code></pre>
<p>This displays the available commands, but you’ll note that there are none except for <code>help</code> and <code>list</code>. We’ll remedy that. First, we’ll register a command:</p>
<pre><code class="lang-php">$app-&gt;add(new App\Console\ClearCacheCommand);
</code></pre>
<p>This has to be done in <code>console</code>, after we create <code>$app</code>, but before we run it.</p>
<p>Don’t forget to update the autoload section of your <code>composer.json</code> to register the namespace:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;App\\Console\\&quot;: &quot;src/Console/&quot;
        }
    },
</code></pre>
<p>Then create the class for that command. This class must extend <code>Symfony\Component\Console\Command\Command</code>, and must have two methods:</p>
<ul>
<li><code>configure()</code></li>
<li><code>execute()</code></li>
</ul>
<p>In addition, the <code>execute()</code> method must accept two arguments, an instance of <code>Symfony\Component\Console\Input\InputInterface</code>, and an instance of <code>Symfony\Component\Console\Output\OutputInterface</code>. There are used to retrieve input and display output.</p>
<p>Let’s write our command:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class ClearCacheCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName(&#39;cache:clear&#39;)
             -&gt;setDescription(&#39;Clears the cache&#39;)
             -&gt;setHelp(&#39;This command clears the application cache&#39;);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $dir = CONSOLE_ROOT.DIRECTORY_SEPARATOR.&#39;cache&#39;;
        $this-&gt;deleteTree($dir);
        $output-&gt;writeln(&#39;Cache cleared&#39;);
    } 

    private function deleteTree($dir)
    {
        $files = array_diff(scandir($dir), array(&#39;.&#39;,&#39;..&#39;)); 
        foreach ($files as $file) { 
            (is_dir(&quot;$dir/$file&quot;)) ? $this-&gt;deleteTree(&quot;$dir/$file&quot;) : unlink(&quot;$dir/$file&quot;); 
        } 
        return rmdir($dir); 
    }
}
</code></pre>
<p>As you can see, in the <code>configure()</code> method, we set the name, description and help text for the command.</p>
<p>The <code>execute()</code> method is where the actual work is done. In this case, we have some code that needs to be called recursively, so we have to pull it out into a private method. Once that’s done we use <code>$output-&gt;writeln()</code> to write a line to the output.</p>
<p>Now, if we run our console task, we should see our new command:</p>
<pre><code class="lang-bash">$ php console
Console Tool

Usage:
  command [options] [arguments]

Options:
  -h, --help            Display this help message
  -q, --quiet           Do not output any message
  -V, --version         Display this application version
      --ansi            Force ANSI output
      --no-ansi         Disable ANSI output
  -n, --no-interaction  Do not ask any interactive question
  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug

Available commands:
  help         Displays help for a command
  list         Lists commands
 cache
  cache:clear  Clears the cache
</code></pre>
<p>And we can see it in action too:</p>
<pre><code class="lang-bash">$ php console cache:clear
Cache cleared
</code></pre>
<p>For commands that need to accept additional arguments, you can define them in the <code>configure()</code> method:</p>
<pre><code class="lang-php">$this-&gt;addArgument(&#39;file&#39;, InputArgument::REQUIRED, &#39;Which file do you want to delete?&#39;)
</code></pre>
<p>Then, you can access it in the <code>execute()</code> method using <code>InputInterface</code>:</p>
<pre><code class="lang-php">$file = $input-&gt;getArgument(&#39;file&#39;);
</code></pre>
<p>This tutorial is just skimming the surface of what you can do with the Symfony Console components - indeed, many other console interfaces, such as Laravel’s Artisan, are built on top of it. If you have a legacy application built in a framework that lacks any sort of console interface, such as CodeIgniter, then you can quite quickly produce basic console commands for working with that application. The <a href="https://symfony.com/doc/current/console.html">documentation is very good</a>, and with a little work you can soon have something up and running.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Rendering different views for mobile and desktop clients in Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/</guid>
            <pubDate>Sun, 22 Apr 2018 22:50:10 GMT</pubDate>
            <description><![CDATA[<p>This was a bit of a weird post to write. It started out explaining how I resolved an issue years ago on a CodeIgniter site, but amended to work for Laravel. In the process, I realised it made sense to implement it as middleware, and I ended up pulling it out into <a href="https://github.com/matthewbdaly/laravel-dynamic-serving">a package</a>. However, it’s still useful to understand the concept behind it, even if you prefer to just install the complete package, because your needs might be slightly different to mine.</p>
<p>On web development forums, it’s quite common to see variants of the following question:</p>
<blockquote>
<p>How do I redirect a user on a mobile device to a mobile version of the site?</p>
</blockquote>
<p>It’s quite surprising that this is still an issue that crops up. For many years, it’s been widely accepted that the correct solution for this problem is responsive design. However, there are ways in which this may not be adequate for certain applications. For instance, you may have an application where certain functionality only makes sense in a certain context, or your user interface may need to be optimised for specific environments.</p>
<p>The trouble is that a dedicated mobile site isn’t a good idea either. Among other things, it means that users can’t easily use the same bookmarks between desktop and mobile versions, and can result in at least some of the server-side logic being duplicated.</p>
<p>Fortunately, there is another way - <a href="https://developers.google.com/search/mobile-sites/mobile-seo/dynamic-serving">dynamic serving</a> allows you to render different content based on the user agent. You can also easily enable users to switch between desktop and mobile versions themselves if their client isn’t detected correctly or they just prefer the other one. I’ve implemented this years ago for a CodeIgniter site. Here’s how you might implement it in Laravel, although if you understand the principle behind it, it should be easy to adapt for any other framework.</p>
<p>Don’t try to implement mobile user agent detection yourself. Instead, find an implementation that’s actively maintained and install it with Composer. That way you can be reasonably sure that as new mobile devices come onto the market the package will detect them correctly as long as you keep it up to date. I would be inclined to go for <a href="https://github.com/jenssegers/agent">Agent</a>, since it has Laravel support baked in.</p>
<p>We could just use Agent to serve up different content based on the user agent. However, user agent strings are notoriously unreliable - if a new mobile device appears and it doesn’t show up correctly in Agent, users could find themselves forced to use the wrong UI. Instead, we need to check for a flag in the session that indicates if the session is mobile or not. If it’s not set, we set it based on the user agent. That way, if you need to offer functionality to override the detected session type, you can just update that session variable to correct that elsewhere in the application. I would be inclined to use a button in the footer that makes an AJAX request to toggle the flag, then reloads the page.</p>
<p>You also need to set the HTTP response header <code>Vary: User-Agent</code> to notify clients (including not only search engines, but also proxies at either end of the connection, such as Varnish or Squid) that the response will differ by user agent, in order to prevent users being served the wrong version.</p>
<p>Middleware is the obvious place to do this. Here’s a middleware that sets the session variable and the appropriate response headers:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;
use Jenssegers\Agent\Agent;
use Illuminate\Contracts\Session\Session;

class DetectMobile
{
    protected $agent;

    protected $session;

    public function __construct(Agent $agent, Session $session)
    {
        $this-&gt;agent = $agent;
        $this-&gt;session = $session;
    }

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if (!$this-&gt;session-&gt;exists(&#39;mobile&#39;)) {
            if ($this-&gt;agent-&gt;isMobile() || $this-&gt;agent-&gt;isTablet()) {
                $this-&gt;session-&gt;put(&#39;mobile&#39;, true);
            } else {
                $this-&gt;session-&gt;put(&#39;mobile&#39;, false);
            }
        }
        $response = $next($request);
        return $response-&gt;setVary(&#39;User-Agent&#39;);
    }
}
</code></pre>
<p>Now, you could then work with the session directly to retrieve the <code>mobile</code> flag, but as you may be working in the view, it makes sense to create helpers for this:</p>
<pre><code class="lang-php">&lt;?php

if (!function_exists(&#39;is_mobile&#39;)) {
    function is_mobile()
    {
        $session = app()-&gt;make(&#39;Illuminate\Contracts\Session\Session&#39;);
        return $session-&gt;get(&#39;mobile&#39;) == true;
    }
}

if (!function_exists(&#39;is_desktop&#39;)) {
    function is_desktop()
    {
        $session = app()-&gt;make(&#39;Illuminate\Contracts\Session\Session&#39;);
        return $session-&gt;get(&#39;mobile&#39;) == false;
    }
}
</code></pre>
<p>Now, if you want to serve up completely different views, you can use these helpers in your controllers. If you instead want to selectively show and hide parts of the UI based on the user agent, you can instead use these in the views to determine what parts of the page should be shown.</p>
<p>Agent offers more functionality than just detecting if a user agent is a mobile or desktop device, and you may find this useful as a starting point for developing middleware for detecting bots, or showing different content to users based on their device type or operating system. If you just need to detect if a user is a mobile or desktop client, this middleware should be sufficient.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Check your code base is PHP 7 ready with PHP Compatibility]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/02/25/check-your-code-base-is-php-7-ready-with-php-compatibility/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/02/25/check-your-code-base-is-php-7-ready-with-php-compatibility/</guid>
            <pubDate>Sun, 25 Feb 2018 17:22:34 GMT</pubDate>
            <description><![CDATA[<p>I’ve recently started a new job and as part of that I’m working on a rather substantial legacy code base. In fact, it was so legacy that it was still in Subversion - needless to say the very first thing I did was migrate it to Git. One of the jobs on our radar for this code base is to migrate it to from PHP 5.4 to 5.6, and subsequently to PHP 7. I’ve been using it locally in 5.6 without issue so far, but I’ve also been looking around for an automated tool to help catch potential problems.</p>
<p>I recently discovered <a href="https://github.com/wimg/PHPCompatibility">PHP Compatibility</a> which is a set of sniffs for PHP CodeSniffer that can be used to detect code that will be problematic in a particular PHP version. As I use CodeSniffer extensively already, it’s a good fit for my existing toolset.</p>
<p>To install it, add the following dependencies to your <code>composer.json</code>:</p>
<pre><code class="lang-json">    &quot;require-dev&quot;: {
        &quot;dealerdirect/phpcodesniffer-composer-installer&quot;: &quot;^0.4.3&quot;,
        &quot;squizlabs/php_codesniffer&quot;: &quot;^2.5&quot;,
        &quot;wimg/php-compatibility&quot;: &quot;^8.1&quot;
    },
</code></pre>
<p>Then update your <code>phpcs.xml</code> to look something like this:</p>
<pre><code class="lang-xml">&lt;ruleset name=&quot;PHP_CodeSniffer&quot;&gt;
   &lt;description&gt;The coding standard for my app.&lt;/description&gt;
   &lt;file&gt;./&lt;/file&gt;
   &lt;arg value=&quot;np&quot;/&gt;
   &lt;rule ref=&quot;PSR2&quot;/&gt;
   &lt;rule ref=&quot;PHPCompatibility&quot;/&gt;
   &lt;config name=&quot;testVersion&quot; value=&quot;7.2-&quot;/&gt;
&lt;/ruleset&gt;
</code></pre>
<p>As you can see, it’s possible to use it alongside existing coding standards such as PSR2. Note the <code>testVersion</code> config key - the value specified is the PHP version we’re testing against. Here we’re specifying PHP 7.2.</p>
<p>Obviously, the very best way to guard against breakages in newer versions of PHP is to have a comprehensive test suite, but legacy code bases by definition tend to have little or no tests. By using PHP Compatibility, you should at least be able to catch syntax problems without having to audit the code base manually.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Unit testing your Laravel controllers]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/02/25/unit-testing-your-laravel-controllers/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/02/25/unit-testing-your-laravel-controllers/</guid>
            <pubDate>Sun, 25 Feb 2018 15:50:44 GMT</pubDate>
            <description><![CDATA[<p>In <a href="/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/">my previous post</a> I mentioned some strategies for refactoring Laravel controllers to move unnecessary functionality elsewhere. However, I didn’t cover testing them. In this post I will demonstrate the methodology I use for testing Laravel controllers.</p>
<p>Say we have the following method in a controller:</p>
<pre><code class="lang-php">public function store(Request $request)
{    
        $document = new Document($request-&gt;only([
            &#39;title&#39;, 
            &#39;text&#39;, 
        ]));
        $document-&gt;save();

        event(new DocumentCreated($document));

        return redirect()-&gt;route(&#39;/&#39;);
}
</code></pre>
<p>This controller method does three things:</p>
<ul>
<li>Return a response</li>
<li>Create a model instance</li>
<li>Fire an event</li>
</ul>
<p>Our tests therefore need to pass it all its external dependencies and check it carries out the required actions.</p>
<p>First we fake the event facade:</p>
<pre><code class="lang-php">    Event::fake();
</code></pre>
<p>Next, we create an instance of <code>Illuminate\Http\Request</code> to represent the HTTP request passed to the controller:</p>
<pre><code class="lang-php">    $request = Request::create(&#39;/store&#39;, &#39;POST&#39;,[
        &#39;title&#39;     =&gt;     &#39;foo&#39;,
        &#39;text&#39;     =&gt;     &#39;bar&#39;,
    ]);
</code></pre>
<p>If you’re using a custom form request class, you should instantiate that in exactly the same way.</p>
<p>Then, instantiate the controller, and call the method, passing it the request object:</p>
<pre><code class="lang-php">    $controller = new MyController();
    $response = $controller-&gt;store($request);
</code></pre>
<p>You can then test the response from the controller. You can test the status code like this:</p>
<pre><code class="lang-php">    $this-&gt;assertEquals(302, $response-&gt;getStatusCode());
</code></pre>
<p>You may also need to check the content of the response matches what you expect to see, by retrieving <code>$response-&gt;getBody()-&gt;getContent()</code>.</p>
<p>Next, retrieve the newly created model instance, and verify it exists:</p>
<pre><code class="lang-php">    $document = Document::where(&#39;title&#39;, &#39;foo&#39;)-&gt;first();
    $this-&gt;assertNotNull($document);
</code></pre>
<p>You can also use <code>assertEquals()</code> to check the attributes on the model if appropriate. Finally, you check the event was fired:</p>
<pre><code class="lang-php">    Event::assertDispatched(DocumentCreated::class, function ($event) use ($document) { 
        return $event-&gt;document-&gt;id === $document-&gt;id; 
    });
</code></pre>
<p>This test should not concern itself with any functionality triggered by the event, only that the event gets triggered. The event should have separate unit tests in which the event is triggered, and then the test verifies it carried out the required actions.</p>
<p>Technically, these don’t quite qualify as being unit tests because they hit the database, but they should cover the controller adequately. To make them true unit tests, you’d need to implement the repository pattern for the database queries rather than using Eloquent directly, and mock the repository, so you can assert that the mocked repository receive the right data and have it return the expected response.</p>
<p>Here is how you might do that with Mockery:</p>
<pre><code class="lang-php">$mock = Mockery::mock(&#39;App\Contracts\Repositories\Document&#39;);
$mock-&gt;shouldReceive(&#39;create&#39;)-&gt;with([
    &#39;title&#39;    =&gt;        &#39;foo&#39;,
    &#39;text&#39;    =&gt;        &#39;bar&#39;,
])-&gt;once()-&gt;andReturn(true);
$controller = new MyController($mock);
</code></pre>
<p>As long as your controllers are kept as small as possible, it’s generally not too hard to test them. Unfortunately, fat controllers become almost impossible to test, which is another good reason to avoid them.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Put your Laravel controllers on a diet]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/</guid>
            <pubDate>Sun, 18 Feb 2018 18:10:10 GMT</pubDate>
            <description><![CDATA[<p>MVC frameworks are a tremendously useful tool for modern web development. They offer easy ways to carry out common tasks, and enforce a certain amount of structure on a project.</p>
<p>However, that doesn’t mean using them makes you immune to bad practices, and it’s quite easy to wind up falling into certain anti-patterns. Probably the most common is the Fat Controller.</p>
<h2 id="what-is-a-fat-controller-">What is a fat controller?</h2>
<p>When I first started out doing professional web development, CodeIgniter 2 was the first MVC framework I used. While I hadn’t used it before, I was familiar with the general concept of MVC. However, I didn’t appreciate that when referring to the model layer as a place for business logic, that wasn’t necessarily the same thing as the database models.</p>
<p>As such, my controllers became a dumping ground for anything that didn’t fit into the models. If it didn’t interact with the database, I put it in the controller. They quickly became bloated, with many methods running to hundreds of lines of code. The code base became hard to understand, and when I was under the gun on projects I found myself copying and pasting functionality between controllers, making the situation even worse. Not having an experienced senior developer on hand to offer criticism and advice, it was a long time before I realised that this was a problem or how to avoid it.</p>
<h2 id="why-are-fat-controllers-bad-">Why are fat controllers bad?</h2>
<p>Controllers are meant to be simple glue code that receives requests and returns responses. Anything else should be handed off to the model layer. As noted above, however, that’s not the same as putting it in the models. Your model layer can consist of many different classes, not just your Eloquent models, and you should not fall into the trap of thinking your application should consist of little more than models, views and controllers.</p>
<p>Placing business logic in controllers can be bad for many reasons:</p>
<ul>
<li>Code in controllers can be difficult to write automated tests for</li>
<li>Any logic in a controller method may need to be repeated elsewhere if the same functionality is needed for a different route, unless it’s in a private or protected method that is called from elsewhere, in which case it’s very hard to test in isolation</li>
<li>Placing it in the controller makes it difficult to pull out and re-use on a different project</li>
<li>Making your controller methods too large makes them complex and hard to follow</li>
</ul>
<p>As a general rule of thumb, I find that 10 lines of code for any one method for a controller is where it starts getting a bit much. That said, it’s not a hard and fast rule, and for very small projects it may not be worthwhile. But if a project is large and needs to be maintained for any reasonable period of time, you should take the trouble to ensure your controllers are as skinny as is practical.</p>
<p>Nowadays Laravel is my go-to framework and I’ve put together a number of strategies for avoiding the fat controller anti-pattern. Here’s some examples of how I would move various parts of the application out of my controllers.</p>
<h2 id="validation">Validation</h2>
<p>Laravel has a nice, easy way of getting validation out of the controllers. Just create a custom <a href="https://laravel.com/docs/5.6/validation#form-request-validation">form request</a> for your input data, as in this example:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CreateRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            &#39;email&#39; =&gt; &#39;required|email&#39;
        ];
    }
}
</code></pre>
<p>Then type-hint the form request in the controller method, instead of <code>Illuminate\Http\Request</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Requests\CreateRequest;

class HomeController extends Controller
{
    public function store(CreateRequest $request)
    {
        // Process request here..
    }
}
</code></pre>
<h2 id="database-access-and-caching">Database access and caching</h2>
<p>For non-trivial applications I normally use <a href="/blog/2017/03/01/decorating-laravel-repositories/">decorated repositories</a> to handle caching and database access in one place. That way my caching and database layers are abstracted out into separate classes, and caching is nearly always handled seamlessly without having to do much work.</p>
<h2 id="complex-object-creation-logic">Complex object creation logic</h2>
<p>If I have a form or API endpoint that needs to:</p>
<ul>
<li>Create more than one object</li>
<li>Transform the incoming data in some way</li>
<li>Or is non-trivial in any other way</li>
</ul>
<p>I will typically pull it out into a separate persister class. First, you should create an interface for this persister class:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts\Persisters;

use Illuminate\Database\Eloquent\Model;

interface Foo
{
    /**
     * Create a new Model
     *
     * @param array $data
     * @return Model
     */
    public function create(array $data);

    /**
     * Update the given Model
     *
     * @param array $data
     * @param Model $model
     * @return Model
     */
    public function update(array $data, Model $model);
}
</code></pre>
<p>Then create the persister class itself:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Persisters;

use Illuminate\Database\Eloquent\Model;
use App\Contracts\Repositories\Foo as Repository;
use App\Contracts\Persisters\Foo as FooContract;
use Illuminate\Database\DatabaseManager;
use Carbon\Carbon;

class Foo implements FooContract
{
    protected $repository;

    protected $db;

    public function __construct(DatabaseManager $db, Repository $repository)
    {
        $this-&gt;db = $db;
        $this-&gt;repository = $repository;
    }

    /**
     * Create a new Model
     *
     * @param array $data
     * @return Model
     */
    public function create(array $data)
    {
        $this-&gt;db-&gt;beginTransaction();
        $model = $this-&gt;repository-&gt;create([
             &#39;date&#39; =&gt; Carbon::parse($data[&#39;date&#39;])-&gt;toDayDateTimeString(),
        ]);
        $this-&gt;db-&gt;commit();
        return $model;
    }

    /**
     * Update the given Model
     *
     * @param array $data
     * @param Model $model
     * @return Model
     */
    public function update(array $data, Model $model)
    {
        $this-&gt;db-&gt;beginTransaction();
        $updatedmodel = $this-&gt;repository-&gt;update([
             &#39;date&#39; =&gt; Carbon::parse($data[&#39;date&#39;])-&gt;toDayDateTimeString(),
             $model
        ]);
        $this-&gt;db-&gt;commit();
        return $updatedmodel;
    }
}
</code></pre>
<p>Then you can set up the persister in a service provider so that type-hinting the interface returns the persister:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
       $this-&gt;app-&gt;bind(
            &#39;App\Contracts\Persisters\Foo&#39;,
            &#39;App\Persisters\Foo&#39;,
       });
    }
}
</code></pre>
<p>This approach means that complex logic, such as creating multiple related objects, can be handled in a consistent way, even if it needs to be called from multiple places.</p>
<h2 id="triggering-actions-as-a-result-of-something">Triggering actions as a result of something</h2>
<p><a href="https://laravel.com/docs/5.6/events">Events</a> are tailor-made for this use case, and Laravel documents them very well, so I won’t repeat it here. Suffice to say, if something needs to happen, but the response sent by the application doesn’t necessarily depend on it returning something immediately, then it’s probably worth considering making it an event. If it’s going to be called from multiple places, it’s even more worthwhile.</p>
<p>For instance, if you have a contact form, it’s worth taking the time to create an event for when a new contact is received, and handle proessing the contact within the listener for that event. Also, doing so means you can queue that event and have it handled outside the context of the application, so that it responds to the user more quickly. If you’re sending an acknowledgement email for a new user registration, you don’t need to wait for that email to be sent before you return the response, so queueing it can improve response times.</p>
<h2 id="interacting-with-third-party-services">Interacting with third-party services</h2>
<p>If you have some code that needs to interact with a third-party service or API, it can get quite complex, especially if you need to process the content in some way. It therefore makes sense to pull that functionality out into a separate class.</p>
<p>For instance, say you have some code in your controller that uses an HTTP client to fetch some data from a third-party API and display it in the view:</p>
<pre><code class="lang-php">public function index(Request $request)
{
   $data = $this-&gt;client-&gt;get(&#39;http://api.com/api/items&#39;);
   $items = [];
   foreach ($data as $k =&gt; $v) {
         $item = [
           &#39;name&#39; =&gt; $v[&#39;name&#39;],
              &#39;description&#39; =&gt; $v[&#39;data&#39;][&#39;description&#39;],
              &#39;tags&#39; =&gt; $v[&#39;data&#39;][&#39;metadata&#39;][&#39;tags&#39;]
         ];
         $items[] = $item;
   }
   return view(&#39;template&#39;, [
       &#39;items&#39; =&gt; $items
   ]);
}
</code></pre>
<p>This is a very small example (and a lot simpler than most real-world instances of this issue), but it illustrates the principle. Not only does this code bloat the controller, it might also be used elsewhere in the application, and we don’t want to copy and paste it elsewhere - therefore it makes sense to extract it to a service class.</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services

use GuzzleHttp\ClientInterface as GuzzleClient;

class Api
{
   protected $client;

   public function __construct(GuzzleClient $client)
   {
      $this-&gt;client = $client;
   }

    public function fetch()
    {
      $data = $this-&gt;client-&gt;get(&#39;http://api.com/api/items&#39;);
      $items = [];
      foreach ($data as $k =&gt; $v) {
         $item = [
            &#39;name&#39; =&gt; $v[&#39;name&#39;],
            &#39;description&#39; =&gt; $v[&#39;data&#39;][&#39;description&#39;],
            &#39;tags&#39; =&gt; $v[&#39;data&#39;][&#39;metadata&#39;][&#39;tags&#39;]
         ];
         $items[] = $item;
      }
      return $items;
    }
}
</code></pre>
<p>Our controller can then type-hint the service and refactor that functionality out of the method:</p>
<pre><code class="lang-php">public function __construct(App\Services\Api $api)
{
    $this-&gt;api = $api;
}

public function index(Request $request)
{
   $items = $this-&gt;api-&gt;fetch();
   return view(&#39;template&#39;, [
       &#39;items&#39; =&gt; $items
   ]);
}
</code></pre>
<h2 id="including-common-variables-in-the-view">Including common variables in the view</h2>
<p>If data is needed in more than one view (eg show the user’s name on every page when logged in), consider using <a href="https://laravel.com/docs/5.6/views#view-composers">view composers</a> to retrieve this data rather than fetching them in the controller. That way you’re not having to repeat that logic in more than one place.</p>
<h2 id="formatting-content-for-display">Formatting content for display</h2>
<p>Logically this belongs in the view layer, so you should <a href="/blog/2018/01/09/creating-laravel-helpers/">write a helper</a> to handle things like formatting dates. For more complex stuff, such as formatting HTML, you should be doing this in Blade (or another templating system, if you’re using one) - for instance, when generating an HTML table, you should consider <a href="https://laravel.com/docs/5.6/blade#rendering-views-for-collections">using a view partial</a> to loop through them. For particularly tricky functionality, you have the option of <a href="https://laravel.com/docs/5.6/blade#extending-blade">writing a custom Blade directive</a>.</p>
<p>The same applies for rendering other content - for rendering JSON you should consider using <a href="https://laravel.com/docs/5.6/eloquent-resources">API resources</a> or <a href="https://fractal.thephpleague.com/">Fractal</a> to get any non-trivial logic for your API responses out of the controller. Blade templates can also work for non-HTML content such as XML.</p>
<h2 id="anything-else-">Anything else…</h2>
<p>These examples are largely to get you started, and there will be occasions where something doesn’t fall into any of the above categories. However, the same principle applies. Your controllers should stick to just receiving requests and sending responses, and anything else should normally be deferred to other classes.</p>
<p>Fat controllers make developer’s lives very difficult, and if you want your code base to be easily maintainable, you should be willing to refactor them ruthlessly. Any functionality you can pull out of the controller becomes easier to reuse and test, and as long as you name your classes and methods sensibly, they’re easier to understand.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[How I deploy Laravel apps]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/29/how-i-deploy-laravel-apps/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/29/how-i-deploy-laravel-apps/</guid>
            <pubDate>Mon, 29 Jan 2018 22:00:35 GMT</pubDate>
            <description><![CDATA[<p>A while back I provided details of the web server setup I used for Django applications. Nowadays I tend to use Laravel most of the time, so I thought I’d share an example of the sort of setup I use to deploy that.</p>
<h2 id="server-os">Server OS</h2>
<p>As before I generally prefer Debian Stable where possible. If that’s not possible for any reason then the current Ubuntu LTS is an acceptable substitute.</p>
<h2 id="web-server">Web server</h2>
<p>My usual web server these days is Nginx with PHP 7 or better via FPM. I generally use HTTP2 where possible, with SSL via Let’s Encrypt.</p>
<p>Here’s my typical Nginx config:</p>
<pre><code class="lang-nginx">fastcgi_cache_path /etc/nginx/cache levels=1:2 keys_zone=my-app:100m inactive=60m;
fastcgi_cache_key &quot;$scheme$request_method$host$request_uri&quot;;
add_header Content-Security-Policy &quot;default-src &#39;self&#39;; script-src &#39;self&#39;; img-src &#39;self&#39; https://placehold.it; style-src &#39;self&#39; https://fonts.googleapis.com ; font-src &#39;self&#39; https://themes.googleusercontent.com; frame-src &#39;none&#39;; object-src &#39;none&#39;&quot;;
server_tokens off;

server {
    listen 80;
    listen [::]:80;
    server_name my-app.domain;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    include snippets/ssl-my-app.domain.conf;
    include snippets/ssl-params.conf;
    client_max_body_size 50M;
    fastcgi_param HTTP_PROXY &quot;&quot;;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    root /var/www/my-app.domain/current/public;
    index index.php index.html index.htm;

    server_name my-app.domain;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.0-fpm-my-app.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_cache my-app;
        fastcgi_cache_valid 200 60m;
    }

    location ~ /.well-known {
        allow all;
    }

    location ~* \.(?:manifest|appcache|html?|xml|json)$ {
        expires -1;
        gzip on;
        gzip_vary on;
        gzip_types application/json text/xml application/xml;
    }

    location ~* \.(?:rss|atom)$ {
        expires 1h;
        add_header Cache-Control &quot;public&quot;;
        gzip on;
        gzip_vary on;
        gzip_types application/xml+rss;
    }

    location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
        expires 1M;
        access_log off;
        add_header Cache-Control &quot;public&quot;;
    }

    location ~* \.(?:css|js)$ {
        expires 1y;
        access_log off;
        add_header Cache-Control &quot;public&quot;;
        gzip on;
        gzip_vary on;
        gzip_types text/css application/javascript text/javascript;
    }
}
</code></pre>
<p>The times for FastCGI caching tend to vary in practice - sometimes it’s not appropriate to use it all, while for others it can be cached for some time.</p>
<p>It’s generally fairly safe to cache CSS and JS for a long time with a Laravel app if you’re using Mix to version those assets, so I feel comfortable caching them for a year. Images are a bit dicier, but still don’t change often so a month seems good enough.</p>
<p>I’ll typically give each application its own pool, which means copying the file at <code>/etc/php/7.0/fpm/pool.d/www.conf</code> to another file in the same directory, amending the pool name and path to set a new location for the socket, and then restarting Nginx and PHP-FPM. Here are the fields that should be changed:</p>
<pre><code class="lang-ini">; Start a new pool named &#39;www&#39;.
; the variable $pool can be used in any directive and will be replaced by the
; pool name (&#39;www&#39; here)
[my-app.domain]
...
listen = /var/run/php/php7.0-fpm-my-app.sock
</code></pre>
<h2 id="database">Database</h2>
<p>I’m a fan of PostgreSQL - it’s stricter than MySQL/MariaDB, and has some very useful additional field types, so where possible I prefer to use it over MySQL or MariaDB.</p>
<h2 id="cache-and-session-backend">Cache and session backend</h2>
<p>Redis is my usual choice here - I make heavy use of cache tags so I need a backend for the cache that supports them, and Memcached doesn’t seem to have as much inertia as Redis these days. Neither needs much in the way of configuration, but you can get a slight speed boost by using phpiredis.</p>
<h2 id="queue">Queue</h2>
<p>I sometimes use Redis for this too, but it can be problematic if you’re using Redis as the queue and broadcast backend, so these days I’m more likely to use Beanstalk and keep Redis for other stuff. I use Supervisor for running the queue worker, and this is an example of the sort of configuration I would use:</p>
<pre><code class="lang-ini">[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/artisan queue:work --sleep=3 --tries=3
autostart=true
autorestart=true
user=www-data
numprocs=8
redirect_stderr=true
stdout_logfile=/var/log/worker.log
</code></pre>
<p>This is fairly standard for Laravel applications.</p>
<h2 id="scheduler">Scheduler</h2>
<p>I often make use of the Laravel scheduled tasks system. Here’s the typical cron job that would be used for that:</p>
<pre><code class="lang-cron">* * * * * php /var/www/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1
</code></pre>
<p>Again, this is standard for Laravel applications. It runs the scheduler every minute, and the scheduler then determines if it needs to do something.</p>
<h2 id="provisioning">Provisioning</h2>
<p>To set all this up, I’ll generally use Ansible. In addition to this, I’ll generally also set up fail2ban to block various attacks via both HTTP and SSH.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Deploying your Laravel application with Deployer]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/22/deploying-your-laravel-application-with-deployer/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/22/deploying-your-laravel-application-with-deployer/</guid>
            <pubDate>Mon, 22 Jan 2018 12:00:14 GMT</pubDate>
            <description><![CDATA[<p>Deployment processes have a nasty tendency to be a mish-mash of cobbled-together scripts or utilities in many web shops, with little or no consistency in practice between them. As a result, it’s all too easy for even the most experienced developer to mess up a deployment.</p>
<p>I personally have used all kinds of bodged-together solutions. For a while I used Envoy scripts to deploy my Laravel apps, but then there was an issue with the SSH library in PHP 7 that made it impractical to use it. Then I adopted Fabric, which I’d used before for deploying Django apps and will do fine for deploying PHP apps too, but it wasn’t much more sophisticated than using shell scripts for deployment purposes. There are third-party services like Deploybot, but these are normally quite expensive for what they are.</p>
<p>A while back I heard of <a href="https://deployer.org/">Deployer</a>, but I didn’t have the opportunity to try it until recently on a personal project as I was working somewhere that had its own in-house deployment process. It’s a PHP-specific deployment tool with recipes for deploying applications built with various frameworks and CMS’s, including Laravel, Symfony, CodeIgniter and Drupal.</p>
<h2 id="installing-deployer">Installing Deployer</h2>
<p>Deployer is installed as a <code>.phar</code> file, much like you would with Composer:</p>
<pre><code class="lang-bash">$ curl -LO https://deployer.org/deployer.phar
$ mv deployer.phar /usr/local/bin/dep
$ chmod +x /usr/local/bin/dep
</code></pre>
<p>With that done, you should be able to run the following command in your project’s directory to create a Deployer script:</p>
<pre><code class="lang-bash">$ dep init
</code></pre>
<p>In response, you should see a list of project types:</p>
<pre><code class="lang-bash">  Welcome to the Deployer config generator  



 This utility will walk you through creating a deploy.php file.
 It only covers the most common items, and tries to guess sensible defaults.

 Press ^C at any time to quit.

 Please select your project type [Common]:
  [0] Common
  [1] Laravel
  [2] Symfony
  [3] Yii
  [4] Yii2 Basic App
  [5] Yii2 Advanced App
  [6] Zend Framework
  [7] CakePHP
  [8] CodeIgniter
  [9] Drupal
 &gt;
</code></pre>
<p>Here I chose Laravel as I was deploying a Laravel project. I was then prompted for the repository URL - this will be filled in with the origin remote if the current folder is already a Git repository:</p>
<pre><code class="lang-bash">Repository [git@gitlab.com:Group/Project.git]:
 &gt; 
</code></pre>
<p>You’ll also see a message about contributing anonymous usage data. After answering this, the file <code>deploy.php</code> will be generated:</p>
<pre><code class="lang-php">&lt;?php
namespace Deployer;

require &#39;recipe/laravel.php&#39;;

// Configuration

set(&#39;repository&#39;, &#39;git@gitlab.com:Group/Project.git&#39;);
set(&#39;git_tty&#39;, true); // [Optional] Allocate tty for git on first deployment
add(&#39;shared_files&#39;, []);
add(&#39;shared_dirs&#39;, []);
add(&#39;writable_dirs&#39;, []);


// Hosts

host(&#39;project.com&#39;)
    -&gt;stage(&#39;production&#39;)
    -&gt;set(&#39;deploy_path&#39;, &#39;/var/www/project.com&#39;);

host(&#39;beta.project.com&#39;)
    -&gt;stage(&#39;beta&#39;)
    -&gt;set(&#39;deploy_path&#39;, &#39;/var/www/project.com&#39;);  


// Tasks

desc(&#39;Restart PHP-FPM service&#39;);
task(&#39;php-fpm:restart&#39;, function () {
    // The user must have rights for restart service
    // /etc/sudoers: username ALL=NOPASSWD:/bin/systemctl restart php-fpm.service
    run(&#39;sudo systemctl restart php-fpm.service&#39;);
});
after(&#39;deploy:symlink&#39;, &#39;php-fpm:restart&#39;);

// [Optional] if deploy fails automatically unlock.
after(&#39;deploy:failed&#39;, &#39;deploy:unlock&#39;);

// Migrate database before symlink new release.

before(&#39;deploy:symlink&#39;, &#39;artisan:migrate&#39;);
</code></pre>
<p>By default it has two hosts, <code>beta</code> and <code>production</code>, and you can refer to them by these names. You can also add or remove hosts, and amend the existing ones. Note the deploy path as well - this sets the place where the application gets deployed to.</p>
<p>Note that it’s set up to expect the server to be using PHP-FPM and Nginx by default, so if you’re using Apache you may need to amend the command to restart the server. Also, note that if like me you’re using PHP 7 on a distro like Debian that also has PHP 5 around, you’ll probably need to change the references to <code>php-fpm</code> as follows:</p>
<pre><code class="lang-php">desc(&#39;Restart PHP-FPM service&#39;);
task(&#39;php-fpm:restart&#39;, function () {
    // The user must have rights for restart service
    // /etc/sudoers: username ALL=NOPASSWD:/bin/systemctl restart php-fpm.service
    run(&#39;sudo systemctl restart php7.0-fpm.service&#39;);
});
after(&#39;deploy:symlink&#39;, &#39;php-fpm:restart&#39;);
</code></pre>
<p>You will also need to make sure the <code>acl</code> package is installed - on Debian and Ubuntu you can install it as follows:</p>
<pre><code class="lang-bash">$ sudo apt-get install acl
</code></pre>
<p>Now, the recipe for deploying a Laravel app will include the following:</p>
<ul>
<li>Pulling from the Git remote</li>
<li>Updating any Composer dependencies to match <code>composer.json</code></li>
<li>Running the migrations</li>
<li>Optimizing the application</li>
</ul>
<p>In addition, one really great feature Deployer offers is rollbacks. Rather than checking out your application directly into the project root you specify, it numbers each release and deploys it in a separate folder, before symlinking that folder to the project root as <code>current</code>. That way, if a release cannot be deployed successfully, rather than leaving your application in an unfinished state, Deployer will symlink the previous version so that you still have a working version of your application.</p>
<p>If you have configured Deployer for that project, you can deploy using the following command where <code>production</code> is the name of the host you’re deploying to:</p>
<pre><code class="lang-bash">$ dep deploy production
</code></pre>
<p>The output will look something like this:</p>
<pre><code class="lang-bash">✔ Executing task deploy:prepare
✔ Executing task deploy:lock
✔ Executing task deploy:release
➤ Executing task deploy:update_code
Counting objects: 761, done.
Compressing objects: 100% (313/313), done.
Writing objects: 100% (761/761), done.
Total 761 (delta 384), reused 757 (delta 380)
Connection to linklater.shellshocked.info closed.
✔ Ok
✔ Executing task deploy:shared
✔ Executing task deploy:vendors
✔ Executing task deploy:writable
✔ Executing task artisan:storage:link
✔ Executing task artisan:view:clear
✔ Executing task artisan:cache:clear
✔ Executing task artisan:config:cache
✔ Executing task artisan:optimize
✔ Executing task artisan:migrate
✔ Executing task deploy:symlink
✔ Executing task php-fpm:restart
✔ Executing task deploy:unlock
✔ Executing task cleanup
✔ Executing task success
Successfully deployed!
</code></pre>
<p>As you can see, we first of all lock the application and pull the latest version from the Git remote. Next we copy the files shared between releases (eg the <code>.env</code> file, the <code>storage/</code> directory etc), update the dependencies, and make sure the permissions are correct. Next we link the storage, clear all the cached content, optimize our app, and migrate the database, before we set up the symlink. Finally we restart the web server and unlock the application.</p>
<p>In the event you discover a problem after deploy and need to rollback manually, you can do so with the following command:</p>
<pre><code class="lang-bash">$ dep rollback production
</code></pre>
<p>That makes it easy to ensure that in the event of something going wrong, you can quickly switch back to an earlier version with zero downtime.</p>
<p>Deployer has made deployments a lot less painful for me than any other solution I’ve tried. The support for rollbacks means that if something goes wrong it’s trivial to switch back to an earlier revision.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating a caching user provider for Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/</guid>
            <pubDate>Fri, 12 Jan 2018 13:16:51 GMT</pubDate>
            <description><![CDATA[<p>If you have a Laravel application that requires users to log in and you use Clockwork or Laravel DebugBar to examine the queries that take place, you’ll probably notice a query that fetches the user model occurs quite a lot. This is because the user’s ID gets stored in the session, and is then used to retrieve the model.</p>
<p>This query is a good candidate for caching because not only is that query being made often, but it’s also not something that changes all that often. If you’re careful, it’s quite easy to set your application up to cache the user without having to worry about invalidating the cache.</p>
<p>Laravel allows you to define your own user providers in order to fetch the user’s details. These must implement <code>Illuminate\Contracts\Auth\UserProvider</code> and must return a user model from the identifier provided. Out of the box it comes with two implementations, <code>Illuminate\Auth\EloquentUserProvider</code> and <code>Illuminate\Auth\DatabaseUserProvider</code>, with the former being the default. Our caching user provider can extend the Eloquent one as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Auth;

use Illuminate\Auth\EloquentUserProvider;
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Contracts\Hashing\Hasher as HasherContract;

class CachingUserProvider extends EloquentUserProvider
{
    /**
     * The cache instance.
     *
     * @var Repository
     */
    protected $cache;

    /**
     * Create a new database user provider.
     *
     * @param  \Illuminate\Contracts\Hashing\Hasher  $hasher
     * @param  string  $model
     * @param  Repository  $cache
     * @return void
     */
    public function __construct(HasherContract $hasher, $model, Repository $cache)
    {
        $this-&gt;model = $model;
        $this-&gt;hasher = $hasher;
        $this-&gt;cache = $cache;
    }

    /**
     * Retrieve a user by their unique identifier.
     *
     * @param  mixed  $identifier
     * @return \Illuminate\Contracts\Auth\Authenticatable|null
     */
    public function retrieveById($identifier)
    {
        return $this-&gt;cache-&gt;tags($this-&gt;getModel())-&gt;remember(&#39;user_by_id_&#39;.$identifier, 60, function () use ($identifier) {
            return parent::retrieveById($identifier);
        });
    }
}
</code></pre>
<p>Note that we override the constructor to accept a cache instance as well as the other arguments. We also override the <code>retrieveById()</code> method to wrap a call to the parent’s implementation inside a callback that caches the response. I usually tag anything I cache with the model name, but if you need to use a cache backend that doesn’t support tagging this may not be an option. Our cache key also includes the identifier so that it’s unique to that user.</p>
<p>We then need to add our user provider to the auth service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Gate;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use App\Auth\CachingUserProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        Auth::provider(&#39;caching&#39;, function ($app, array $config) {
            return new CachingUserProvider(
                $app-&gt;make(&#39;Illuminate\Contracts\Hashing\Hasher&#39;),
                $config[&#39;model&#39;],
                $app-&gt;make(&#39;Illuminate\Contracts\Cache\Repository&#39;)
            );
        });
    }
}
</code></pre>
<p>Note here that we call this provider <code>caching</code>, and we pass it the hasher, the model name, and an instance of the cache. Then, we need to update <code>config/auth.php</code> to use this provider:</p>
<pre><code class="lang-php">    &#39;providers&#39; =&gt; [
        &#39;users&#39; =&gt; [
            &#39;driver&#39; =&gt; &#39;caching&#39;,
            &#39;model&#39; =&gt; App\Eloquent\Models\User::class,
        ],
    ],
</code></pre>
<p>The only issue now is that our user models will continue to be cached, even when they are updated. To be able to flush the cache, we can create a model event that fires whenever the user model is updated:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Eloquent\Models;

use Illuminate\Notifications\Notifiable;
use Illuminate\Foundation\Auth\User as Authenticatable;
use App\Events\UserAmended;

class User extends Authenticatable
{
    use Notifiable;

    protected $dispatchesEvents = [
        &#39;saved&#39; =&gt; UserAmended::class,
        &#39;deleted&#39; =&gt; UserAmended::class,
        &#39;restored&#39; =&gt; UserAmended::class,
    ];
}
</code></pre>
<p>This will call the <code>UserAmended</code> event when a user model is created, updated, deleted or restored. Then we can define that event:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use App\Eloquent\Models\User;

class UserAmended
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct(User $model)
    {
        $this-&gt;model = $model;
    }
}
</code></pre>
<p>Note our event contains an instance of the user model. Then we set up a listener to do the work of clearing the cache:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Listeners;

use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use App\Events\UserAmended;
use Illuminate\Contracts\Cache\Repository;

class ClearUserId
{
    /**
     * Create the event listener.
     *
     * @return void
     */
    public function __construct(Repository $cache)
    {
        $this-&gt;cache = $cache;
    }

    /**
     * Handle the event.
     *
     * @param  object  $event
     * @return void
     */
    public function handle(UserAmended $event)
    {
        $this-&gt;cache-&gt;tags(get_class($event-&gt;model))-&gt;forget(&#39;user_by_id_&#39;.$event-&gt;model-&gt;id);
    }
}
</code></pre>
<p>Here, we get the user model’s class again, and clear the cache entry for that user model.</p>
<p>Finally, we hook up the event and listener in the event service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Event;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;

class EventServiceProvider extends ServiceProvider
{
    /**
     * The event listener mappings for the application.
     *
     * @var array
     */
    protected $listen = [
        &#39;App\Events\UserAmended&#39; =&gt; [
            &#39;App\Listeners\ClearUserId&#39;,
        ],
    ];

    /**
     * Register any events for your application.
     *
     * @return void
     */
    public function boot()
    {
        parent::boot();

        //
    }
}
</code></pre>
<p>With that done, our user should be cached after the first load, and flushed when the model is amended.</p>
<h2 id="handling-eager-loaded-data">Handling eager-loaded data</h2>
<p>It may be that you’re pulling in additional data from the user model in your application, such as roles, permissions, or a separate profile model. Under those circumstances it makes sense to treat that data in the same way by eager-loading it along with your user model.</p>
<pre><code class="lang-php">&lt;?php

namespace App\Auth;

use Illuminate\Auth\EloquentUserProvider;
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Contracts\Hashing\Hasher as HasherContract;

class CachingUserProvider extends EloquentUserProvider
{
    /**
     * The cache instance.
     *
     * @var Repository
     */
    protected $cache;

    /**
     * Create a new database user provider.
     *
     * @param  \Illuminate\Contracts\Hashing\Hasher  $hasher
     * @param  string  $model
     * @param  Repository  $cache
     * @return void
     */
    public function __construct(HasherContract $hasher, $model, Repository $cache)
    {
        $this-&gt;model = $model;
        $this-&gt;hasher = $hasher;
        $this-&gt;cache = $cache;
    }

    /**
     * Retrieve a user by their unique identifier.
     *
     * @param  mixed  $identifier
     * @return \Illuminate\Contracts\Auth\Authenticatable|null
     */
    public function retrieveById($identifier)
    {
        return $this-&gt;cache-&gt;tags($this-&gt;getModel())-&gt;remember(&#39;user_by_id_&#39;.$identifier, 60, function () use ($identifier) {
          $model = $this-&gt;createModel();
          return $model-&gt;newQuery()
            -&gt;with(&#39;roles&#39;, &#39;permissions&#39;, &#39;profile&#39;)
            -&gt;where($model-&gt;getAuthIdentifierName(), $identifier)
            -&gt;first();
        });
    }
}
</code></pre>
<p>Because we need to amend the query itself, we can’t just defer to the parent implementation like we did above and must instead copy it over and amend it to eager-load the data.</p>
<p>You’ll also need to set up model events to clear the cache whenever one of the related fields is updated, but it should be fairly straightforward to do so.</p>
<h2 id="summary">Summary</h2>
<p>Fetching a user model (and possibly some relations) on every page load while logged in can be a bit much, and it makes sense to cache as much as you can without risking serving stale data. Using this technique you can potentially cache a lot of repetitive, unnecessary queries and make your application faster.</p>
<p>This technique will also work in cases where you’re using other methods of maintaining user state, such as JWT, as long as you’re making use of a guard for authentication purposes, since all of these guards will still be using the same user provider. In fact, I first used this technique on a REST API that used JWT for authentication, and it’s worked well in that case.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Easy repositories and decorators with Laravel Repositories]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/10/easy-repositories-and-decorators-with-laravel-repositories/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/10/easy-repositories-and-decorators-with-laravel-repositories/</guid>
            <pubDate>Wed, 10 Jan 2018 12:22:44 GMT</pubDate>
            <description><![CDATA[<p>Creating repositories for your Laravel models, as well as creating caching decorators for them, is a useful way of not only implementing caching in your web app, but decoupling the application from a specific ORM. Unfortunately, it can involve writing a fair amount of boilerplate code.</p>
<p><a href="https://github.com/matthewbdaly/laravel-repositories">Laravel Repositories</a> is a set of base classes and interfaces for creating repositories and decorators in your application. It consists of:</p>
<ul>
<li>A generic interface for repositories</li>
<li>A base repository that implements the interface and can be extended for your own repositories</li>
<li>A base decorator that also implements the interface and can similarly be extended</li>
</ul>
<p>By using these, not only are you able to implement caching quickly and easily for most use cases, but you can easily extend the base classes to add additional methods for your use case. By creating new interfaces that extend the base interface, then having your repositories extend the repository and decorator, you can minimise the amount of work required to set up new repositories.</p>
<p>The main interface used is <code>Matthewbdaly\LaravelRepositories\Repositories\Interfaces\AbstractRepositoryInterface</code>, and your interfaces should extend this. Your decorators should extend <code>Matthewbdaly\LaravelRepositories\Repositories\Decorators\BaseDecorator</code>, and your repositories should extend <code>Matthewbdaly\LaravelRepositories\Repositories\Base</code>. Then, if you add any additional methods to your interface and ensure your repository and decorator implement that interface, it should be straightforward to type-hint the interface and get back the decorated repository, which will handle caching for you.</p>
<p>To be able to type-hint the repositories, you need to set them up in a service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;singleton(&#39;App\Repositories\Interfaces\ExampleRepositoryInterface&#39;, function () {
            $baseRepo = new \App\Repositories\EloquentExampleRepository(new \App\Example);
            $cachingRepo = new \App\Repositories\Decorators\ExampleDecorator($baseRepo, $this-&gt;app[&#39;cache.store&#39;]);
            return $cachingRepo;
        });
    }
}
</code></pre>
<p>Also, note that the cache backend used must be one that supports tags, such as Redis or Memcached. Data is cached using a tag derived from the model name. This also means you have to be careful when eager-loading relations, as the data will be cached under the main model’s name, not that of the relation. You may want to set up separate model events to flush those tags when the related field is updated.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating Laravel Helpers]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/09/creating-laravel-helpers/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/09/creating-laravel-helpers/</guid>
            <pubDate>Tue, 09 Jan 2018 17:26:26 GMT</pubDate>
            <description><![CDATA[<p>Although helpers are an important part of Laravel, the documentation doesn’t really touch on creating them. Fortunately, doing so it fairly easy.</p>
<p>Here I’m building a helper for formatting dates for the HTML5 <code>datetime-local</code> form input. First we define the helper function in <code>app\Helpers.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Carbon\Carbon;

if (!function_exists(&#39;format_date&#39;)) {
    function format_date(string $date)
    {
        return Carbon::parse($date, config(&#39;app.timezone&#39;))-&gt;format(&#39;Y-m-d\TH:i:s&#39;);
    }
}
</code></pre>
<p>Then we create a service provider to load them:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class HelperServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap the application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register the application services.
     *
     * @return void
     */
    public function register()
    {
        //
        require_once app_path() . &#39;/Helpers.php&#39;;
    }
}
</code></pre>
<p>Finally,we register the service provider in <code>config/app.php</code>:</p>
<pre><code class="lang-php">    &#39;providers&#39; =&gt; [

       ...
        App\Providers\HelperServiceProvider::class,
   ],
</code></pre>
<p>Of course, once you have this all set up for one helper, it’s easy to add more because they can all go in <code>app/Helpers.php</code>.</p>
<p>Creating your own helpers is a good way of refactoring unwanted logic out of your Blade templates or controllers and making it more reusable and maintainable, particularly for things like formatting dates or strings.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Getting the type of an unsupported Postgres field in Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/</guid>
            <pubDate>Mon, 08 Jan 2018 14:00:15 GMT</pubDate>
            <description><![CDATA[<p>Today I’ve been working on a generic, reusable Laravel admin interface, loosely inspired by the Django admin, that dynamically picks up the field types and generates an appropriate input field accordingly.</p>
<p>One problem I’ve run into is that getting a representation of a database table’s fields relies on <code>doctrine/dbal</code>, and its support for the more unusual PostgreSQL field types is spotty at best. I’ve been testing it out on a Laravel-based blogging engine, which has full-text search using the <code>TSVECTOR</code> field type, which isn’t supported, and it threw a nasty <code>Unknown database type tsvector requested</code> error.</p>
<p>Fortunately, it’s possible to register custom field type mappings easily enough. In this case we can safely treat a <code>TSVECTOR</code> field as a string` type anyway, so we can map it to the string type. We can do so in the boot method of a service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        // Register the TSVECTOR column
        $conn = $this-&gt;app-&gt;make(&#39;Illuminate\Database\ConnectionInterface&#39;);
        $conn-&gt;getDoctrineSchemaManager()
            -&gt;getDatabasePlatform()
            -&gt;registerDoctrineTypeMapping(&#39;tsvector&#39;, &#39;string&#39;);
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
       //
    }
}
</code></pre>
<p>We register a Doctrine type mapping that maps the <code>tsvector</code> type to a string. Now Doctrine will just treat it as a string.</p>
<p>We can then retrieve the field types as follows:</p>
<pre><code class="lang-php">        $table = $this-&gt;model-&gt;getTable();
        $fields = array_values(Schema::getColumnListing($table));
        $fielddata = [];
        foreach ($fields as $field){
            if ($field != &#39;id&#39; &amp;&amp; $field != &#39;created_at&#39; &amp;&amp; $field != &#39;updated_at&#39; &amp;&amp; $field != &#39;deleted_at&#39;) {
                try {
                    $fielddata[$field] = Schema::getColumnType($table, $field);
                } catch (\Exception $e) {
                    $fielddata[$field] = &#39;unknown&#39;;
                }
            }
        }
</code></pre>
<p>Note that we specifically don’t want to retrieve the ID or timestamps, so we exclude them - the user should never really have the need to update them manually. We fetch the table from the model and then call <code>Schema::getColumnListing()</code> to retrieve a list of fields for that table. Finally we call <code>Schema::getColumnType()</code> to actually get the type of each column.</p>
<p>Now, I suspect the performance of this admin interface is going to be inferior to a more specific one because it has to retrieve the fields all the time, but that’s not the point here - with a non-user facing admin interface, performance isn’t quite as much of an issue. For the same reason the admin doesn’t do any caching at all. It’s still useful under certain circumstances to be able to reverse-engineer the table structure and render an appropriate form dynamically.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating an Artisan task to set up a user account]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/08/creating-an-artisan-task-to-set-up-a-user-account/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/08/creating-an-artisan-task-to-set-up-a-user-account/</guid>
            <pubDate>Mon, 08 Jan 2018 12:52:39 GMT</pubDate>
            <description><![CDATA[<p>When working with any Laravel application that implements authentication, you’ll need to set up a user account to be able to work with it. One way of doing that is to add a user in a seeder, but that’s only really suitable if every user is going to use the same details.</p>
<p>Instead, you may want to create an Artisan command to set up the user account. Here’s an example of a command that does that:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Hash;

class CreateUser extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &#39;create:user&#39;;

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &#39;Creates a single user&#39;;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        // Get user model from config
        $model = config(&#39;auth.providers.users.model&#39;);

        // Let user know what this will do
        $this-&gt;info(&#39;I\&#39;ll ask you for the details I need to set up the user&#39;);

        // Get username
        $name = $this-&gt;ask(&#39;Please provide the username&#39;);

        // Get email
        $email = $this-&gt;ask(&#39;Please provide the email address&#39;);

        // Get password
        $password = $this-&gt;secret(&#39;Please provide the password&#39;);

        // Create model
        $user = new $model;
        $user-&gt;name = $name;
        $user-&gt;email = $email;
        $user-&gt;password = Hash::make($password);
        $user-&gt;save();
        $this-&gt;info(&#39;User saved&#39;);
    }
}
</code></pre>
<p>We fetch the user model from the config, before asking the user for the data we need. Then we insert it into the database and confirm it to the user.</p>
<p>Then we just need to register the command in <code>App\Console\Kernel.php</code>:</p>
<pre><code class="lang-php">    protected $commands = [
        \App\Console\Commands\CreateUser::class,
    ];
</code></pre>
<p>And we can run our command with <code>php artisan create:user</code>.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Adding comments to models in Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/07/adding-comments-to-models-in-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/07/adding-comments-to-models-in-laravel/</guid>
            <pubDate>Sun, 07 Jan 2018 17:21:50 GMT</pubDate>
            <description><![CDATA[<p><a href="https://github.com/matthewbdaly/laravel-comments">Laravel Comments</a> is a package I recently released that allows you to add comments to any model in your application. Possible models you could use it to enable comments on might include:</p>
<ul>
<li>Blog posts</li>
<li>Forum posts</li>
<li>Issues on an issue tracker</li>
</ul>
<p>It’s loosely inspired by Django’s comments system.</p>
<h2 id="installation">Installation</h2>
<p>Run this command to install it:</p>
<pre><code class="lang-bash">$ composer require matthewbdaly/laravel-comments
</code></pre>
<p>You will also need to run <code>php artisan migrate</code> to create the appropriate tables.</p>
<h2 id="making-a-model-commentable">Making a model commentable</h2>
<p>Add the following trait to a model to make it commentable:</p>
<pre><code class="lang-php">Matthewbdaly\LaravelComments\Eloquent\Traits\Commentable
</code></pre>
<p>The comments table uses a polymorphic relation, so it should be possible to attach it to pretty much any model. The model should now have a <code>comments</code> relation, allowing you to get the comments for a model instance.</p>
<h2 id="displaying-the-comments">Displaying the comments</h2>
<p>Obviously you can just render the comments in a view you can create yourself, but it’s usually going to be more convenient to use the existing view, even if just as a starting point, which includes the ability to submit new comments and flag existing ones. Include it in your views as follows:</p>
<pre><code class="lang-php">@include(&#39;comments::comments&#39;, [&#39;parent&#39; =&gt; $post])
</code></pre>
<p>The argument passed to <code>parent</code> should be the model instance for which you want to display the comments form. Obviously, you can easily override this to use your own custom form instead.</p>
<p>The package also contains the following views:</p>
<ul>
<li><code>comments::commentsubmitted</code></li>
<li><code>comments::flagsubmitted</code></li>
</ul>
<p>These are basically just acknowledgement screens for when a comment has been submitted or flagged, and you’ll probably want to override them.</p>
<p>The package also has its own routes and controller included for submitting comments and flags.</p>
<h2 id="using-the-models-directly">Using the models directly</h2>
<p>Of course there’s nothing stopping you creating your own routes and controllers for creating, viewing and flagging comments, and if, for instance, you wish to build a REST API that allows for adding comments to objects you can just use these models directly:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Eloquent\Models\Comment</code></li>
<li><code>Matthewbdaly\LaravelComments\Eloquent\Models\Comment\Flag</code></li>
</ul>
<p>I recommend that you use my repositories, which are as follows:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Contracts\Repositories\Comment</code></li>
<li><code>Matthewbdaly\LaravelComments\Contracts\Repositories\Comment\Flag</code></li>
</ul>
<p>These use <code>matthewbdaly/laravel-repositories</code> and so implement caching on the decorated repository, making it simple to ensure your models get cached appropriately. However, they aren’t compulsory.</p>
<h2 id="events">Events</h2>
<p>You can set up listeners for the following events:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Events\CommentReceived</code></li>
</ul>
<p>Fired when a new comment is submitted. The package does not include any kind of validation of comments, so you can instead listen for this event and implement your own functionality to validate them (eg, check it with Akismet, check for links). That way you can easily customise how it handles potentially spammy comments for your own particular use case.</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Events\CommentFlagged</code></li>
</ul>
<p>This event indicates that a comment has been flagged for moderator attention. You can use this event to send whatever notification is most appropriate (eg, email, Slack, SMS).</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[More tricks for speeding up your Laravel test suite]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/07/more-tricks-for-speeding-up-your-laravel-test-suite/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/07/more-tricks-for-speeding-up-your-laravel-test-suite/</guid>
            <pubDate>Sun, 07 Jan 2018 16:32:03 GMT</pubDate>
            <description><![CDATA[<p>When you first start doing test-driven development with Laravel, it can be quite hard to produce a test suite that runs quickly enough. The first time I used Laravel for a large project, I had a test suite that at one time, took over seven minutes to run, which was pretty awful considering that the ideal time for a test suite to take to run is no more than ten seconds.</p>
<p>Fortunately, with experience you can pick up some techniques which can quite drastically speed up your test suite. Here are some of the ones I’ve learned that can be useful.</p>
<p>Note that some of these are contradictory, and what works for one use case won’t necessarily work for another, so my advice is to try these and see what makes a difference for your use case.</p>
<h2 id="reduce-the-cost-of-hashing">Reduce the cost of hashing</h2>
<p>Inside the <code>createApplication()</code> method of <code>tests\CreatesApplication.php</code>, place the following statement:</p>
<pre><code class="lang-php">        Hash::setRounds(4);
</code></pre>
<p>This makes hashing passwords quicker and less demanding, and since you don’t care about the security of a password in a test, you’re not losing out in any way by doing so.</p>
<p>This, by itself, can <em>massively</em> reduce the time taken by your test suite - your mileage may vary, but I’ve personally seen it cut to a third of the previous time by using this. In fact, it’s recently been added to Laravel by default.</p>
<h2 id="if-you-re-creating-a-lot-of-fixtures-for-tests-do-so-in-a-transaction">If you’re creating a lot of fixtures for tests, do so in a transaction</h2>
<p>Sometimes, your application requires a lot of data to be added to the database just to be usable, and it’s quite common to use seeders for this purpose. However, it can take some time to insert a lot of data, especially if it has to be re-run for every test. If you do have to insert a lot of data before a test, you can cut down the time substantially by wrapping the seeder calls in a transaction:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Illuminate\Database\Eloquent\Model;
use DB;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        Model::unguard();

        DB::beginTransaction();
        $this-&gt;call(GroupTableSeeder::class);
        $this-&gt;call(UserTableSeeder::class);
        $this-&gt;call(ProjectTableSeeder::class);
        DB::commit();

        Model::reguard();
    }
}
`
</code></pre>
<p>I’ve personally seen this trick cut the insert time by over half, every single time the database is seeded. If you don’t have much data to insert, it may not help, but for large amounts of data it can make a big difference.</p>
<h2 id="if-a-lot-of-tests-need-the-same-data-migrate-and-seed-it-first-then-wrap-the-tests-in-transactions-and-roll-them-back-afterwards">If a lot of tests need the same data, migrate and seed it first, then wrap the tests in transactions and roll them back afterwards</h2>
<p>If multiple tests need to work with the same dataset, you should consider running the migrations and seeders before the first test, and then wrapping each test inside a transaction. That way the data will only be inserted once, and will be rolled back to that initial good state after each test.</p>
<pre><code class="lang-php">    protected static $migrated = false;

    public function setUp()
    {
        parent::setUp();
        DB::beginTransaction();
    }

    public function tearDown()
    {
        DB::rollback();
        parent::tearDown();
    }

    public static function setUpBeforeClass()
    {
        if (!self::$migrated) {
            Artisan::call(&#39;migrate:fresh&#39;);
            Artisan::call(&#39;db:seed&#39;);
            self::$migrated = true;
        }
    }
</code></pre>
<p>Using something like this instead of one of the existing testing traits may be a better fit under those circumstances. However, if your application uses transactions for some functionality this might cause problems.</p>
<h2 id="don-t-create-a-full-instance-of-the-laravel-application-unless-you-have-to">Don’t create a full instance of the Laravel application unless you have to</h2>
<p>Not every test requires that you instantiate the full Laravel application, and doing so slows your tests down. If you don’t absolutely need the full application instantiated in the test, consider having your test inherit from the below simple test case class instead:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests;

use Mockery\Adapter\Phpunit\MockeryPHPUnitIntegration;
use PHPUnit\Framework\TestCase as BaseTestCase;

class SimpleTestCase extends BaseTestCase
{
    use MockeryPHPUnitIntegration;
}
</code></pre>
<p>For properly isolated unit tests, using this base class instead can have a noticeable effect on performance.</p>
<h2 id="if-you-can-use-an-in-memory-sqlite-database-for-testing">If you can, use an in-memory SQLite database for testing</h2>
<p>This isn’t an option if you’re relying on the features of another database, but if it is, this is usually the fastest way to go. Configure it as follows in <code>phpunit.xml</code>:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<h2 id="use-the-new-refresh-database-trait">Use the new Refresh Database trait</h2>
<pre><code class="lang-php">   use RefreshDatabase;
</code></pre>
<p>This testing trait is generally more efficient than migrating down and up, because it empties the database afterwards rather than stepping through the changes of each migration. If you have a non-trivial number of migrations, it will almost certainly be quicker than migrating down, then back up for the next test.</p>
<h2 id="mock-what-you-can-t-control">Mock what you can’t control</h2>
<p>You should never, ever be making calls to external APIs in your test suite, because you can’t control whether those external API’s work - if a third-party API goes down, you may get a failed test run even if your application is working perfectly, not to mention it will add the time taken to send the request and receive a response to the test time. Instead, mock the calls to the third-party API.</p>
<h2 id="for-large-applications-consider-moving-parts-into-a-separate-package">For large applications, consider moving parts into a separate package</h2>
<p>If you have a particularly large application, it’s worth considering moving parts of it out into standalone packages and requiring them using Composer’s support for private Git repositories. That way, those packages can have their own test suites, and the main application’s test suite can cover the remaining functionality.</p>
<p>For instance, it’s fairly straightforward to pull out your models and migrations and put them in a separate package, and the tests for them can go with them to that package.</p>
<p>You should also consider whether parts of your application would be useful as standalone packages, and if so pull them out along with their tests. That way, not only are you making your test suite quicker, but you’re also saving yourself work by creating a reusable solution for a problem you might encounter again in the future.</p>
<h2 id="turn-off-xdebug">Turn off XDebug</h2>
<p>XDebug has a horrendous effect on the performance of the test suite. Turn it off unless you need it to generate test coverage. Better yet, set up continuous integration and have that generate the coverage for you.</p>
<h2 id="summary">Summary</h2>
<p>When you first start using Laravel, it can be hard to keep your test suite lean, and the longer a test suite takes to run, the less likely it is to actually get run regularly. To practice TDD properly, your test suite should not take long enough that your mind starts to wander, and ten seconds is a good target to aim for in this regard - you need to be able to run it several times a minute without problem. Obviously things like having a faster computer or an SSD will help, but there’s a lot you can do to make your test suite more efficient, even when running on a quite basic machine.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Adding dynamic flat pages to your Laravel app]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/03/adding-dynamic-flat-pages-to-your-laravel-app/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/03/adding-dynamic-flat-pages-to-your-laravel-app/</guid>
            <pubDate>Wed, 03 Jan 2018 11:49:11 GMT</pubDate>
            <description><![CDATA[<p>Most web apps have at least some need for some additional flat pages, for purposes such as:</p>
<ul>
<li>Terms and conditions</li>
<li>Cookie/privacy policy</li>
<li>FAQ</li>
</ul>
<p>You can of course hard-code this content in a view file, but if this content is likely to change often it may be useful to give the site owners the capability to manage this themselves.</p>
<p><a href="https://github.com/matthewbdaly/laravel-flatpages">Laravel Flatpages</a> is a package I wrote that adds a flatpage model, controller and view to your application. It’s loosely inspired by Django’s flatpages app. Using it, you can quickly and easily build a very simple brochure-style CMS. Each page contains fields for the title, content, slug, and an optional template field that specifies which view to use.</p>
<p>Note that it doesn’t include any kind of admin functionality, so you’ll need to add this yourself or find a package for it. It uses my <a href="http://github.com/matthewbdaly/laravel-repositories">repositories package</a> to access the database, and this has caching built in, so when you create, update or delete a flatpage, you should either resolve <code>Matthewbdaly\LaravelFlatpages\Contracts\Repositories\Flatpage</code> and use the methods on that to make the changes (in which case the appropriate caches should be flushed automatically), or flush the cache. It also requires a cache backend that supports tags, such as Memcached or Redis.</p>
<p>It does not include routing in the package itself because I couldn’t find a way to guarantee that it would always be the last route, so instead you should put this in your <code>routes/web.php</code> and make sure it’s always the last route:</p>
<pre><code class="lang-php">Route::get(&#39;{path}&#39;, &#39;\Matthewbdaly\LaravelFlatpages\Http\Controllers\FlatpageController@page&#39;);
</code></pre>
<p>Otherwise you could wind up with problems. The reason for that is that it has to check the path against the slugs of the flat pages in the database, and if it doesn’t find any it raises a 404.</p>
<p>Or, if you prefer, you can use the middleware at <code>Matthewbdaly\LaravelFlatpages\Http\Middleware\FlatpageMiddleware</code>, which may be more convenient in many case. This should be added as the last global middleware in <code>app\Http\Kernel.php</code>.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[A Laravel package boilerplate]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/02/a-laravel-package-boilerplate/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/02/a-laravel-package-boilerplate/</guid>
            <pubDate>Tue, 02 Jan 2018 12:12:15 GMT</pubDate>
            <description><![CDATA[<p>The second package I’ve been working on recently is <a href="https://github.com/matthewbdaly/laravel-package-boilerplate">Laravel Package Boilerplate</a>. It’s a basic starter boilerplate for building your own Laravel packages.</p>
<p>It’s not meant to be installed as a project dependency. Instead, run the following command to create a new project boilerplate with it:</p>
<pre><code class="lang-bash">composer create-project --prefer-dist matthewbdaly/laravel-package-boilerplate &lt;YOUR_NEW_PACKAGE_DIRECTORY&gt;
</code></pre>
<p>This will create a new folder that includes a <code>src</code> folder containing a service provider, and a <code>tests</code> folder containing a preconfigured base test case, as well as a simple test case for tests that don’t need the full application instantiated, in order to help keep your test suite as fast as possible.</p>
<p>In addition, it includes configuration files for:</p>
<ul>
<li>PHPUnit</li>
<li>PHP CodeSniffer</li>
<li>Travis CI</li>
</ul>
<p>That way you can start your project off the right way with very little effort.</p>
<p>I’ve also added my Artisan Standalone project as a dependency - that way you can access any Artisan commands you need to generate files you need as follows:</p>
<pre><code class="lang-bash">$ vendor/bin/artisan
</code></pre>
<p>Hopefully this package should make it a lot easier to create new Laravel packages in future.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Using Artisan from standalone Laravel packages]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/02/using-artisan-from-standalone-laravel-packages/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/02/using-artisan-from-standalone-laravel-packages/</guid>
            <pubDate>Tue, 02 Jan 2018 12:01:10 GMT</pubDate>
            <description><![CDATA[<p>Recently I’ve been building and publishing a significant number of Laravel packages, and I thought I’d share details of some of them over the next few days.</p>
<p><a href="https://github/com/matthewbdaly/artisan-standalone">Artisan Standalone</a> is a package that, when installed in a standalone Laravel package (eg, not in an actual Laravel install, but in a package that you’re building that is intended for use with Laravel), allows you to use Artisan. It’s intended largely to make it quicker and easier to build functionality as separate packages by giving you access to the same generator commands as you have when working with a Laravel application. It came about largely from a need to scratch my own itch, as when building packages I was having to either run Artisan commands in a Laravel app and move them over, or copy them from existing files, which was obviously a pain in the proverbial.</p>
<p>You can install it with the following command:</p>
<pre><code class="lang-bash">$ composer require --dev matthewbdaly/artisan-standalone
</code></pre>
<p>Once it’s installed, you can access Artisan as follows:</p>
<pre><code class="lang-bash">$ vendor/bin/artisan
</code></pre>
<p>Note that it doesn’t explicitly include Laravel as a dependency - you’ll need to add that in the parent package to pull in the libraries it needs (which you should be doing anyway). It’s possible that there are some commands that won’t work in this context, but they’re almost certainly ones you won’t need here, such as the <code>migrate</code> command. As far as I can tell the generator commands, which are the only ones we’re really interested in here, all work OK.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating Artisan tasks that generate files]]></title>
            <link>https://matthewdaly.co.uk/blog/2018/01/01/creating-artisan-tasks-that-generate-files/</link>
            <guid>https://matthewdaly.co.uk/blog/2018/01/01/creating-artisan-tasks-that-generate-files/</guid>
            <pubDate>Mon, 01 Jan 2018 16:06:21 GMT</pubDate>
            <description><![CDATA[<p>While the documentation for creating Artisan tasks is generally pretty good, it doesn’t really touch on creating tasks that generate new files. The only way to figure it out was to go digging through the source code. In this case, I was building an Artisan command to create Fractal transformers as part of a package I’m working on.</p>
<p>There’s a specialised class for generating files at <code>Illuminate\Console\GeneratorCommand</code>, which your command class should extend instead of <code>Illuminate\Console\Command</code>. In addition to the usual properties such as the signature and description, you also need to specify <code>$type</code> to give the type of class being generated. Also, note that the constructor is different, so if you use <code>php artisan make:console</code> to create the boilerplate for this command, you’ll need to delete the constructor.</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\MyPackage\Console\Commands;

use Illuminate\Console\GeneratorCommand;
use Symfony\Component\Console\Input\InputArgument;

class TransformerMakeCommand extends GeneratorCommand
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &#39;make:transformer {name : The required name of the transformer class}&#39;;

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &#39;Create a Fractal transformer&#39;;

    /**
     * The type of class being generated.
     *
     * @var string
     */
    protected $type = &#39;Fractal transformer&#39;;

    /**
     * Get the stub file for the generator.
     *
     * @return string
     */
    protected function getStub()
    {
        return __DIR__.&#39;/stubs/transformer.stub&#39;;
    }

    /**
     * Get the console command arguments.
     *
     * @return array
     */
    protected function getArguments()
    {
        return [
            [&#39;name&#39;, InputArgument::REQUIRED, &#39;The name of the command.&#39;],
        ];
    }

    /**
     * Get the default namespace for the class.
     *
     * @param  string  $rootNamespace
     * @return string
     */
    protected function getDefaultNamespace($rootNamespace)
    {
        return $rootNamespace.&#39;\Transformers&#39;;
    }
}
</code></pre>
<p>Note the <code>getDefaultNamespace()</code> method. If your class will live directly under the <code>app</code> folder this is not necessary. Otherwise, it needs to return the root namespace, with the folder structure you want after it. Here my class will live under <code>app\Transformers</code>, so I’ve set it to reflect that.</p>
<p>Also, note the <code>getStub()</code> method. This tells Artisan that it should use the specified stub file as the basis for our class. Below you’ll find the stub file I used for my transformer:</p>
<pre><code class="lang-php">&lt;?php

namespace DummyNamespace;

use Matthewbdaly\MyPackage\Transformers\BaseTransformer;
use Illuminate\Database\Eloquent\Model;

class DummyClass extends BaseTransformer
{
    public function transform(Model $model)
    {
        return [
            &#39;id&#39;            =&gt; (int) $model-&gt;id,
        ];
    }
}
</code></pre>
<p>Note that the <code>DummyNamespace</code> and <code>DummyClass</code> fields will be overwritten with the correct values.</p>
<p>Once this Artisan command is registered in the usual way, you can then run it as follows:</p>
<pre><code class="lang-bash">$ php artisan make:transformer Example
</code></pre>
<p>And it will generate a boilerplate class something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Transformers;

use Matthewbdaly\MyPackage\Transformers\BaseTransformer;
use Illuminate\Database\Eloquent\Model;

class Example extends BaseTransformer
{
    public function transform(Model $model)
    {
        return [
            &#39;id&#39;            =&gt; (int) $model-&gt;id,
        ];
    }
}
</code></pre>
<p>You can then replace the model with your own one as necessary, and add any further content to this class.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Using UUIDs as primary keys with Laravel and PostgreSQL]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/</guid>
            <pubDate>Fri, 29 Dec 2017 18:01:04 GMT</pubDate>
            <description><![CDATA[<p>For many applications, using UUID’s as the primary keys on a database table can make a lot of sense. For mobile or offline apps, in particular, they mean you can create new objects locally and assign them a primary key without having to worry about it colliding with another object that was created in the meantime once it gets synchronised to the server. Also, they are less informative to nefarious users - an autoincrementing value in a URL tells a user that that value is the primary key, and means the app may potentially allow gathering of information via user enumeration (eg calling <code>/api/v1/users/1</code>, <code>/api/v1/users/2</code> etc).</p>
<p>It’s fairly straightforward to use UUID’s as primary keys on your models when using PostgreSQL. First, you need to set up your migrations to use the <code>uuid-ossp</code> extension and set up the <code>id</code> field as both a UUID and the primary key. You also need to set a default value manually so that if it’s left empty it will generate a UUID for it.</p>
<pre><code class="lang-php">DB::statement(&#39;CREATE EXTENSION IF NOT EXISTS &quot;uuid-ossp&quot;;&#39;);
Schema::create(&#39;items&#39;, function (Blueprint $table) {
    $table-&gt;uuid(&#39;id&#39;)-&gt;primary();
    $table-&gt;text(&#39;text&#39;)-&gt;nullable();
    $table-&gt;timestamps();
});
DB::statement(&#39;ALTER TABLE items ALTER COLUMN id SET DEFAULT uuid_generate_v4();&#39;);
</code></pre>
<p>Then, in the model definition, you need to tell Laravel to cast the <code>id</code> field to a string, and explicitly set the primary key to <code>id</code>:</p>
<pre><code class="lang-php">class Item extends Model
{
    protected $casts = [
        &#39;id&#39; =&gt; &#39;string&#39;,
    ];

    protected $primaryKey = &quot;id&quot;;
}
</code></pre>
<p>Once this is done, the model should generate the primary keys for you as usual, except as UUID’s. If your application needs to accept UUID primary keys that were created offline, such as in a mobile app, you will probably want to add the <code>id</code> field to the <code>$fillable</code> array on the model to allow this.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Full text search with Laravel and PostgreSQL]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/</guid>
            <pubDate>Sat, 02 Dec 2017 23:30:44 GMT</pubDate>
            <description><![CDATA[<p>I’ve touched on <a href="/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/">using PostgreSQL to implement fuzzy search with Laravel before</a>, but another type of search that PostgreSQL can handle fairly easily is full-text search. Here I’ll show you how to use it in a Laravel application.</p>
<p>An obvious use case for this kind of search is a personal blogging engine. It’s unlikely something like this is going to have enough content for it to be worth using a heavier solution like Elasticsearch, but a <code>LIKE</code> or <code>ILIKE</code> statement doesn’t really cut it either, so Postgres’s full text search is a good fit. Below you’ll see a Laravel migration for the blog posts table:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreatePostsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create(&#39;posts&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;title&#39;);
            $table-&gt;datetime(&#39;pub_date&#39;);
            $table-&gt;text(&#39;text&#39;);
            $table-&gt;string(&#39;slug&#39;);
            $table-&gt;integer(&#39;author_id&#39;);
            $table-&gt;timestamps();
        });
        DB::statement(&quot;ALTER TABLE posts ADD COLUMN searchtext TSVECTOR&quot;);
        DB::statement(&quot;UPDATE posts SET searchtext = to_tsvector(&#39;english&#39;, title || &#39;&#39; || text)&quot;);
        DB::statement(&quot;CREATE INDEX searchtext_gin ON posts USING GIN(searchtext)&quot;);
        DB::statement(&quot;CREATE TRIGGER ts_searchtext BEFORE INSERT OR UPDATE ON posts FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(&#39;searchtext&#39;, &#39;pg_catalog.english&#39;, &#39;title&#39;, &#39;text&#39;)&quot;);
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        DB::statement(&quot;DROP TRIGGER IF EXISTS tsvector_update_trigger ON posts&quot;);
        DB::statement(&quot;DROP INDEX IF EXISTS searchtext_gin&quot;);
        DB::statement(&quot;ALTER TABLE posts DROP COLUMN searchtext&quot;);
        Schema::dropIfExists(&#39;posts&#39;);
    }
}
</code></pre>
<p>Note that after we create the basic layout of our <code>posts</code> table, we then have to drop down to raw DB statements to achieve the next steps:</p>
<ul>
<li>We add a column called <code>searchtext</code> with a type of <code>TSVECTOR</code> (unfortunately Laravel doesn’t have a convenient method to create this column type, so we need to do it with a raw statement). This column will hold our searchable document.</li>
<li>We use the <code>to_tsvector()</code> method to generate a document on each row that combines the title and text fields and store it in the <code>searchtext</code> column. Note also that we specify the language as the first argument. This is because Postgres’s full text search understands so-called “stopwords”, which are words that are so common as to not be worth bothering with at all, such as “the” - these will obviously differ between languages, so it’s prudent to explicitly state this so Postgres knows what stopwords to expect.</li>
<li>We create a <code>GIN</code> index on the <code>posts</code> table using our new <code>searchtext</code> column.</li>
<li>Finally we create a trigger which, when the table is amended, regenerates the search text.</li>
</ul>
<p>With that done, we can now look at actually performing a full-text search. To facilitate easy re-use, we’ll create a local scope on our <code>Post</code> model. If you haven’t used scopes in Laravel before, they essentially allow you to break queries into reusable chunks. In this case, we expect our scope to receive two arguments, the query instance (which is passed through automatically), and the search text:</p>
<pre><code class="lang-php">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    protected $fillable = [
        &#39;title&#39;,
        &#39;pub_date&#39;,
        &#39;text&#39;,
        &#39;slug&#39;,
        &#39;author_id&#39;
    ];

    public function scopeSearch($query, $search)
    {
        if (!$search) {
            return $query;
        }
        return $query-&gt;whereRaw(&#39;searchtext @@ to_tsquery(\&#39;english\&#39;, ?)&#39;, [$search])
            -&gt;orderByRaw(&#39;ts_rank(searchtext, to_tsquery(\&#39;english\&#39;, ?)) DESC&#39;, [$search]);
    }
}
</code></pre>
<p>If <code>$search</code> is empty, we just return the query object as is. Otherwise, we first of all construct a <code>WHERE</code> clause that matches our search text against the <code>searchtext</code> column. Note the syntax used here:</p>
<pre><code class="lang-sql">searchtext @@ to_tsquery(&#39;english&#39;, &#39;foo&#39;)
</code></pre>
<p>We use the <code>to_tsquery()</code> method to match our text against our search document. As before, note that we specify the language.</p>
<p>Finally, we specify an order - we want the highest ranked matches to appear first, and this section of the query does that:</p>
<pre><code class="lang-sql">ts_rank(searchtext, to_tsquery(&#39;english&#39;, &#39;foo&#39;)) DESC
</code></pre>
<p>Here we use <code>ts_rank()</code> to ensure we get our results in the appropriate order. Note that for both queries, we passed the arguments through as parameterized queries, rather than constructing a raw string - we have to watch out for SQL injection when we’re writing raw queries, but we can use PDO’s parameterized queries from Eloquent in a raw statement, which makes things a bit easier.</p>
<p>Now we can call our new search scope as follows:</p>
<pre><code class="lang-php">$posts = Post::search($search)-&gt;get();
</code></pre>
<p>Because the scope receives and returns a query builder instance, you can continue to add the rest of your query, or paginate it, as necessary:</p>
<pre><code class="lang-php">$posts = Post::search($search)-&gt;where(&#39;draft&#39;, false)-&gt;simplePaginate(5);
</code></pre>
<p>If you’re working in a language that makes heavy use of accents, such as French, you might also want to install the <code>unaccent</code> extension (you can do this in the migration with <code>CREATE EXTENSION unaccent</code>). Then, any time we call <code>to_tsvector()</code>, you should pass any strings through the <code>unaccent()</code> method to strip out the accents.</p>
<h2 id="do-we-need-the-migrations-">Do we need the migrations?</h2>
<p>Technically, we could do without the additional changes to the database structure - we could create a document on the fly inside a subquery and use that to query against, which would look something like this in SQL:</p>
<pre><code class="lang-sql">SELECT *
FROM
  (SELECT *,
          to_tsvector(&#39;english&#39;, posts.title) || to_tsvector(&#39;english&#39;, posts.text) AS document
   FROM &quot;posts&quot;) search
WHERE search.document @@ to_tsquery(&#39;Redis&#39;)
ORDER BY ts_rank(search.document, to_tsquery(&#39;english&#39;, &#39;Redis&#39;)) DESC;
</code></pre>
<p>However, the performance is likely to be significantly worse using this approach as it has to recreate the document, and doesn’t have an existing index to query against. It’s also a pig to write something like this with an ORM.</p>
<p>I’m currently working on a more generic solution for implementing full text search with Postgres and Laravel, however so far it looks like that solution will not only be considerably more complex than this (consistently producing a suitable query for unknown data is rather fiddly), but you can’t create a column for the vector ahead of time, meaning the query will be slower. This approach, while it requires more work than simply installing a package, is not terribly hard to implement on a per-model basis and is easy to customise for your use case.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a postcode lookup client with HTTPlug and PHPSpec]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/11/28/building-a-postcode-lookup-client-with-httplug-and-phpspec/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/11/28/building-a-postcode-lookup-client-with-httplug-and-phpspec/</guid>
            <pubDate>Tue, 28 Nov 2017 11:40:39 GMT</pubDate>
            <description><![CDATA[<p>While PHPUnit is my normal go-to PHP testing framework, for some applications I find <a href="http://www.phpspec.net/en/stable/">PHPSpec</a> superior, in particular REST API clients. I’ve found that it makes for a better flow when doing test-driven development, because it makes it very natural to write a test first, then run it, then make the test pass.</p>
<p>In this tutorial I’ll show you how to build a lookup API client for UK postcodes. In the process of doing so, we’ll use PHPSpec to drive our development process. We’ll also use <a href="http://docs.php-http.org/en/latest/httplug/tutorial.html">HTTPlug</a> as our underlying HTTP library. The advantage of this over using something like Guzzle is that we give library users the freedom to choose the HTTP library they feel is most appropriate to their situation.</p>
<h2 id="background">Background</h2>
<p>If you’re unfamiliar with it, the UK postcode system is our equivalent of a zip code in the US, but with two major differences:</p>
<ul>
<li>The codes themselves are alphanumeric instead of numeric, with the first part including one or two letters usually (but not always) derived from the nearest large town or city (eg L for Liverpool, B for Birmingham, OX for Oxford), or for London, based on the part of the city (eg NW for the north-west of London)</li>
<li>A full postcode is in two parts (eg NW1 8TQ), and the first part narrows the location down to a similar area to a US-style zip code, while the second part usually narrows it down to a street (although sometimes large organisations that receive a lot of mail will have a postcode to themselves).</li>
</ul>
<p>This means that if you have someone’s postcode and house name or address, you can use those details to look up the rest of their address details. This obviously makes it easier for users to fill out a form, such as when placing an order on an e-commerce site - you can just request those two details and then autofill the rest from them.</p>
<p>Unfortunately, it’s not quite that simple. The data is owned by Royal Mail, and they charge through the nose for access to the raw data, which places this data well outside the budgets of many web app developers. Fortunately, <a href="https://ideal-postcodes.co.uk/">Ideal Postcodes</a> offer a REST API for querying this data. It’s not free, but at 2.5p per request it’s not going to break the bank unless used excessively, and they offer some dummy postcodes that are free to query, which is perfectly fine for testing.</p>
<p>For those of you outside the UK, this may not be of much immediate use, but the underlying principles will still be useful, and you can probably build a similar client for your own nation’s postal code system. For instance, there’s a <a href="https://www.zipcodeapi.com/API">Zipcode API</a> that those of you in the US can use, and if you understand what’s going on here it shouldn’t be hard to adapt it to work with that. If you do produce a similar client for your country’s postal code system, submit a pull request to update the README with a link to it and I’ll include it.</p>
<h2 id="setting-up">Setting up</h2>
<p>First we’ll create a <code>composer.json</code> to specify our dependencies:</p>
<pre><code class="lang-json">{
    &quot;name&quot;: &quot;matthewbdaly/postcode-client&quot;,
    &quot;description&quot;: &quot;A postcode lookup client.&quot;,
    &quot;type&quot;: &quot;library&quot;,
    &quot;keywords&quot;: [&quot;postcode&quot;],
    &quot;require&quot;: {
        &quot;psr/http-message&quot;: &quot;^1.0&quot;,
        &quot;php-http/client-implementation&quot;: &quot;^1.0&quot;,
        &quot;php-http/httplug&quot;: &quot;^1.0&quot;,
        &quot;php-http/message-factory&quot;: &quot;^1.0&quot;,
        &quot;php-http/discovery&quot;: &quot;^1.0&quot;
    },
    &quot;require-dev&quot;: {
        &quot;psy/psysh&quot;: &quot;^0.8.0&quot;,
        &quot;phpspec/phpspec&quot;: &quot;^3.2&quot;,
        &quot;squizlabs/php_codesniffer&quot;: &quot;^2.7&quot;,
        &quot;php-http/mock-client&quot;: &quot;^1.0&quot;,
        &quot;php-http/message&quot;: &quot;^1.0&quot;,
        &quot;guzzlehttp/psr7&quot;: &quot;^1.0&quot;
    },
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;authors&quot;: [
        {
            &quot;name&quot;: &quot;Matthew Daly&quot;,
            &quot;email&quot;: &quot;matthewbdaly@gmail.com&quot;
        }
    ],
    &quot;autoload&quot;: {
        &quot;psr-4&quot;: {
            &quot;Matthewbdaly\\Postcode\\&quot;: &quot;src/&quot;
        }
    }
}
</code></pre>
<p>Note that we don’t install an actual HTTPlug client, other than the mock one, which is only useful for testing. This is deliberate - we’re giving developers working with this library the choice of working with whatever HTTP client they see fit. We do use the Guzzle PSR7 library, but that’s just for the PSR7 library.</p>
<p>Then we install our dependencies:</p>
<pre><code class="lang-bash">$ composer install
</code></pre>
<p>We also need to tell PHPSpec what our namespace will be. Save this as <code>phpspec.yml</code>:</p>
<pre><code class="lang-yml">suites:
    test_suite:
        namespace: Matthewbdaly\Postcode
        psr4_prefix: Matthewbdaly\Postcode
</code></pre>
<p>Don’t forget to update the namespace in both files to whatever you’re using, which should have a vendor name and a package name.</p>
<p>With that done, it’s time to introduce the next component.</p>
<h2 id="introducing-httplug">Introducing HTTPlug</h2>
<p>In the past I’ve usually used either Curl or Guzzle to carry out HTTP requests. However, the problem with this approach is that you’re forcing whoever uses your library to use whatever HTTP client, and whatever version of that client, that you deem appropriate. If they’re also using another library that someone else has written and they made different choices, you could have problems.</p>
<p>HTTPlug is an excellent way of solving this problem. By requiring only an interface and not a concrete implementation, using HTTPlug means that you can specify that the consumer of the library must provide a suitable implementation of that library, but leave the choice of implementation up to them. This means that they can choose whatever implementation best fits their use case. There are <a href="http://docs.php-http.org/en/latest/clients.html">adapters for many different clients</a>, so it’s unlikely that they won’t be able to find one that meets their needs.</p>
<p>In addition, HTTPlug provides the means to automatically determine what HTTP client to use, so that if one is not explicitly provided, it can be resolved without any action on the part of the developer. As long as a suitable HTTP adapter is installed, it will be used.</p>
<h2 id="getting-started">Getting started</h2>
<p>One advantage of PHPSpec is that it will automatically generate much of the boilerplate for our client and specs. To create our client spec, run this command:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec desc Matthewbdaly/Postcode/Client
Specification for Matthewbdaly\Postcode\Client created in /home/matthew/Projects/postcode-client/spec/ClientSpec.php.
</code></pre>
<p>Now that we have a spec for our client, we can generate the client itself:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                    
  11  - it is initializable
      class Matthewbdaly\Postcode\Client does not exist.

                                      100%                                       1
1 specs
1 example (1 broken)
14ms


  Do you want me to create `Matthewbdaly\Postcode\Client` for you?              
                                                                         [Y/n] 
y
Class Matthewbdaly\Postcode\Client created in /home/matthew/Projects/postcode-client/src/Client.php.

                                      100%                                       1
1 specs
1 example (1 passed)
16ms
</code></pre>
<p>You will need to enter <code>Y</code> when prompted. We now have an empty class for our client.</p>
<p>Next, we need to make sure that the constructor for our client accepts two parameters:</p>
<ul>
<li>The HTTP client</li>
<li>A message factory instance, which is used to create the request</li>
</ul>
<p>Amend <code>spec/ClientSpec.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace spec\Matthewbdaly\Postcode;

use Matthewbdaly\Postcode\Client;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Http\Client\HttpClient;
use Http\Message\MessageFactory;

class ClientSpec extends ObjectBehavior
{
    function let (HttpClient $client, MessageFactory $messageFactory)
    {
        $this-&gt;beConstructedWith($client, $messageFactory);
    }

    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Client::class);
    }
}
</code></pre>
<p>Note the use of the <code>let()</code> method here. This lets us specify how the object is constructed, with the <code>beConstructedWith()</code> method. Also, note that <code>$this</code> refers not to the test, but to the object being tested - this takes a bit of getting used to if you’re used to working with PHPUnit.</p>
<p>Also, note that the objects passed through are not actual instances of those objects - instead they are mocks created automatically by PHPSpec. This makes mocking extremely easy, and you can easily set up your own expectations on those mock objects in the test. If you want to use a real object, you can instantiate it in the spec as usual. If we need any other mocks, we can typehint them in our method in exactly the same way.</p>
<p>If we once again use <code>vendor/bin/phpspec run</code> we can now generate a constructor:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                    
  18  - it is initializable
      method Matthewbdaly\Postcode\Client::__construct not found.

                                      100%                                       1
1 specs
1 example (1 broken)
281ms


  Do you want me to create `Matthewbdaly\Postcode\Client::__construct()` for    
  you?                                                                          
                                                                         [Y/n] 
y
  Method Matthewbdaly\Postcode\Client::__construct() has been created.

                                      100%                                       1
1 specs
1 example (1 passed)
50ms
</code></pre>
<p>This will only create a placeholder for the constructor. You need to populate it yourself, so update <code>src/Client.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Postcode;

use Http\Client\HttpClient;
use Http\Discovery\HttpClientDiscovery;
use Http\Message\MessageFactory;
use Http\Discovery\MessageFactoryDiscovery;

class Client
{
    public function __construct(HttpClient $client = null, MessageFactory $messageFactory = null)
    {
        $this-&gt;client = $client ?: HttpClientDiscovery::find();
        $this-&gt;messageFactory = $messageFactory ?: MessageFactoryDiscovery::find();
    }
}
</code></pre>
<p>A little explanation is called for here. We need two arguments in our construct:</p>
<ul>
<li>An instance of <code>Http\Client\HttpClient</code> to send the request</li>
<li>An instance of <code>Http\Message\MessageFactory</code> to create the request</li>
</ul>
<p>However, we don’t want to force the user to create one. Therefore if they are not set, we use <code>Http\Discovery\HttpClientDiscovery</code> and <code>Http\Discovery\MessageFactoryDiscovery</code> to create them for us.</p>
<p>If we re-run PHPSpec, it should now pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       1
1 specs
1 example (1 passed)
31ms
</code></pre>
<p>Next, we want to have a method for retrieving the endpoint. Add the following method to <code>spec/ClientSpec.php</code>:</p>
<pre><code class="lang-php">    function it_can_retrieve_the_base_url()
    {
        $this-&gt;getBaseUrl()-&gt;shouldReturn(&#39;https://api.ideal-postcodes.co.uk/v1/postcodes/&#39;);
    }
</code></pre>
<p>Here we’re asserting that fetching the base URL returns the given result. Note how much simpler and more intuitive this syntax is than PHPUnit would be:</p>
<pre><code class="lang-php">$this-&gt;assertEquals(&#39;https://api.ideal-postcodes.co.uk/v1/postcodes/&#39;, $client-&gt;getBaseUrl());
</code></pre>
<p>Running the tests again should prompt us to create the boilerplate for the new method:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                      
  23  - it can retrieve the base url
      method Matthewbdaly\Postcode\Client::getBaseUrl not found.

                  50%                                     50%                    2
1 specs
2 examples (1 passed, 1 broken)
40ms


  Do you want me to create `Matthewbdaly\Postcode\Client::getBaseUrl()` for     
  you?                                                                          
                                                                         [Y/n] 
y
  Method Matthewbdaly\Postcode\Client::getBaseUrl() has been created.

Matthewbdaly/Postcode/Client                                                      
  23  - it can retrieve the base url
      expected &quot;https://api.ideal-postcod...&quot;, but got null.

                  50%                                     50%                    2
1 specs
2 examples (1 passed, 1 failed)
72ms
</code></pre>
<p>Now we need to update that method to work as expected:</p>
<pre><code class="lang-php">    protected $baseUrl = &#39;https://api.ideal-postcodes.co.uk/v1/postcodes/&#39;;

     ...

    public function getBaseUrl()
    {
        return $this-&gt;baseUrl;
    }
</code></pre>
<p>This should make the tests pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       2
1 specs
2 examples (2 passed)
34ms
</code></pre>
<p>Next, we need to be able to get and set the API key. Add the following to <code>spec/ClientSpec.php</code>:</p>
<pre><code class="lang-php">    function it_can_get_and_set_the_key()
    {
        $this-&gt;getKey()-&gt;shouldReturn(null);
        $this-&gt;setKey(&#39;foo&#39;)-&gt;shouldReturn($this);
        $this-&gt;getKey()-&gt;shouldReturn(&#39;foo&#39;);
    }
</code></pre>
<p>Note that we expect <code>$this-&gt;setKey(&#39;foo&#39;)</code> to return <code>$this</code>. This is an example of a <em>fluent</em> interface - by returning an instance of the object, it enables methods to be chained, eg <code>$client-&gt;setKey(&#39;foo&#39;)-&gt;get()</code>. Obviously it won’t work for anything that has to return a value, but it’s a useful way of making your classes more intuitive to use.</p>
<p>Next, run the tests again and agree to the prompts as before:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                      
  28  - it can get and set the key
      method Matthewbdaly\Postcode\Client::getKey not found.

                         66%                                     33%             3
1 specs
3 examples (2 passed, 1 broken)
51ms


  Do you want me to create `Matthewbdaly\Postcode\Client::getKey()` for you?    
                                                                         [Y/n] 
y
  Method Matthewbdaly\Postcode\Client::getKey() has been created.

Matthewbdaly/Postcode/Client                                                      
  28  - it can get and set the key
      method Matthewbdaly\Postcode\Client::setKey not found.

                         66%                                     33%             3
1 specs
3 examples (2 passed, 1 broken)
43ms


  Do you want me to create `Matthewbdaly\Postcode\Client::setKey()` for you?    
                                                                         [Y/n] 
y
  Method Matthewbdaly\Postcode\Client::setKey() has been created.

Matthewbdaly/Postcode/Client                                                      
  28  - it can get and set the key
      expected [obj:Matthewbdaly\Postcode\Client], but got null.

                         66%                                     33%             3
1 specs
3 examples (2 passed, 1 failed)
52ms
</code></pre>
<p>Next, add our getter and setter for the key, as well as declaring the property <code>$key</code>:</p>
<pre><code class="lang-php">    protected $key;

    public function getKey()
    {
        return $this-&gt;key;
    }

    public function setKey(string $key)
    {
        $this-&gt;key = $key;
        return $this;
    }
</code></pre>
<p>That should make the tests pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       3
1 specs
3 examples (3 passed)
38ms
</code></pre>
<p>With that done, our final task is to be able to handle sending requests. Add the following imports at the top of <code>spec/ClientSpec.php</code>:</p>
<pre><code class="lang-php">use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;
</code></pre>
<p>And add the following method at the bottom of the same file:</p>
<pre><code class="lang-php">    function it_can_send_the_request(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)
    {
        $this-&gt;beConstructedWith($client, $messageFactory);
        $this-&gt;setKey(&#39;foo&#39;);
        $data = json_encode([
            &#39;result&#39; =&gt; [
                &quot;postcode&quot; =&gt; &quot;SW1A 2AA&quot;,
                &quot;postcode_inward&quot; =&gt; &quot;2AA&quot;,
                &quot;postcode_outward&quot; =&gt; &quot;SW1A&quot;,
                &quot;post_town&quot; =&gt; &quot;LONDON&quot;,
                &quot;dependant_locality&quot; =&gt; &quot;&quot;,
                &quot;double_dependant_locality&quot; =&gt; &quot;&quot;,
                &quot;thoroughfare&quot; =&gt; &quot;Downing Street&quot;,
                &quot;dependant_thoroughfare&quot; =&gt; &quot;&quot;,
                &quot;building_number&quot; =&gt; &quot;10&quot;,
                &quot;building_name&quot; =&gt; &quot;&quot;,
                &quot;sub_building_name&quot; =&gt; &quot;&quot;,
                &quot;po_box&quot; =&gt; &quot;&quot;,
                &quot;department_name&quot; =&gt; &quot;&quot;,
                &quot;organisation_name&quot; =&gt; &quot;Prime Minister &amp; First Lord Of The Treasury&quot;,
                &quot;udprn&quot; =&gt; 23747771,
                &quot;umprn&quot; =&gt; &quot;&quot;,
                &quot;postcode_type&quot; =&gt; &quot;L&quot;,
                &quot;su_organisation_indicator&quot; =&gt; &quot;&quot;,
                &quot;delivery_point_suffix&quot; =&gt; &quot;1A&quot;,
                &quot;line_1&quot; =&gt; &quot;Prime Minister &amp; First Lord Of The Treasury&quot;,
                &quot;line_2&quot; =&gt; &quot;10 Downing Street&quot;,
                &quot;line_3&quot; =&gt; &quot;&quot;,
                &quot;premise&quot; =&gt; &quot;10&quot;,
                &quot;longitude&quot; =&gt; -0.127695242183412,
                &quot;latitude&quot; =&gt; 51.5035398826274,
                &quot;eastings&quot; =&gt; 530047,
                &quot;northings&quot; =&gt; 179951,
                &quot;country&quot; =&gt; &quot;England&quot;,
                &quot;traditional_county&quot; =&gt; &quot;Greater London&quot;,
                &quot;administrative_county&quot; =&gt; &quot;&quot;,
                &quot;postal_county&quot; =&gt; &quot;London&quot;,
                &quot;county&quot; =&gt; &quot;London&quot;,
            ]
        ]);
        $messageFactory-&gt;createRequest(&#39;GET&#39;, &#39;https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo&#39;, [], null, &#39;1.1&#39;)-&gt;willReturn($request);
        $client-&gt;sendRequest($request)-&gt;willReturn($response);
        $response-&gt;getStatusCode()-&gt;willReturn(200);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;getContents()-&gt;willReturn($data);
        $this-&gt;get(&#39;SW1A 2AA&#39;)-&gt;shouldBeLike(json_decode($data, true));
    }
</code></pre>
<p>This test is by far the biggest so far, so it merits some degree of explanation.</p>
<p>Note that we don’t make a real HTTP request against the API. This may sound strange, but bear with me. We have no control whatsoever over that API, and it could in theory become inaccessible or be subject to breaking changes at any time. We also don’t want to be shelling out for a paid service just to test our API client works. All we can do is test that our implementation will send the request we expect it to send - we don’t want our test suite reporting a bug when the API goes down.</p>
<p>We therefore typehint not just the dependencies for the constructor, but a request, response and stream instance. We mock our our responses from those instances using the <code>willReturn()</code> method, so we have complete control over what we pass to our client. That way we can return any appropriate response or throw any exception we deem fit to test the behaviour under those circumstances. For the message factory, we specify what arguments it should receive to create the request, and return our mocked-out request object.</p>
<p>Also, note we use <code>shouldBeLike()</code> to verify the response - this is effectively using the <code>==</code> operator, whereas <code>shouldBe()</code> uses the <code>===</code> operator, making it stricter.</p>
<p>Let’s run the tests, and don’t forget the prompt:</p>
<pre><code class="lang-php">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                      
  38  - it can send the request
      method Matthewbdaly\Postcode\Client::get not found.

                            75%                                     25%          4
1 specs
4 examples (3 passed, 1 broken)
55ms


  Do you want me to create `Matthewbdaly\Postcode\Client::get()` for you?       
                                                                         [Y/n] 
y
  Method Matthewbdaly\Postcode\Client::get() has been created.

Matthewbdaly/Postcode/Client                                                      
  38  - it can send the request
      expected [array:1], but got null.

                            75%                                     25%          4
1 specs
4 examples (3 passed, 1 failed)
56ms
</code></pre>
<p>Now we can implement the <code>get()</code> method:</p>
<pre><code class="lang-php">    public function get(string $postcode)
    {
        $url = $this-&gt;getBaseUrl() . rawurlencode($postcode) . &#39;?&#39; . http_build_query([
            &#39;api_key&#39; =&gt; $this-&gt;getKey()
        ]);
        $request = $this-&gt;messageFactory-&gt;createRequest(
            &#39;GET&#39;,
            $url,
            [],
            null,
            &#39;1.1&#39;
        );
        $response = $this-&gt;client-&gt;sendRequest($request);
        $data = json_decode($response-&gt;getBody()-&gt;getContents(), true);
        return $data;
    }
</code></pre>
<p>We first build up our URL, before using the message factory to create a request object. We then pass the built request to our client to send, before decoding the response into the format we want.</p>
<p>This should make our tests pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       4
1 specs
4 examples (4 passed)
307ms
</code></pre>
<p>Our client now works, but there are a couple of situations we need to account for. First, the API will raise a 402 if you make a request for a real postcode without having paid. We need to catch this and throw an exception. Add this to <code>spec/ClientSpec.php</code>:</p>
<pre><code class="lang-php">use Matthewbdaly\Postcode\Exceptions\PaymentRequired;

    ...

    function it_throws_an_exception_if_payment_required(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)
    {
        $this-&gt;beConstructedWith($client, $messageFactory);
        $this-&gt;setKey(&#39;foo&#39;);
        $messageFactory-&gt;createRequest(&#39;GET&#39;, &#39;https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo&#39;, [], null, &#39;1.1&#39;)-&gt;willReturn($request);
        $client-&gt;sendRequest($request)-&gt;willReturn($response);
        $response-&gt;getStatusCode()-&gt;willReturn(402);
        $this-&gt;shouldThrow(PaymentRequired::class)-&gt;duringGet(&#39;SW1A 2AA&#39;);
    }
</code></pre>
<p>With that done, run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                      
  87  - it throws an exception if payment required
      expected exception of class &quot;Matthewbdaly\Postcode\Exc...&quot;, but got
      [exc:Prophecy\Exception\Call\UnexpectedCallException(&quot;Method call:
        - getBody()
      on Double\ResponseInterface\P15 was not expected, expected calls were:
        - getStatusCode()&quot;)].

                              80%                                     20%        5
1 specs
5 examples (4 passed, 1 failed)
130ms
</code></pre>
<p>Let’s amend the client to throw this exception:</p>
<pre><code class="lang-php">use Matthewbdaly\Postcode\Exceptions\PaymentRequired;

    ...

    public function get(string $postcode)
    {
        $url = $this-&gt;getBaseUrl() . rawurlencode($postcode) . &#39;?&#39; . http_build_query([
            &#39;api_key&#39; =&gt; $this-&gt;getKey()
        ]);
        $request = $this-&gt;messageFactory-&gt;createRequest(
            &#39;GET&#39;,
            $url,
            [],
            null,
            &#39;1.1&#39;
        );
        $response = $this-&gt;client-&gt;sendRequest($request);
        if ($response-&gt;getStatusCode() == 402) {
            throw new PaymentRequired;
        }
        $data = json_decode($response-&gt;getBody()-&gt;getContents(), true);
        return $data;
    }
</code></pre>
<p>And let’s re-run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                    
  87  - it throws an exception if payment required
      expected exception of class &quot;Matthewbdaly\Postcode\Exc...&quot;, but got [obj:Error] with the
      message: &quot;Class &#39;Matthewbdaly\Postcode\Exceptions\PaymentRequired&#39; not found&quot;

                              80%                                     20%        5
1 specs
5 examples (4 passed, 1 failed)
389ms
</code></pre>
<p>It fails now because the exception doesn’t exist. Let’s create it at <code>src/Exceptions/PaymentRequired.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Postcode\Exceptions;

class PaymentRequired extends \Exception
{
}
</code></pre>
<p>That should be enough to make our tests pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       5
1 specs
5 examples (5 passed)
89ms
</code></pre>
<p>We also need to raise an exception when the postcode is not found, which raises a 404 error. Add the following spec:</p>
<pre><code class="lang-php">use Matthewbdaly\Postcode\Exceptions\PostcodeNotFound;
    ...
    function it_throws_an_exception_if_postcode_not_found(HttpClient $client, MessageFactory $messageFactory, RequestInterface $request, ResponseInterface $response, StreamInterface $stream)
    {
        $this-&gt;beConstructedWith($client, $messageFactory);
        $this-&gt;setKey(&#39;foo&#39;);
        $messageFactory-&gt;createRequest(&#39;GET&#39;, &#39;https://api.ideal-postcodes.co.uk/v1/postcodes/SW1A%202AA?api_key=foo&#39;, [], null, &#39;1.1&#39;)-&gt;willReturn($request);
        $client-&gt;sendRequest($request)-&gt;willReturn($response);
        $response-&gt;getStatusCode()-&gt;willReturn(404);
        $this-&gt;shouldThrow(PostcodeNotFound::class)-&gt;duringGet(&#39;SW1A 2AA&#39;);
    }
</code></pre>
<p>Run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
Matthewbdaly/Postcode/Client                                                    
  98  - it throws an exception if postcode not found
      expected exception of class &quot;Matthewbdaly\Postcode\Exc...&quot;, but got
      [exc:Prophecy\Exception\Call\UnexpectedCallException(&quot;Method call:
        - getBody()
      on Double\ResponseInterface\P20 was not expected, expected calls were:
        - getStatusCode()&quot;)].

                                83%                                     16%      6
1 specs
6 examples (5 passed, 1 failed)
538ms
</code></pre>
<p>This time we’ll create the exception class before updating the client. Create the following class at <code>src/Exceptions/PostcodeNotFound.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\Postcode\Exceptions;

/**
 * Postcode not found exception
 *
 */
class PostcodeNotFound extends \Exception
{
}
</code></pre>
<p>And update the client:</p>
<pre><code class="lang-php">use Matthewbdaly\Postcode\Exceptions\PostcodeNotFound;
    ...
    public function get(string $postcode)
    {
        $url = $this-&gt;getBaseUrl() . rawurlencode($postcode) . &#39;?&#39; . http_build_query([
            &#39;api_key&#39; =&gt; $this-&gt;getKey()
        ]);
        $request = $this-&gt;messageFactory-&gt;createRequest(
            &#39;GET&#39;,
            $url,
            [],
            null,
            &#39;1.1&#39;
        );
        $response = $this-&gt;client-&gt;sendRequest($request);
        if ($response-&gt;getStatusCode() == 402) {
            throw new PaymentRequired;
        }
        if ($response-&gt;getStatusCode() == 404) {
            throw new PostcodeNotFound;
        }
        $data = json_decode($response-&gt;getBody()-&gt;getContents(), true);
        return $data;
    }
</code></pre>
<p>Re-run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpspec run
                                      100%                                       6
1 specs
6 examples (6 passed)
103ms
</code></pre>
<p>And our API client is feature complete! You can find the source code of the finished client <a href="https://github.com/matthewbdaly/postcode-client">here</a>.</p>
<h2 id="summary">Summary</h2>
<p>Personally, I find that while PHPSpec isn’t appropriate for every use case, it’s particularly handy for API clients and it’s generally my go-to testing solution for them. It handles producing a lot of the boilerplate for me, and it results in a much better workflow for test-driven development as it makes it very natural to write the test first, then make it pass.</p>
<p>HTTPlug has been a revelation for me. While it takes a bit of getting used to if you’re used to something like Guzzle, it means that you’re giving consumers of your library the freedom to choose the HTTP client of their choice, meaning they don’t have to fight with several different libraries requiring different versions of Guzzle. It also allows for easy resolution of the HTTP client, rather than having to explicitly pass through an instance when instantiating your client. I’m planning to use it extensively in the future.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating custom assertions with PHPUnit]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/11/16/creating-custom-assertions-with-phpunit/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/11/16/creating-custom-assertions-with-phpunit/</guid>
            <pubDate>Thu, 16 Nov 2017 15:15:50 GMT</pubDate>
            <description><![CDATA[<p>Today I’ve been working on a library I’m building for making it easier to build RESTful API’s with Laravel. It uses an abstract RESTful controller, which inherits from the default Laravel controller, and I wanted to verify that the instantiated controller includes all the traits from the base controller.</p>
<p>However, there was a problem. The only practical way to verify that a class includes a trait is with the <code>class_uses()</code> function, but this doesn’t work if the class inherits from a parent that includes these traits. As the class is abstract, it can’t be instantiated directly, so you must either create a dummy class just for testing that extends it, or mock the class, and that means that <code>class_uses()</code> won’t work. As a result, I needed to first get the parent class, then call <code>class_uses()</code> on that, which is possible, but a bit verbose to do repeatedly for several tests.</p>
<p>Fortunately it’s quite easy to create your own custom assertions in PHPUnit. I started out by setting up the test with the assertion I wanted to have:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\Unit\Http\Controllers;

use Tests\TestCase;
use Mockery as m;

class RestfulControllerTest extends TestCase
{
    public function testTraits()
    {
        $controller = m::mock(&#39;Matthewbdaly\Harmony\Http\Controllers\RestfulController&#39;)-&gt;makePartial();
        $this-&gt;assertParentHasTrait(&#39;Illuminate\Foundation\Bus\DispatchesJobs&#39;, $controller);
        $this-&gt;assertParentHasTrait(&#39;Illuminate\Foundation\Validation\ValidatesRequests&#39;, $controller);
        $this-&gt;assertParentHasTrait(&#39;Illuminate\Foundation\Auth\Access\AuthorizesRequests&#39;, $controller);
    }
}
</code></pre>
<p>Actually implementing the assertion is fairly straightforward. You simply add the assertion as a method on the base test case you’re using. and accept whatever arguments are required, plus a final argument of <code>$message = &#39;&#39;</code>. Then you call <code>self::assertThat()</code>, as demonstrated below:</p>
<pre><code class="lang-php">    public function assertParentHasTrait($trait, $class, $message = &#39;&#39;)
    {
        $parent = get_parent_class($class);
        $traits = class_uses($parent);
        self::assertThat(in_array($trait, $traits), self::isTrue(), $message);
    }
</code></pre>
<p>In this case we’re asserting that the specified trait appears in the list of traits on the parent class. Note the use of <code>self::isTrue()</code> - this just verifies that the response is truthy.</p>
<p>Using this method it’s quite easy to create custom assertions, which can help make your tests less verbose and easier to read.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Catching debug statements in PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/11/06/catching-debug-statements-in-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/11/06/catching-debug-statements-in-php/</guid>
            <pubDate>Mon, 06 Nov 2017 12:00:18 GMT</pubDate>
            <description><![CDATA[<p>It’s unfortunately quite easy to neglect to remove debugging statements in PHP code. I’ve done so many times myself, and it’s not unknown for these to wind up in production. After I saw it happen again recently, I decided to look around for a way to prevent it happening.</p>
<p><a href="/blog/2017/03/15/enforcing-a-coding-standard-with-php-codesniffer/">As mentioned earlier</a>, I generally use PHP CodeSniffer to enforce a coding standard on my projects, and it’s easy to set it up and run it. With a little work, you can also use it to catch these unwanted debugging statements before they get committed.</p>
<p>First, you need to make sure <code>squizlabs/php_codesniffer</code> is included in your project’s development dependencies in <code>composer.json</code>. Then, create a <code>phpcs.xml</code> file that looks something like this:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ruleset name=&quot;PHP_CodeSniffer&quot;&gt;
    &lt;description&gt;Coding standard.&lt;/description&gt;
    &lt;file&gt;src&lt;/file&gt;
    &lt;arg value=&quot;np&quot;/&gt;
    &lt;rule ref=&quot;PSR2&quot;/&gt;
    &lt;rule ref=&quot;Squiz.Commenting.FunctionComment&quot; /&gt;
    &lt;rule ref=&quot;Squiz.Commenting.FunctionCommentThrowTag&quot; /&gt;
    &lt;rule ref=&quot;Squiz.Commenting.ClassComment&quot; /&gt;
    &lt;rule ref=&quot;Generic.PHP.ForbiddenFunctions&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;forbiddenFunctions&quot; type=&quot;array&quot; value=&quot;eval=&gt;NULL,dd=&gt;NULL,die=&gt;NULL,var_dump=&gt;NULL,sizeof=&gt;count,delete=&gt;unset,print=&gt;echo,create_function=&gt;NULL&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
&lt;/ruleset&gt;
</code></pre>
<p>The key is the rule <code>Squiz.PHP.ForbiddenFunctions</code>. This allows us to define a list of functions that are forbidden in our project. Typically this will be things like <code>die()</code>, <code>eval()</code>, <code>var_dump()</code> and <code>dd()</code>.</p>
<p>Now, this ruleset will catch the unwanted functions (as well as enforcing PSR2 and certain rules about comments), but we can’t guarantee that we’ll always remember to run it. We could run CodeSniffer in continuous integration (and this is a good idea anyway), but that doesn’t stop us from committing code with those forbidden functions. We need a way to ensure that CodeSniffer runs on every commit and doesn’t allow it to go ahead if it fails. To do that we can use a pre-commit hook. Save the following in your repository as <code>.git/hooks/pre-commit</code>:</p>
<pre><code class="lang-bash">vendor/bin/phpcs
</code></pre>
<p>Then run the following command to make it executable:</p>
<pre><code class="lang-bash">$ chmod +x .git/hooks/pre-commit
</code></pre>
<p>A pre-commit hook is run before every commit, and if it returns false, will not allow the commit to go ahead. That means that if CodeSniffer fails for any reason, we will have to go back and fix the problem before we can commit. If for some reason you do need to bypass this check, you can still do so by using the <code>--no-verify</code> flag with <code>git commit</code>.</p>
<p>The advantage of this method is that it’s not dependent on any one IDE or editor, so it’s widely applicable. However, if you’re doing this sort of thing with Git hooks, you may want to look at some of the solutions for managing hooks, since <code>.git/hooks</code> is outside the actual Git repository.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[An Azure Filesystem integration for Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/</guid>
            <pubDate>Sun, 29 Oct 2017 19:31:34 GMT</pubDate>
            <description><![CDATA[<p><a href="/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/">My earlier post about integrating Laravel and Azure storage</a> seems to have become something of a go-to resource on this subject (I suspect this is because very few developers actually use Laravel and Azure together). Unfortunately it hasn’t really aged terribly well - changes to the namespace and to Guzzle mean that it needs some work to integrate it.</p>
<p>I’ve therefore <a href="https://github.com/matthewbdaly/laravel-azure-storage">created a package for it</a>. That way, it’s easier to keep it up to date as if someone finds and fixes an issue with it, they can submit their changes back.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Using phpiredis with Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/10/20/using-phpiredis-with-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/10/20/using-phpiredis-with-laravel/</guid>
            <pubDate>Fri, 20 Oct 2017 21:55:26 GMT</pubDate>
            <description><![CDATA[<p>Laravel has support out of the box for using Redis. However, by default it uses a Redis client written in PHP, which will always be a little slower than one written in C. If you’re making heavy use of Redis, it may be worth using the <a href="https://github.com/nrk/phpiredis">phpiredis</a> extension to squeeze a little more performance out of it.</p>
<p>I’m using PHP 7.0 on Ubuntu Zesty and I installed the dependencies with the following command:</p>
<pre><code class="lang-bash">$ sudo apt-get install libhiredis-dev php-redis php7.0-dev
</code></pre>
<p>Then I installed phpiredis as follows:</p>
<pre><code class="lang-bash">git clone https://github.com/nrk/phpiredis.git &amp;&amp; \
       cd phpiredis &amp;&amp; \
       phpize &amp;&amp; \
       ./configure --enable-phpiredis &amp;&amp; \
       make &amp;&amp; \
       sudo make install
</code></pre>
<p>Finally, I configured Redis to use phpiredis in the <code>redis</code> section of <code>config/database.php</code> for a Laravel app:</p>
<pre><code class="lang-php">    &#39;redis&#39; =&gt; [

        &#39;cluster&#39; =&gt; false,

        &#39;default&#39; =&gt; [
            &#39;host&#39;     =&gt; env(&#39;REDIS_HOST&#39;, &#39;localhost&#39;),
            &#39;password&#39; =&gt; env(&#39;REDIS_PASSWORD&#39;, null),
            &#39;port&#39;     =&gt; env(&#39;REDIS_PORT&#39;, 6379),
            &#39;database&#39; =&gt; 0,
            &#39;options&#39; =&gt; [
                &#39;connections&#39; =&gt; [
                    &#39;tcp&#39; =&gt; &#39;Predis\Connection\PhpiredisStreamConnection&#39;, // PHP streams
                    &#39;unix&#39; =&gt; &#39;Predis\Connection\PhpiredisSocketConnection&#39;, // ext-socket
                ],
            ]
        ],
    ],
</code></pre>
<p>Now, I’m going to be honest - in a casual comparison I couldn’t see much difference in terms of speed. I would probably only bother with setting this up on a site where high Redis performance was absolutely necessary. If you just want a quicker cache response it might make more sense to put Varnish in front of the site instead. However, in cases where Redis gets used heavily, it’s probably worth doing.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[A generic PHP SMS library]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/09/25/a-generic-php-sms-library/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/09/25/a-generic-php-sms-library/</guid>
            <pubDate>Mon, 25 Sep 2017 21:18:18 GMT</pubDate>
            <description><![CDATA[<p>This weekend I published <a href="https://github.com/matthewbdaly/sms-client">sms-client</a>, a generic PHP library for sending SMS notifications. It’s intended to offer a consistent interface when sending SMS notifications by using swappable drivers. That way, if your SMS service provider suddenly goes out of business or bumps up their prices, it’s easy to switch to a new one.</p>
<p>Out of the box it comes with drivers for the following services:</p>
<ul>
<li>Nexmo</li>
<li>ClockworkSMS</li>
</ul>
<p>In addition, it provides the following test drivers:</p>
<ul>
<li>Null</li>
<li>Log</li>
<li>RequestBin</li>
</ul>
<p>Here’s an example of how you might use it with the ClockworkSMS driver:</p>
<pre><code class="lang-php">use GuzzleHttp\Client as GuzzleClient;
use GuzzleHttp\Psr7\Response;
use Matthewbdaly\SMS\Drivers\Clockwork;
use Matthewbdaly\SMS\Client;

$guzzle = new GuzzleClient;
$resp = new Response;
$driver = new Clockwork($guzzle, $resp, [
    &#39;api_key&#39; =&gt; &#39;MY_CLOCKWORK_API_KEY&#39;,
]);
$client = new Client($driver);
$msg = [
    &#39;to&#39;      =&gt; &#39;+44 01234 567890&#39;,
    &#39;content&#39; =&gt; &#39;Just testing&#39;,
];
$client-&gt;send($msg);
</code></pre>
<p>If you want to roll your own driver for it, it should be easy - just create a class that implements the <code>Matthewbdaly\SMS\Contracts\Driver</code> interface. Most of the existing drivers work using Guzzle to send HTTP requests to an API, but you don’t necessarily have to do that - for instance, you could create a driver for a mail-to-SMS gateway by using Swiftmailer or the PHP mail class. If you create a driver for it, please feel free to submit a pull request so I can add it to the repository.</p>
<p>For Laravel or Lumen users, there’s <a href="https://github.com/matthewbdaly/laravel-sms">an integration package</a> that should make it easier to use. For users of other frameworks, it should still be fairly straightforward to integrate.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Installing Nginx Unit on Ubuntu]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/09/08/installing-nginx-unit-on-ubuntu/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/09/08/installing-nginx-unit-on-ubuntu/</guid>
            <pubDate>Fri, 08 Sep 2017 21:05:04 GMT</pubDate>
            <description><![CDATA[<p>Recently Nginx announced the release of the first beta of <a href="https://www.nginx.com/products/nginx-unit/">Unit</a>, an application server that supports Python, PHP and Go, with support coming for Java, Node.js and Ruby.</p>
<p>The really interesting part is that not only does it support more than one language, but Unit can be configured by making HTTP requests, rather than by editing config files. This makes it potentially very interesting to web developers like myself who have worked in multiple languages - I could use it to serve a Python or PHP web app, simply by making different requests during the setup process. I can see this being a boon for SaaS providers - you could pick up the language from a file, much like the <code>runtime.txt</code> used by Heroku, and set up the application on the fly.</p>
<p>It’s currently in public beta, and there are packages for Ubuntu, so I decided to try it out. I’ve created the Ansible role below to set up Unit on an Ubuntu 16.04 server or VM:</p>
<pre><code class="lang-yml">---
- name: Install keys
  apt_key: url=http://nginx.org/keys/nginx_signing.key state=present

- name: Setup main repo
  apt_repository: repo=&#39;deb http://nginx.org/packages/mainline/ubuntu/ xenial nginx&#39; state=present

- name: Setup source rep
  apt_repository: repo=&#39;deb-src http://nginx.org/packages/mainline/ubuntu/ xenial nginx&#39; state=present

- name: Update system
  apt: upgrade=full update_cache=yes

- name: Install dependencies
  apt: name={{ item }} state=present
  with_items:
    - nginx
    - unit
    - golang
    - php-dev
    - php7.0-dev
    - libphp-embed
    - libphp7.0-embed
    - python-dev
    - python3
    - python3-dev
    - php7.0-cli
    - php7.0-mcrypt
    - php7.0-pgsql
    - php7.0-sqlite3
    - php7.0-opcache
    - php7.0-curl
    - php7.0-mbstring
    - php7.0-dom
    - php7.0-xml
    - php7.0-zip
    - php7.0-bcmath

- name: Copy over Nginx configuration
  copy: src=nginx.conf dest=/etc/nginx/sites-available/default owner=root group=root mode=0644
</code></pre>
<p>Note the section that copies over the Nginx config file. Here is that file:</p>
<pre><code class="lang-nginx">upstream unit_backend {
    server 127.0.0.1:8300;
}

server {
    listen 80 default_server;
    listen [::]:80 default_server ipv6only=on;
    fastcgi_param HTTP_PROXY &quot;&quot;; 

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    root /var/www/public;
    index index.php index.html index.htm;

    server_name server_domain_or_IP;

    location / { 
        try_files $uri $uri/ /index.php?$query_string;
    }   

    location ~ \.php$ {
        try_files $uri /index.php =404;
        proxy_pass http://unit_backend;
        proxy_set_header Host $host;
    }   
}
</code></pre>
<p>This setup proxies all dynamic requests to the Unit backend in a similar fashion to how it would normally pass it to PHP-FPM.</p>
<p>There were still a few little issues. It doesn’t exactly help that the Nginx package provided with this repository isn’t quite the same as the one in Ubuntu by default - not only is it the unstable version, but it doesn’t set up the <code>sites-available</code> and <code>sites-enabled</code> folders, so I had to do that manually. I also had an issue with Systemd starting the process (at <code>/run/control.unit.sock</code>) with permissions that didn’t allow Nginx to access it. I’m not that familiar with Systemd so I wound up just setting the permissions of the file manually, but that doesn’t persist between restarts. I expect this issue isn’t that big a deal to someone more familiar with Systemd, but I haven’t been able to resolve it yet.</p>
<p>I decided to try it out with a Laravel application. I created a new Laravel app and set it up with the web root at <code>/var/www</code>. I then saved the following configuration for it as <code>app.json</code>:</p>
<pre><code class="lang-json">{
    &quot;listeners&quot;: {
        &quot;*:8300&quot;: {
            &quot;application&quot;: &quot;myapp&quot;
        }
    },
    &quot;applications&quot;: {
        &quot;myapp&quot;: {
            &quot;type&quot;: &quot;php&quot;,
            &quot;workers&quot;: 20,
            &quot;user&quot;: &quot;www-data&quot;,
            &quot;group&quot;: &quot;www-data&quot;,
            &quot;root&quot;: &quot;/var/www/public&quot;,
            &quot;index&quot;: &quot;index.php&quot;
        }
    }
}
</code></pre>
<p>This is fairly basic, but a good example of how you configure an application with Unit. The <code>listener</code> section maps a port to an application, while the <code>applications</code> section defines an application called <code>myapp</code>. In this case, we specify that the type should be <code>php</code>. Note that each platform has slightly different options - for instance, the Python type doesn’t have the <code>index</code> or <code>root</code> options, instead having the <code>path</code> option, which specifies the path to the <code>wsgi.py</code> file.</p>
<p>I then ran the following command to upload the file:</p>
<pre><code class="lang-bash">$ curl -X PUT -d @app.json --unix-socket /run/control.unit.sock http://localhost
</code></pre>
<p>Note that we send it direct to the Unix socket file - this way we don’t have to expose the API to the outside. After this was done, the Laravel app began working as expected.</p>
<p>We can then make a GET request to view the configured applications:</p>
<pre><code class="lang-bash">$ curl --unix-socket /run/control.unit.sock http://localhost/
{
        &quot;listeners&quot;: {
                &quot;*:8300&quot;: {
                        &quot;application&quot;: &quot;saas&quot;
                }
        },

        &quot;applications&quot;: {
                &quot;saas&quot;: {
                        &quot;type&quot;: &quot;php&quot;,
                        &quot;workers&quot;: 20,
                        &quot;user&quot;: &quot;www-data&quot;,
                        &quot;group&quot;: &quot;www-data&quot;,
                        &quot;root&quot;: &quot;/var/www/public&quot;,
                        &quot;index&quot;: &quot;index.php&quot;
                }
        }
}
</code></pre>
<p>It’s also possible to update and delete existing applications via the API using PUT and DELETE requests.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>This is <em>way</em> too early to be seriously considering using Unit in production. It’s only just been released as a public beta, and it’s a bit fiddly to set up. However, it has an enormous amount of promise.</p>
<p>One thing I can’t really see right now is whether it’s possible to use a virtualenv with it for Python applications. In the Python community it’s standard practice to use Virtualenv to isolate the dependencies for individual applications, and it’s not clear how I’d be able to go about using this, if it is possible. For deploying Python applications, lack of virtualenv support would be a deal breaker, and I hope this gets clarified soon.</p>
<p>I’d also be curious to see benchmarks of how it compares to something like PHP-FPM. It’s quite possible that it may be less performant than other solutions. However, I will keep a close eye on this in future.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Making internal requests with Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/09/02/making-internal-requests-with-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/09/02/making-internal-requests-with-laravel/</guid>
            <pubDate>Sat, 02 Sep 2017 13:45:27 GMT</pubDate>
            <description><![CDATA[<p>Recently I’ve been working on a Phonegap app that needs to work offline. The nature of relational databases can often make this tricky if you’re dealing with related objects and you’re trying to retrofit it to something that wasn’t built with this use case in mind.</p>
<p>Originally my plan was to push each request that would have been made to a queue in WebSQL, and then on reconnect, make every request individually. It quickly became apparent, however, that this approach had a few problems:</p>
<ul>
<li>If one request failed, the remaining requests had to be stopped from executing</li>
<li>It didn’t allow for storing the failed transactions in a way that made them easy to retrieve</li>
</ul>
<p>Instead, I decided to create a single <code>sync</code> endpoint for the API that would accept an object containing all the requests that would be made, and then step through each one. If it failed, it would get the failed request and all subsequent ones in the object, and store them in the database. That way, even if the data didn’t sync correctly, it wasn’t lost, and if necessary it could be resolved manually.</p>
<p>Since the necessary API endpoints already existed, and were thoroughly tested, it was not a good idea to start duplicating that functionality. Instead, I implemented the functionality to carry out internal requests, and I thought I’d share how you can do this.</p>
<p>For any service you may build for your Laravel applications, it’s a good idea to create an interface for it first:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts;

interface MakesInternalRequests
{
    /**
     * Make an internal request
     *
     * @param string $action   The HTTP verb to use.
     * @param string $resource The API resource to look up.
     * @param array  $data     The request body.
     * @return \Illuminate\Http\Response
     */
    public function request(string $action, string $resource, array $data = []);
}
</code></pre>
<p>That way you can resolve the service using dependency injection, making it trivial to replace it with a mock when testing.</p>
<p>Now, actually making an internal request is pretty easy. You get the app instance (you can do so by resolving it using dependency injection as I do below, or call the <code>app()</code> helper). Then you put together the request you want to make and pass it as an argument to the app’s <code>handle()</code> method:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services;

use Illuminate\Http\Request;
use App\Contracts\MakesInternalRequests;
use Illuminate\Foundation\Application;
use App\Exceptions\FailedInternalRequestException;

/**
 * Internal request service
 */
class InternalRequest implements MakesInternalRequests
{
    /**
     * The app instance
     *
     * @var $app
     */
    protected $app;

    /**
     * Constructor
     *
     * @param Application $app        The app instance.
     * @return void
     */
    public function __construct(Application $app)
    {
        $this-&gt;app = $app;
    }

    /**
     * Make an internal request
     *
     * @param string $action   The HTTP verb to use.
     * @param string $resource The API resource to look up.
     * @param array  $data     The request body.
     * @throws FailedInternalRequestException Request could not be synced.
     * @return \Illuminate\Http\Response
     */
    public function request(string $action, string $resource, array $data = [])
    {
        // Create request
        $request = Request::create(&#39;/api/&#39; . $resource, $action, $data, [], [], [
            &#39;HTTP_Accept&#39;             =&gt; &#39;application/json&#39;,
        ]);

        // Get response
        $response = $this-&gt;app-&gt;handle($request);
        if ($response-&gt;getStatusCode() &gt;= 400) {
            throw new FailedInternalRequestException($request, $response);
        }

        // Dispatch the request
        return $response;
    }
}
</code></pre>
<p>Also note that I’ve created a custom exception, called <code>FailedInternalRequestException</code>. This is fired if the status code returned from the internal requests is greater than or equal to 400 (thus denoting an error):</p>
<pre><code class="lang-php">&lt;?php

namespace App\Exceptions;

use Illuminate\Http\Request;
use Illuminate\Http\Response;

/**
 * Exception for when a bulk sync job fails
 */
class FailedInternalRequestException extends \Exception
{
    /**
     * Request instance
     *
     * @var $request
     */
    protected $request;

    /**
     * Response instance
     *
     * @var $response
     */
    protected $response;

    /**
     * Constructor
     *
     * @param Request  $request  The request object.
     * @param Response $response The response object.
     * @return void
     */
    public function __construct(Request $request, Response $response)
    {
        parent::__construct();
        $this-&gt;request = $request;
        $this-&gt;response = $response;
    }

    /**
     * Get request object
     *
     * @return Request
     */
    public function getRequest()
    {
        return $this-&gt;request;
    }

    /**
     * Get response object
     *
     * @return Response
     */
    public function getResponse()
    {
        return $this-&gt;response;
    }
}
</code></pre>
<p>You can catch this exception in an appropriate place and handle it as you wish. Now, if you import the internal request class as <code>$dispatcher</code>, you can just call <code>$dispatcher-&gt;request($action, $resource, $data)</code>, where <code>$action</code> is the HTTP verb, <code>$resource</code> is the API resource to send to, and <code>$data</code> is the data to send.</p>
<p>It’s actually quite rare to have to do this. In this case, because this was a REST API and every request made to it was changing the state of the application (there were no GET requests, only POST, PUT, PATCH and DELETE), it made sense to just break down the request body and do internal requests against the existing API, since otherwise I’d have to duplicate the existing functionality. I would not recommend this approach for something like fetching data to render a page on the server side, as there are more efficient ways of accomplishing it. In all honesty I can’t think of any other scenario where this would genuinely be the best option. However, it worked well for my use case and allowed me to implement this functionality quickly and simply.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Run your tests locally with Sismo]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/08/19/run-your-tests-locally-with-sismo/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/08/19/run-your-tests-locally-with-sismo/</guid>
            <pubDate>Sat, 19 Aug 2017 14:40:07 GMT</pubDate>
            <description><![CDATA[<p>Continuous integration is a veritable boon when working on any large software project. However, the popularity of distributed version control systems like Git over the older, more centralised ones like Subversion means that when you commit your changes, they don’t necessarily get pushed up to a remote repository immediately. While this is a good thing because it means you can commit at any stage without worrying about pushing up changes that break everyone else’s build, it has the downside that the tests aren’t automatically run on every commit, just every push, so if you get sloppy about running your tests before every commit you can more easily get caught out. In addition, a full CI server like Jenkins is a rather large piece of software that you don’t really want to run locally if you can help it, and has a lot of functionality you don’t need.</p>
<p><a href="https://sismo.symfony.com/">Sismo</a> is a small, simple continuous integration server, implemented in PHP, that’s ideal for running locally. You can set it up to run your tests on every commit, and it has an easy-to-use web interface. Although it’s a PHP application, there’s no reason why you couldn’t use it to run tests for projects in other languages, and because it’s focused solely on running your test suite without many of the other features of more advanced CI solutions, it’s a good fit for local use. Here I’ll show you how I use it.</p>
<h2 id="setting-up-sismo">Setting up Sismo</h2>
<p>Nowadays I don’t generally install a web server on a computer directly, preferring to use Vagrant or the dev server as appropriate, so Sismo generally doesn’t have to coexist with anything else. I normally install PHP7’s FastCGI implementation and Nginx, along with the SQLite bindings (which Sismo needs):</p>
<pre><code class="lang-bash">$ sudo apt-get install nginx php7.0-fpm php7.0-sqlite3
</code></pre>
<p>Then we can set up our Nginx config at <code>/etc/nginx/sites-available/default</code>:</p>
<pre><code class="lang-nginx">server {
    listen 80 default_server;
    listen [::]:80 default_server ipv6only=on;
    fastcgi_param HTTP_PROXY &quot;&quot;;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    root /var/www/html;
    index sismo.php index.html index.htm;

    server_name server_domain_or_IP;

    location / {
        try_files $uri $uri/ /sismo.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri /sismo.php =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        fastcgi_index sismo.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param SISMO_DATA_PATH &quot;/home/matthew/.sismo/data&quot;;
        fastcgi_param SISMO_CONFIG_PATH &quot;/home/matthew/.sismo/config.php&quot;;
        include fastcgi_params;
    }
}
</code></pre>
<p>You’ll probably want to adjust the paths as appropriate. Then set up the required folders:</p>
<pre><code class="lang-bash">$ mkdir ~/.sismo
$ mkdir ~/.sismo/data
$ touch ~/.sismo/config.php
$ chmod -R a+w ~/.sismo/
</code></pre>
<p>Then, <a href="https://sismo.symfony.com/get/sismo.php">download Sismo</a> and put it in your web root (here it’s at <code>/var/www/html/sismo.php</code>).</p>
<p>Now, say you have a project you want to test (I’m using my <a href="https://github.com/matthewbdaly/laravel-etag-middleware">Laravel ETag middleware</a> for this example). We need to specify the projects we want to test in <code>~/.sismo/config.php</code>:</p>
<pre><code class="lang-php">&lt;?php

$projects = array();

$notifier = new Sismo\Notifier\DBusNotifier();

Sismo\Project::setDefaultCommand(&#39;if [ -f composer.json ]; then composer install; fi &amp;&amp; vendor/bin/phpunit&#39;);

$projects[] = new Sismo\GithubProject(&#39;Laravel ETag Middleware&#39;, &#39;/home/matthew/Projects/laravel-etag-middleware&#39;, $notifier);

return $projects;
</code></pre>
<p>Hopefully this shouldn’t be too difficult to understand. We create an array of projects, then specify a notifier (this is Linux-specific - refer to the documentation for using Growl on Mac OS). Next, we specify that by default the tests should run <code>composer install</code> followed by <code>vendor/bin/phpunit</code>. We then specify this project is a Github project - it also supports Bitbucket, or plain SSH, or the default Project, but in general it shouldn’t be a problem to use it with any repository as you can just run it against the local copy. Finally we return the list of projects.</p>
<p>Now, we should be able to run our tests as follows:</p>
<pre><code class="lang-bash">$ php /var/www/html/sismo.php build
Building Project &quot;Laravel ETag Middleware&quot; (into &quot;68a087&quot;)
</code></pre>
<p>That should be working, but it doesn’t get us anything we don’t get by running the tests ourselves. To trigger the build, we need to set up a post-commit hook for our project in <code>.git/hooks/post-commit</code>:</p>
<pre><code class="lang-bash">#!/bin/sh

php /var/www/html/sismo.php --quiet --force build laravel-etag-middleware `git log -1 HEAD --pretty=&quot;%H&quot;` &amp;&gt;/dev/null &amp;
</code></pre>
<p>You should now be able to view your project in the Sismo web interface at <a href="http://localhost">http://localhost</a>:</p>
<p><img src="/static/images/sismo-screenshot.png" alt="Sismo"></p>
<p>Clicking on the project should take you through to its build history:</p>
<p><img src="/static/images/sismo-screenshot2.png" alt="Sismo project page"></p>
<p>From here on, it should be straightforward to add new projects as and when necessary. Because you can change the command on a per-project basis, you can quite happily use it to run tests for Python or Node.js projects as well as PHP ones, and it’s not hard to configure it.</p>
<p>I personally find it very useful to have something in place to run my tests on every commit like this, and while you could just use a post-commit hook for that, this approach is less obtrusive because it doesn’t force you to wait around for your test suite to finish.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Profiling your Laravel application with Clockwork]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/08/14/profiling-your-laravel-application-with-clockwork/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/08/14/profiling-your-laravel-application-with-clockwork/</guid>
            <pubDate>Mon, 14 Aug 2017 11:40:00 GMT</pubDate>
            <description><![CDATA[<p>If you’re building any non-trivial application, it’s always a good idea to profile it to find performance problems. <a href="https://github.com/barryvdh/laravel-debugbar">Laravel Debugbar</a> is the usual solution for profiling Laravel web applications, but it isn’t really much use for REST API’s or single-page web apps that consume them.</p>
<p>Recently I was introduced to <a href="https://github.com/itsgoingd/clockwork">Clockwork</a>, which is a server-side extension for profiling PHP applications. It’s made it a whole lot easier to track down issues like excessive numbers of queries when building an API, and as a result I’ve been able to dramatically improve the performance of an API I’ve been working on. Here I’ll show you how you can use it on a project.</p>
<h2 id="installing-clockwork">Installing Clockwork</h2>
<p>Clockwork is available via Composer:</p>
<pre><code class="lang-bash">$ composer require itsgoingd/clockwork
</code></pre>
<p>You also need to register the service provider in <code>config/app.php</code>:</p>
<pre><code class="lang-php">   Clockwork\Support\Laravel\ClockworkServiceProvider::class,
</code></pre>
<p>And register the middleware globally in <code>app/Http/Kernel.php</code>:</p>
<pre><code class="lang-php">protected $middleware = [
      \Clockwork\Support\Laravel\ClockworkMiddleware::class,
]
</code></pre>
<p>Note that it only works when <code>APP_DEBUG</code> is set to true in your <code>.env</code> file. This means that you can keep it in your application without worrying about exposing too much data in production, as long as debug mode is not active on your production server (which it shouldn’t be anyway).</p>
<p>You will also need to install the <a href="https://chrome.google.com/webstore/detail/clockwork/dmggabnehkmmfmdffgajcflpdjlnoemp?hl=en">Chrome extension</a> in order to actually work with the returned data. Clockwork works by adding its own route to your Laravel application, and this extension makes sure that it makes the appropriate request on loading a page, and then displays the data in the dev tools.</p>
<p>Once it’s all installed and your application is running, open the dev tools and you should see the new <strong>Clockwork</strong> tab in there. On the left of this tab is a list of requests - if you make a request, you’ll see it added to the list. When you click on each request, you’ll see the following tabs, where applicable:</p>
<h2 id="request">Request</h2>
<p><img src="/static/images/clockwork1.png" alt="Request tab"></p>
<p>This is similar to Chrome’s network tab in that it shows all of the headers for a given request. It’s not anything you can’t get using Chrome’s existing dev tools, but because it doesn’t show any static content it’s arguably a bit easier to navigate.</p>
<h2 id="timeline">Timeline</h2>
<p><img src="/static/images/clockwork2.png" alt="Timeline tab"></p>
<p>This shows how long the response takes to respond, which can be helpful in identifying slower requests.</p>
<p>In addition, you can create your own events using the <code>clock()</code> helper, which will appear in the timeline, as in this example:</p>
<pre><code class="lang-php">clock()-&gt;startEvent(&#39;email_sent&#39;, &#39;Email sent.&#39;);
clock()-&gt;endEvent(&#39;email_sent&#39;);
</code></pre>
<h2 id="log">Log</h2>
<p><img src="/static/images/clockwork8.png" alt="Log tab"></p>
<p>The log tab is only displayed if you use the <code>clock()</code> helper to log data. You can log text or JSON objects as appropriate:</p>
<pre><code class="lang-php">clock(&#39;Message text.&#39;); // &#39;Message text.&#39; appears in Clockwork log tab
clock([&#39;hello&#39; =&gt; &#39;world&#39;]); // logs json representation of the array
</code></pre>
<p>This is arguably more convenient than using the <code>Log</code> facade to write to the application log, since it’s kept in the browser and you can easily see what request caused what message to be logged.</p>
<h2 id="database">Database</h2>
<p><img src="/static/images/clockwork3.png" alt="Database tab"></p>
<p>The database tab displays details of the queries made by a request. This is useful for identifying things such as:</p>
<ul>
<li>Repeated queries that should be cached</li>
<li>The n+1 problem (which can be resolved by use of eager loading)</li>
<li>Slow queries that need to be optimised</li>
</ul>
<p>Note that if a particular endpoint does not trigger a query, this tab will not be visible.</p>
<h2 id="cookies">Cookies</h2>
<p><img src="/static/images/clockwork4.png" alt="Cookies tab"></p>
<p>For a REST API, you shouldn’t really have much use for cookies, but if you do, this tab lets you view the cookies set on the request.</p>
<h2 id="session">Session</h2>
<p><img src="/static/images/clockwork5.png" alt="Session tab"></p>
<p>As with cookies, the session isn’t normally something you’d use for an API, but this tab lets you view it.</p>
<h2 id="views">Views</h2>
<p><img src="/static/images/clockwork6.png" alt="Views tab"></p>
<p>This tab shows the views used on the page, and all of the data passed to them.</p>
<h2 id="routes">Routes</h2>
<p><img src="/static/images/clockwork7.png" alt="Routes tab"></p>
<p>This tab shows all of the routes defined within your application.</p>
<p>Clockwork isn’t limited to Laravel - you can also use it with Lumen, Slim 2, and CodeIgniter 2.1, and it’s possible to write your own integration for other frameworks. It’s still fundamentally browser-based, so it’s difficult to use it if your API doesn’t have at least some kind of web front end (whether that’s a single page web app or Phonegap app that consumes the API, or that the API is itself browseable and returns HTML in a web browser), but I’ve found it to be superior to Laravel Debugbar for most of what I do.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Enforcing a coding standard with PHP CodeSniffer]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/03/15/enforcing-a-coding-standard-with-php-codesniffer/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/03/15/enforcing-a-coding-standard-with-php-codesniffer/</guid>
            <pubDate>Wed, 15 Mar 2017 21:37:11 GMT</pubDate>
            <description><![CDATA[<p>We all start new projects with the best of intentions - it’ll be clean, fully tested and work perfectly. Sadly as deadlines loom, it’s all too easy to find yourself neglecting your code quality, and once it starts to degrade, getting it back becomes much harder. Many development teams try to adhere to a coding standard, but it can be hard to enforce on other people - it puts you in the uncomfortable position of nagging others all the time.</p>
<p>Fortunately, there’s an easy solution that doesn’t force everyone to use the same IDE. <a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP CodeSniffer</a> is a useful package that lets you specify a coding standard and then validate your code against it. That way, you can set up continuous integration and use that to remind people of errors. Better still, it also allows many errors to be fixed automatically.</p>
<p>To use it on your PHP project, run the following command:</p>
<pre><code class="lang-bash">$ composer require --dev squizlabs/php_codesniffer 
</code></pre>
<p>As this will only ever be used in development, you should use the <code>--dev</code> flag. We also need to specify the settings for our project. This example is for a module to be used with a Laravel application and should be saved as <code>phpcs.xml</code>:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ruleset name=&quot;PHP_CodeSniffer&quot;&gt;
 &lt;description&gt;The coding standard for our project.&lt;/description&gt;

 &lt;file&gt;app&lt;/file&gt;
 &lt;file&gt;tests&lt;/file&gt;


  &lt;exclude-pattern&gt;*/migrations/*&lt;/exclude-pattern&gt;

 &lt;arg value=&quot;np&quot;/&gt;

&lt;rule ref=&quot;PSR2&quot;/&gt;
&lt;/ruleset&gt;
</code></pre>
<p>Note the <code>&lt;rule /&gt;</code> tag - this specifies that this project should be validated as PSR2. Also, note the <code>&lt;file /&gt;</code> and <code>&lt;exclude-pattern /&gt;</code> tags - these specify what files should and should not be checked.</p>
<p>With this in place, we’re ready to run PHP CodeSniffer:</p>
<pre><code class="lang-bash">$ vendor/bin/phpcs
......................

Time: 45ms; Memory: 6Mb
</code></pre>
<p>In this case, our code validated successfully. However, if it doesn’t, there’s an easy way to tidy it up. Just run this command:</p>
<pre><code class="lang-bash">$ vendor/bin/phpcbf
</code></pre>
<p>That will fix many of the most common problems, and any others should be straightforward to fix.</p>
<p>PHP CodeSniffer makes it extremely straightforward to enforce a coding style. You can write custom rulesets or just use an existing one as you prefer, and it’s easy to fix many common problems automatically. In fact, it makes it so easy that there’s very little excuse <em>not</em> to meet the coding standard.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Decorating Laravel repositories]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/03/01/decorating-laravel-repositories/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/03/01/decorating-laravel-repositories/</guid>
            <pubDate>Wed, 01 Mar 2017 23:16:57 GMT</pubDate>
            <description><![CDATA[<p><a href="/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/">As mentioned previously</a>, when building any nontrivial Laravel application, it’s prudent to decouple our controllers from the Eloquent ORM (or any other ORM or data source we may be using) by creating an interface, and then writing a repository that implements that interface. We can then resolve the interface to our repository, and use the repository to interact with our data source. Should we need to switch to a different implementation, we then need only create the new repository and amend how Laravel resolves that interface.</p>
<p>The same principle applies when it comes to caching. Database queries are typically a major bottleneck in a web application, and so it’s prudent to implement some form of caching for your queries. However, it’s a bad idea to do so in your controllers, because just as with Eloquent models, you’re tying yourself to one particular implementation and won’t be able to switch without rewriting a good chunk of your controllers, as well as possibly having to maintain large amounts of duplicate code for when a query is made in several places.</p>
<p>Alternatively, you could implement caching within the methods of your repository, which might make sense for smaller projects. However, it means that your repository is now dependent on both the ORM and cache you chose. If you decide you want to change your ORM but retain the same caching system, or vice versa, you’re stuck with writing a new repository to handle both, duplicating work you’ve already done.</p>
<p>Fortunately, there’s a more elegant solution. Using the <a href="http://designpatternsphp.readthedocs.io/en/latest/Structural/Decorator/README.html">decorator pattern</a>, we can create a second repository that implements the same interface and “wraps” the original repository. Each of its methods will call its counterpart in the original, and if appropriate cache the response. That way, our caching is implemented separately from our database interactions, and we can easily create a repository for a new data source without affecting the caching in the slightest.</p>
<p>Say we have the following interface for our <code>User</code> model:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories\Interfaces;

interface UserRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>And the following repository implements that interface:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories;

use App\User;
use App\Repositories\Interfaces\UserRepositoryInterface;
use Hash;

class EloquentUserRepository implements UserRepositoryInterface {

    private $model;

    public function __construct(User $model)
    {
        $this-&gt;model = $model;
    }

    public function all()
    {
        return $this-&gt;model-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;model-&gt;findOrFail($id);
    }

    public function create($input)
    {
        $user = new $this-&gt;model;
        $user-&gt;email = $input[&#39;email&#39;];
        $user-&gt;name = $input[&#39;name&#39;];
        $user-&gt;password = Hash::make($input[&#39;password&#39;]);
        $user-&gt;save();
        return $user;
    }
}
</code></pre>
<p>We might implement the following repository class to handle caching:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories\Decorators;

use App\Repositories\Interfaces\UserRepositoryInterface;
use Illuminate\Contracts\Cache\Repository as Cache;

class CachingUserRepository implements UserRepositoryInterface {

    protected $repository;

    protected $cache;

    public function __construct(UserRepositoryInterface $repository, Cache $cache)
    {
        $this-&gt;repository = $repository;
        $this-&gt;cache = $cache;
    }

    public function all()
    {
        return $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;remember(&#39;all&#39;, 60, function () {
            return $this-&gt;repository-&gt;all();
        });
    }

    public function findOrFail($id)
    {
        return $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;remember($id, 60, function () use ($id) {
            return $this-&gt;repository-&gt;findOrFail($id);
        });
    }

    public function create($input)
    {
        $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;flush();
        return $this-&gt;repository-&gt;create($input);
    }
}
</code></pre>
<p>Note how each method doesn’t actually do any querying. Instead, the constructor accepts an implementation of the same interface and the cache, and we defer all interactions with the database to that implementation. Each call that queries the database is wrapped in a callback so that it’s stored in Laravel’s cache when it’s returned, without touching the original implementation. When a user is created, the users tag is flushed from the cache so that stale results don’t get served.</p>
<p>To actually use this implementation, we need to update our service provider so that it resolves the interface to an implementation of our decorator:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;singleton(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;, function () {
            $baseRepo = new \App\Repositories\EloquentUserRepository(new \App\User);
            $cachingRepo = new \App\Repositories\Decorators\CachingUserRepository($baseRepo, $this-&gt;app[&#39;cache.store&#39;]);
            return $cachingRepo;
        });
    }
}
</code></pre>
<p>We instantiate the base repository, passing it the appropriate model. Then we instantiate the decorator, passing it the base repository and the cache, and return it. Now our controllers will start using the new decorator.</p>
<h2 id="testing-the-decorator">Testing the decorator</h2>
<p>Now that we have a working decorator, how do we test it? Just as with the decorator itself, we want our tests to be completely decoupled from any particular implementation of the dependencies. If in future we’re asked to migrate the database to MongoDB, say, we’ll have plenty of work writing our new database repositories, so we don’t want to have to rewrite the tests for our decorator as well. Fortunately, using Mockery we can just mock the interface for the repository, and pass that mock into the constructor of the decorator in our test. That way we can have the mock return a known response and not involve either the database repository or the underlying models in any way.</p>
<p>We will also want to mock the cache itself, as this is a unit test and so as far as possible it should not be testing anything outside of the repository class. Here’s an example of how we might test the above decorator.</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\Repositories\Decorators;

use Tests\TestCase;
use App\Repositories\Decorators\CachingUserRepository;
use Mockery as m;

class UserTest extends TestCase
{
    /**
     * Test fetching all items
     *
     * @return void
     */
    public function testFetchingAll()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;all&#39;)-&gt;andReturn([]);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;users&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;remember&#39;)-&gt;andReturn([]);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $items = $repository-&gt;all();
        $this-&gt;assertCount(0, $items);
    }

    /**
     * Test fetching a single item
     *
     * @return void
     */
    public function testFindOrFail()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;findOrFail&#39;)-&gt;with(1)-&gt;andReturn(null);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;users&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;remember&#39;)-&gt;andReturn(null);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $item = $repository-&gt;findOrFail(1);
        $this-&gt;assertNull($item);
    }

    /**
     * Test creating a single item
     *
     * @return void
     */
    public function testCreate()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;create&#39;)-&gt;with([&#39;email&#39; =&gt; &#39;bob@example.com&#39;])-&gt;andReturn(true);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;usersUser&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;flush&#39;)-&gt;andReturn(true);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $item = $repository-&gt;create([&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);
        $this-&gt;assertTrue($item);
    }

    public function tearDown()
    {
        m::close();
        parent::tearDown();
    }
}
</code></pre>
<p>As you can see, all we care about is that the underlying repository interface receives the correct method calls and arguments, nothing more. That way our test is fast and repository-agnositc.</p>
<h2 id="other-applications">Other applications</h2>
<p>Here I’ve used this technique to cache the queries, but that’s not the only use case for decorating a repository. For instance, you could decorate a repository to fire events when certain methods are called, and write different decorators when reusing these repositories for different applications. You could create one to log interactions with the repository, or you could use an external library to cache your queries, all without touching your existing repository. Should we need to switch back to our base repository, it’s just a matter of amending the service provider accordingly as both the decorator and the repository implement the same interface.</p>
<p>Creating decorators does mean you have to implement all of the interface’s methods again, but if you have a base repository that your other ones inherit from, you can easily create a base decorator in a similar fashion that wraps methods common to all the repositories, and then just implement the additional methods for each decorator as required. Also, each method is likely to be fairly limited in scope so it’s not generally too onerous.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[My first Laravel package]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/02/19/my-first-laravel-package/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/02/19/my-first-laravel-package/</guid>
            <pubDate>Sun, 19 Feb 2017 15:50:11 GMT</pubDate>
            <description><![CDATA[<p>For some time now I’ve had a Laravel middleware I use extensively to add ETags to HTTP requests. I often use it for work projects, but obviously copying and pasting it all the time was a pain. I always meant to create a package for it, but I didn’t want to do so until such time as I had some proper tests for it. Now I’ve finally figured out how to test middleware in isolation and I’ve got around to adding tests and creating a proper package for it.</p>
<p>It’s available on <a href="https://github.com/matthewbdaly/laravel-etag-middleware">Github</a> and <a href="https://packagist.org/packages/matthewbdaly/laravel-etag-middleware">Packagist</a> if you want to use it.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Integrating Behat with Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2017/02/18/integrating-behat-with-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2017/02/18/integrating-behat-with-laravel/</guid>
            <pubDate>Sat, 18 Feb 2017 21:25:57 GMT</pubDate>
            <description><![CDATA[<p>The Gherkin format used by tools like Cucumber is a really great way of specifying how your application will work. It’s easy for even non-technical stakeholders to understand, it makes it natural to break your tests into easily reusable steps, and it encourages you to think about the application from an end-user’s perspective. It’s also one of the easiest ways to get started writing automated tests when you first start out - it’s much more intuitive to a junior developer than lower-level unit tests, and is easier to add to a legacy project that may not have been built with testability in mind - if you can drive a browser, you can test it.</p>
<p><a href="http://behat.org/en/latest/">Behat</a> is a PHP equivalent. Combined with <a href="http://mink.behat.org/en/latest/">Mink</a>, it allows for easy automated acceptance tests of a PHP application. However, out of the box it doesn’t integrate well with Laravel. There is <a href="https://github.com/laracasts/Behat-Laravel-Extension">Jeffrey Way’s Behat Laravel extension</a>, but it doesn’t seem to be actively maintained and seems to be overkill for this purpose. I wanted something that I could use to run integration tests using PHPUnit’s assertions and Laravel’s testing utilities, and crucially, I wanted to do so as quickly as possible. That meant running a web server and using an automated web browser wasn’t an option. Also, I often work on REST API’s, and browser testing isn’t appropriate for those - in API tests I’m more interested in setting up the fixtures, making a single request, and verifying that it does what it’s meant to do, as quickly as possible.</p>
<p>As it turns out, integrating Behat and Laravel isn’t that hard. When using Behat, your <code>FeatureContext.php</code> file must implement the <code>Behat\Behat\Context\Context</code> interface, but as this interface does not implement any methods, you can extend any existing class and declare that it implements that interface. That means we can just extend the existing <code>Tests\TestCase</code> class in Laravel 5.4 and gain access to all the same testing utilities we have in our regular Laravel tests.</p>
<p>Then, in the constructor we can set environment variables using <code>putenv()</code> so that we can set it up to use an in-memory SQLite database for faster tests. We also use the <code>@BeforeScenario</code> hook to migrate the database before each scenario, and the <code>@AfterScenario</code> hook to roll it back afterwards.</p>
<p>Here’s the finished example:</p>
<pre><code class="lang-php">&lt;?php

use Behat\Behat\Context\Context;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;
use Tests\TestCase;
use Behat\Behat\Tester\Exception\PendingException;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use App\User;
use Behat\Behat\Hook\Scope\BeforeScenarioScope;
use Behat\Behat\Hook\Scope\AfterScenarioScope;
use Illuminate\Contracts\Console\Kernel;

/**
 * Defines application features from the specific context.
 */
class FeatureContext extends TestCase implements Context
{
    use DatabaseMigrations;

    protected $content;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context instance.
     * You can also pass arbitrary arguments to the
     * context constructor through behat.yml.
     */
    public function __construct()
    {
        putenv(&#39;DB_CONNECTION=sqlite&#39;);
        putenv(&#39;DB_DATABASE=:memory:&#39;);
        parent::setUp();
    }

    /** @BeforeScenario */
    public function before(BeforeScenarioScope $scope)
    {
        $this-&gt;artisan(&#39;migrate&#39;);

        $this-&gt;app[Kernel::class]-&gt;setArtisan(null);
    }

    /** @AfterScenario */
    public function after(AfterScenarioScope $scope)
    {
        $this-&gt;artisan(&#39;migrate:rollback&#39;);
    }

    /**
     * @Given I visit the path :path
     */
    public function iVisitThePath($path)
    {
        $response = $this-&gt;get(&#39;/&#39;);
        $this-&gt;assertEquals(200, $response-&gt;getStatusCode());
        $this-&gt;content = $response-&gt;getContent();
    }

    /**
     * @Then I should see the text :text
     */
    public function iShouldSeeTheText($text)
    {
        $this-&gt;assertContains($text, $this-&gt;content);
    }

    /**
     * @Given a user called :user exists
     */
    public function aUserCalledExists($user)
    {
        $user = factory(App\User::class)-&gt;create([
            &#39;name&#39; =&gt; $user,
        ]);
    }

    /**
     * @Given I am logged in as :user
     */
    public function iAmLoggedInAs($user)
    {
        $user = User::where(&#39;name&#39;, $user)-&gt;first();
        $this-&gt;be($user);
    }

}
</code></pre>
<p>Note that I’ve added a few basic example methods for our tests. As you can see, we can call the same methods we normally use in Laravel tests to make assertions and HTTP requests. If you’re using Dusk, you can also call that in the same way you usually would.</p>
<p>We might then write the following feature file to demonstrate our application at work:</p>
<pre><code class="lang-gherkin">Feature: Login

    Background:
        Given a user called &quot;Alan&quot; exists
        And a user called &quot;Bob&quot; exists
        And a user called &quot;Clare&quot; exists
        And a user called &quot;Derek&quot; exists
        And a user called &quot;Eric&quot; exists

    Scenario: Log in as Alan
        Given I am logged in as &quot;Alan&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Bob
        Given I am logged in as &quot;Bob&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Clare
        Given I am logged in as &quot;Clare&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Derek
        Given I am logged in as &quot;Derek&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Eric
        Given I am logged in as &quot;Eric&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;
</code></pre>
<p>We can then run these tests with <code>vendor/bin/behat</code>:</p>
<pre><code class="lang-bash">$ vendor/bin/behat 
Feature: Login

  Background:                         # features/auth.feature:3
    Given a user called &quot;Alan&quot; exists # FeatureContext::aUserCalledExists()
    And a user called &quot;Bob&quot; exists    # FeatureContext::aUserCalledExists()
    And a user called &quot;Clare&quot; exists  # FeatureContext::aUserCalledExists()
    And a user called &quot;Derek&quot; exists  # FeatureContext::aUserCalledExists()
    And a user called &quot;Eric&quot; exists   # FeatureContext::aUserCalledExists()

  Scenario: Log in as Alan               # features/auth.feature:10
    Given I am logged in as &quot;Alan&quot;       # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Bob                # features/auth.feature:15
    Given I am logged in as &quot;Bob&quot;        # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Clare              # features/auth.feature:20
    Given I am logged in as &quot;Clare&quot;      # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Derek              # features/auth.feature:25
    Given I am logged in as &quot;Derek&quot;      # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Eric               # features/auth.feature:30
    Given I am logged in as &quot;Eric&quot;       # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

5 scenarios (5 passed)
40 steps (40 passed)
0m0.50s (19.87Mb)
</code></pre>
<p>Higher level tests can get very tedious if you’re not careful - you wind up setting up the same fixtures and making the same requests many times over. By using Behat in this way, not only are you writing your tests in a way that is easy to understand, but you’re also breaking it down into logical, repeatable steps, and by passing arguments in each step you limit the amount of repetition. It’s also fast if you aren’t running browser-based tests, making it particularly well-suited to API testing.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Testing Laravel Middleware]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/11/29/testing-laravel-middleware/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/11/29/testing-laravel-middleware/</guid>
            <pubDate>Tue, 29 Nov 2016 23:00:38 GMT</pubDate>
            <description><![CDATA[<p>It’s widely accepted that high-level integration tests alone do not make for a good test suite. Ideally each individual component of your application should have unit tests, which test that component in isolation. These unit tests are usually much quicker to run, making it easier to practice test-driven development. However, it can sometimes be hard to grasp how to test that one component on its own.</p>
<p>The other day I had an issue with several middleware classes for a Laravel application and I wanted to verify that they were working as expected. Sounds like a job for dedicated unit tests, but I hadn’t tested custom middleware in isolation before, and figuring out how to do so took a while.</p>
<p>Laravel middleware accepts an instance of <code>Illuminate\Http\Request</code>, itself based on the Symfony request object, as well as a closure for the action to take next. Depending on what the middleware does, it may return a redirect or simply amend the existing request or response. So in theory you can instantiate a request object, pass it to the middleware, and check the response. For middleware that does something simple, such as redirecting users based on certain conditions, this is fairly straightforward.</p>
<p>In this example we have a fairly useless piece of middleware that checks to see what the route is for a request and redirects it if it matches a certain pattern:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;

class RedirectFromAdminMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request-&gt;is(&#39;admin*&#39;)) {
            return redirect(&#39;/&#39;);
        }
        return $next($request);
    }
}
</code></pre>
<p>While this example is of limited use, it wouldn’t take much work to develop it to redirect conditionally based on an account type, and it’s simple enough to demonstrate the principles involved. In these tests, we create instances of <code>Illuminate\Http\Request</code> and pass them to the middleware’s <code>handle()</code> method, along with an empty closure representing the response. If the middleware does not amend the request, we get the empty response from the closure. If it does amend the request, we get a redirect response.</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

class RedirectFromAdminMiddlewareTest extends TestCase
{
    public function testRedirectMiddlewareCalledOnAdmin()
    {
        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\RedirectFromAdminMiddleware();
        $response = $middleware-&gt;handle($request, function () {});
        $this-&gt;assertEquals($response-&gt;getStatusCode(), 302);
    }

    public function testRedirectMiddlewareNotCalledOnNonAdmin()
    {
        // Create request
        $request = Request::create(&#39;http://example.com/pages&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\RedirectFromAdminMiddleware();
        $response = $middleware-&gt;handle($request, function () {});
        $this-&gt;assertEquals($response, null);
    }
}
</code></pre>
<p>For middleware that fetches the response and acts on it, things are a little more complex. For instance, this is the Etag middleware I use on many projects:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;

class ETagMiddleware {
    /**
     * Implement Etag support
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        // Get response
        $response = $next($request);
        // If this was a GET request...
        if ($request-&gt;isMethod(&#39;get&#39;)) {
            // Generate Etag
            $etag = md5($response-&gt;getContent());
            $requestEtag = str_replace(&#39;&quot;&#39;, &#39;&#39;, $request-&gt;getETags());
            // Check to see if Etag has changed
            if($requestEtag &amp;&amp; $requestEtag[0] == $etag) {
                $response-&gt;setNotModified();
            }
            // Set Etag
            $response-&gt;setEtag($etag);
        }
        // Send response
        return $response;
    }
}
</code></pre>
<p>This acts on the response object, so we need to pass that through as well. Fortunately, Mockery allows us to create a mock of our response object and set it up to handle only those methods we anticipate being called:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

class ETagMiddlewareTest extends TestCase
{
    /**
     * Test new request not cached
     *
     * @return void
     */
    public function testModified()
    {
        // Create mock response
        $response = Mockery::mock(&#39;Illuminate\Http\Response&#39;)-&gt;shouldReceive(&#39;getContent&#39;)-&gt;once()-&gt;andReturn(&#39;blah&#39;)-&gt;getMock();
        $response-&gt;shouldReceive(&#39;setEtag&#39;)-&gt;with(md5(&#39;blah&#39;));

        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\ETagMiddleware();
        $middlewareResponse = $middleware-&gt;handle($request, function () use ($response) { 
            return $response;
        });
    }

    /**
     * Test repeated request not modified
     *
     * @return void
     */
    public function testNotModified()
    {
        // Create mock response
        $response = Mockery::mock(&#39;Illuminate\Http\Response&#39;)-&gt;shouldReceive(&#39;getContent&#39;)-&gt;once()-&gt;andReturn(&#39;blah&#39;)-&gt;getMock();
        $response-&gt;shouldReceive(&#39;setEtag&#39;)-&gt;with(md5(&#39;blah&#39;));
        $response-&gt;shouldReceive(&#39;setNotModified&#39;);

        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;, [], [], [], [
            &#39;ETag&#39; =&gt; md5(&#39;blah&#39;)
        ]);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\ETagMiddleware();
        $middlewareResponse = $middleware-&gt;handle($request, function () use ($response) { 
            return $response;
        });
    }

    public function teardown()
    {
        Mockery::close();
    }
}
</code></pre>
<p>In the first example we mock out the <code>getContent()</code> and <code>setEtag()</code> methods of our response to make sure they get called, and then pass the request to the middleware, along with a closure that returns the response. In the second example, we also mock out <code>setNotModified()</code> to ensure that the correct status code of 304 is set, and add an ETag to our request. In this way we can easily test our middleware in isolation, rather than having to resort to building up our entire application just to test one small method.</p>
<p>Middleware is a convenient place to put functionality that’s needed for many routes, but you shouldn’t neglect testing it, and ideally you shouldn’t have to resort to writing a slow integration test to test it works as expected. By mocking out your dependencies, it’s generally not too hard to test it in isolation, resulting in faster and more robust test suites.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Easy static asset versioning in PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/11/26/easy-static-asset-versioning-in-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/11/26/easy-static-asset-versioning-in-php/</guid>
            <pubDate>Sat, 26 Nov 2016 21:40:39 GMT</pubDate>
            <description><![CDATA[<p>It’s prudent to cache static assets such as images, Javascript and CSS to improve performance, but that raises the issue of changes not being reflected in your site due to visitor’s browsers retaining the cached versions. Many content management systems and frameworks already handle this for you (such as Laravel’s Elixir build system), but what if you have to work with a legacy application that doesn’t do this?</p>
<p>Fortunately there’s a quite easy solution in PHP. Using the <code>filemtime()</code> function described <a href="http://php.net/manual/en/function.filemtime.php">here</a>, we can get a Unix timestamp for when a file was last altered. This is perfect to use to identify when a file last changed, because by appending a new query string to the file name when loading it, we can trick the browser into thinking it’s a new file when it’s not, as in this example for a CodeIgniter application:</p>
<pre><code class="lang-php">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;?=$path?&gt;?v=&lt;?=filemtime($path)?&gt;&quot;&gt;
</code></pre>
<p>   Obviously, this is a bit repetitive, so you may want to refactor this into some kind of template helper to make it easier to use, but the underlying principle applies to most programming languages. For instance, if you wanted to do so in a Handlebars template, you might want to create a helper something like this:</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);
var Handlebars = require(&#39;handlebars&#39;);
Handlebars.registerHelper(&#39;version&#39;, function (path) {
   return path + &#39;?v=&#39; + fs.statSync(path).mtime.getTime();
});
</code></pre>
<p>Where more robust solutions such as Elixir are already available, I’d advise making full use of them. However, this technique is a quick and easy way to implement versioning for static assets in existing projects.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a Phonegap App with Laravel and Angular - Part 4]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/</guid>
            <pubDate>Sun, 13 Nov 2016 16:15:00 GMT</pubDate>
            <description><![CDATA[<p>In this instalment we’ll return to the back end. What we’ve done so far is typical of the kind of proof of concept we might do for a client early on, before going back and implementing the full set of features later on. Now we’ll go back and start to improve on that rather quick-and-dirty API by making sure we follow a few best practices.</p>
<p>For those of you who want to follow the Laravel Phonegap tutorials, I’ve created a dedicated category <a href="/blog/categories/laravel-phonegap-tutorial/">here</a> for those tutorials. This category include RSS and Atom feeds, so if you only want to read those posts, you can do so. I’ve also done the same for the <a href="/blog/categories/django-blog-tutorial/">Django tutorials</a>.</p>
<h2 id="the-repository-pattern">The Repository pattern</h2>
<p>One of the issues we currently have with our API is that we’re passing our Eloquent models into our controllers. This may not seem like a huge issue, but it means that our controllers are tightly coupled to the Eloquent ORM, so if we wanted to switch to another ORM, or to a completely different database such as MongoDB, we’d have to amend our controllers. That’s not good.</p>
<p>However, using the <a href="http://designpatternsphp.readthedocs.io/en/latest/More/Repository/README.html">Repository pattern</a> we can first of all define an interface for our repository, and then create a repository class that implements that interface. That way we can interact with the repository class in our controllers, rather than using Eloquent models directly. Then, if we want to switch databases, we merely amend the repository class to change the implementation of those methods, without having to touch our controllers. Also, it makes it much easier to test our controllers in isolation, because we can easily mock our repository class using Mockery and hard-code the response, so our tests won’t touch the database and will therefore run more quickly. We won’t touch on that this time, but it’s a very significant advantage.</p>
<p>If you haven’t used interfaces before in PHP, they aren’t that hard. They merely specify what methods an object implementing that method must have and what arguments they must accept, but do not specify the details of the implementation. This makes it easy to determine if a class implements an interface correctly, because it will throw an exception if it doesn’t.</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories\Interfaces;

interface PetRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>That’s all there is to it. We define it using the <code>interface</code> keyword and we specify the methods it must implement. Save this file at <code>app/Repositories/Interfaces/PetRepositoryInterface.php</code>.</p>
<p>Next, we implement the repository class:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories;

use AnimalFriend\Pet;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface;

class EloquentPetRepository implements PetRepositoryInterface {

    private $pet;

    public function __construct(Pet $pet)
    {
        $this-&gt;pet = $pet;
    }

    public function all()
    {
        return $this-&gt;pet-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;pet-&gt;findOrFail($id);
    }

    public function create($input)
    {
        return $this-&gt;pet-&gt;create($input);
    }
}
</code></pre>
<p>Save this to <code>app/Repositories/EloquentPetRepository.php</code>. Note how the methods closely mirror the underlying Eloquent methods, but they don’t need to - you could change the underlying implementation of each method, but the repository would still work in exactly the same way.</p>
<p>To make this work, we need to make a few changes elsewhere. In <code>composer.json</code>, we need to add the new <code>Repositories</code> folder to our classmap:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;classmap&quot;: [
            &quot;database&quot;,
            &quot;app/Repositories&quot;
        ],
        &quot;psr-4&quot;: {
            &quot;AnimalFriend\\&quot;: &quot;app/&quot;
        }
    },
</code></pre>
<p>And in <code>app/Providers/AppServiceProvider.php</code>, we need to bind our new files:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\PetRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentPetRepository&#39;
        );
    }
}
</code></pre>
<p>With that done, we can now update <code>app/Http/Controllers/PetController.php</code> to use the repository:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface as Pet;

class PetController extends Controller
{
    private $pet;

    public function __construct(Pet $pet) {
        $this-&gt;pet = $pet;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;all();

        // Send response
        return response()-&gt;json($pets, 200);
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($pet, 200);
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>Our repository is now injected automatically into the controller. To make this work we need to run the following command:</p>
<pre><code class="lang-bash">$ composer dump-autoload
</code></pre>
<p>Running our tests should confirm that everything is still working:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.
............                                                      12 / 12 (100%)

Time: 897 ms, Memory: 18.00MB

OK (12 tests, 46 assertions)
</code></pre>
<p>Let’s do the same for the User model. First we implement our interface in <code>app/Repositories/Interfaces/UserRepositoryInterface.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories\Interfaces;

interface UserRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>Next we create our repository at <code>app/Repositories/EloquentUserRepository.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories;

use AnimalFriend\User;
use AnimalFriend\Repositories\Interfaces\UserRepositoryInterface;
use JWTAuth;
use Hash;

class EloquentUserRepository implements UserRepositoryInterface {

    private $user;

    public function __construct(User $user)
    {
        $this-&gt;user = $user;
    }

    public function all()
    {
        return $this-&gt;user-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;user-&gt;findOrFail($id);
    }

    public function create($input)
    {
        $user = new $this-&gt;user;
        $user-&gt;email = $input[&#39;email&#39;];
        $user-&gt;name = $input[&#39;name&#39;];
        $user-&gt;password = Hash::make($input[&#39;password&#39;]);
        $user-&gt;save();

        // Create token
        return JWTAuth::fromUser($user);
    }
}
</code></pre>
<p>Note how we’ve moved much of the logic for creating a user into the <code>create()</code> method, and we return the token, not the user model. This makes sense as right now we only ever want to get a token back when we create a user. Later that may change, but there’s nothing stopping us adding a new method to implement that behaviour alongside this.</p>
<p>Then we update <code>app/Http/Controllers/UserController.php</code> to use our repository:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\UserRepositoryInterface as User;
use JWTAuth;
use Hash;

class UserController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39;,
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;password&#39; =&gt; &#39;required|confirmed&#39;
        ]);

        // Create token
        $token = $this-&gt;user-&gt;create($request-&gt;only(
            &#39;email&#39;,
            &#39;name&#39;,
            &#39;password&#39;
        ));

        // Send response
        return response()-&gt;json([&#39;token&#39; =&gt; $token], 201);
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>And add a new binding in <code>app/Providers/AppServiceProvider.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\PetRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentPetRepository&#39;
        );
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\UserRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentUserRepository&#39;
        );
    }
}
</code></pre>
<p>Note that we bind the two sets separately - this allows Laravel to figure out which one maps to which.</p>
<p>Let’s run our tests to make sure nothing is broken:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 956 ms, Memory: 18.00MB

OK (12 tests, 46 assertions)
</code></pre>
<p>Now that we’ve got our repositories in place, we’re no longer tightly coupled to Eloquent, and have a more flexible implementation which is easier to test.</p>
<h2 id="separating-our-models-from-our-json-with-fractal">Separating our models from our JSON with Fractal</h2>
<p>Another problem with our API is that our representation of our data is tightly coupled to our underlying implementation of our models. We therefore can’t change our models without potentially changing the data returned by the API. We need to separate our representation of our data from our actual model so that we can more easily specify the exact data we want to return, regardless of the underlying database structure.</p>
<p>Enter <a href="http://fractal.thephpleague.com/">Fractal</a>. From the website:</p>
<blockquote>
<p>Fractal provides a presentation and transformation layer for complex data output, the like found in RESTful APIs, and works really well with JSON. Think of this as a view layer for your JSON/YAML/etc.</p>
</blockquote>
<p>In other words, Fractal lets you specify the format your data will take in one place so that it’s easier to return that data in a desired format. We’ll use Fractal to specify how we want our API responses to be formatted.</p>
<p>Install Fractal with the following command:</p>
<pre><code class="lang-php">$ composer require league/fractal
</code></pre>
<p>Then amend the classmap in <code>composer.json</code>:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;classmap&quot;: [
            &quot;database&quot;,
            &quot;app/Repositories&quot;,
            &quot;app/Transformers&quot;
        ],
        &quot;psr-4&quot;: {
            &quot;AnimalFriend\\&quot;: &quot;app/&quot;
        }
    },
</code></pre>
<p>Then create the folder <code>app/Transformers</code> and run <code>composer dump-autoload</code>. We’re now ready to write our first transformer. Save this as <code>app/Transformers/PetTransformer.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Transformers;

use AnimalFriend\Pet;
use League\Fractal;

class PetTransformer extends Fractal\TransformerAbstract
{
    public function transform(Pet $pet)
    {
        return [
            &#39;id&#39;            =&gt; (int) $pet-&gt;id,
            &#39;name&#39;          =&gt; (string) $pet-&gt;name,
            &#39;type&#39;          =&gt; (string) $pet-&gt;type,
            &#39;available&#39;     =&gt; (bool) $pet-&gt;available,
            &#39;picture&#39;       =&gt; (string) $pet-&gt;picture
        ];
    }
}
</code></pre>
<p>The <code>transform</code> method specifies how we want to represent our objects with our API. We can return only those attributes we want to expose, and amend the structure as we see fit. We could easily represemt relations in whatever manner we see fit, whereas before we needed to amend our queries to return the data in the right format, which would potentially be cumbersome.</p>
<p>Now let’s amend <code>PetController.php</code> to use this:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface as Pet;
use AnimalFriend\Transformers\PetTransformer;
use League\Fractal;
use League\Fractal\Manager;

class PetController extends Controller
{
    private $pet, $fractal;

    public function __construct(Pet $pet, Manager $fractal) {
        $this-&gt;pet = $pet;
        $this-&gt;fractal = $fractal;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;all();

        // Format it
        $resource = new Fractal\Resource\Collection($pets, new PetTransformer);
        $data = $this-&gt;fractal-&gt;createData($resource)-&gt;toArray();

        // Send response
        return response()-&gt;json($data, 200);
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Format it
        $resource = new Fractal\Resource\Item($pet, new PetTransformer);
        $data = $this-&gt;fractal-&gt;createData($resource)-&gt;toArray();

        // Send response
        return response()-&gt;json($data, 200);
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>Note that by default, Fractal places our data inside a dedicated <code>data</code> namespace. This is good because it leaves a place for us to put metadata such as pagination links, but it does mean our controller test has been broken. Let’s fix it:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class PetControllerTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test fetching pets when unauthorised
     *
     * @return void
     */
    public function testFetchingPetsWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets&#39;);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pets when authorised
     *
     * @return void
     */
    public function testFetchingPets()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets&#39;, [], $headers)
            -&gt;seeJsonStructure([
                &#39;data&#39; =&gt; [
                    &#39;*&#39; =&gt; [
                        &#39;id&#39;,
                        &#39;name&#39;,
                        &#39;type&#39;,
                        &#39;available&#39;,
                        &#39;picture&#39;
                    ]
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }

    /**
     * Test fetching pet when unauthorised
     *
     * @return void
     */
    public function testFetchingPetWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Send request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pet which does not exist
     *
     * @return void
     */
    public function testFetchingPetDoesNotExist()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/1&#39;, [], $headers);
        $this-&gt;assertResponseStatus(404);
    }

    /**
     * Test fetching pet when authorised
     *
     * @return void
     */
    public function testFetchingPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id, [], $headers)
            -&gt;seeJsonStructure([
                &#39;data&#39; =&gt; [
                    &#39;id&#39;,
                    &#39;name&#39;,
                    &#39;type&#39;,
                    &#39;available&#39;,
                    &#39;picture&#39;
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }
}
</code></pre>
<p>We’re also going to amend our test settings to use the array backend for the cache, as this does not require any external dependencies, but still allows us to tag our cache keys (I’ll cover that in a future instalment). Change the cache settings in <code>phpunit.xml</code> as follows:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;
</code></pre>
<p>Let’s run our tests to make sure everything’s fine:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 859 ms, Memory: 18.00MB

OK (12 tests, 44 assertions)
</code></pre>
<p>At present our <code>User</code> controller doesn’t actually return anything, and the auth only ever returns the token, so it’s not worth while adding a transformer now.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>That ends this lesson. We haven’t added any functionality, but we have improved the design of our API, and we’re now ready to develop it further. As usual, the backend repository has been tagged as <code>lesson-4</code>.</p>
<p>Next time we’ll start adding the additional functionality we need to our API.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Creating an Azure storage adapter for Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</guid>
            <pubDate>Sun, 23 Oct 2016 23:25:27 GMT</pubDate>
            <description><![CDATA[<p>UPDATE: This post has now been superseded by <a href="/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/">this one</a> as I’ve released this integration as a package.</p>
<p>About a year ago I was working on my first non-trivial Laravel application. The client had, for their own reasons, wanted to use Microsoft’s Azure platform, particularly for its blob storage functionality, which is somewhat comparable to Amazon S3. Now, Laravel has the excellent <code>Storage</code> facade  that allows consistent access to both local files and those stored on various file hosting services, which is built on top of <a href="https://flysystem.thephpleague.com/">Flysystem</a>. Flysystem has an Azure driver, but the Laravel storage doesn’t include support for it, so at the time I resigned myself to using Flysystem directly, which wasn’t actually that bad, but not ideal.</p>
<p>A few days ago I stumbled across <a href="https://laravel.com/docs/5.1/filesystem#custom-filesystems">this section of the Laravel documentation</a>, which had me kicking myself. It’s actually trivially easy to implement a custom filesystem for Laravel if it already has a Flysystem adapter, as demonstrated in their Dropbox implementation in the docs. Using this as a guide, I was able to produce the following service provider for using Azure as a storage backend very quickly:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Storage;
use League\Flysystem\Filesystem;
use Illuminate\Support\ServiceProvider;
use League\Flysystem\Azure\AzureAdapter;
use WindowsAzure\Common\ServicesBuilder;

class AzureStorageServiceProvider extends ServiceProvider
{
    /**
     * Perform post-registration booting of services.
     *
     * @return void
     */
    public function boot()
    {
        Storage::extend(&#39;azure&#39;, function($app, $config) {
            $endpoint = sprintf(
                &#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=%s&#39;,
                $config[&#39;name&#39;],
                $config[&#39;key&#39;]
            );

            $blobRestProxy = ServicesBuilder::getInstance()-&gt;createBlobService($endpoint);
            return new Filesystem(new AzureAdapter($blobRestProxy, $config[&#39;container&#39;]));
        });
    }

    /**
     * Register bindings in the container.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
</code></pre>
<p>This should be saved as <code>app/Providers/AzureStorageServiceProvider.php</code>. You also need to add this to the list of service providers in <code>config/app.php</code>:</p>
<pre><code class="lang-php">        App\Providers\AzureStorageServiceProvider::class,
</code></pre>
<p>And add this to <code>config/filesystems.php</code>:</p>
<pre><code class="lang-php">        &#39;azure&#39; =&gt; [
            &#39;driver&#39;    =&gt; &#39;azure&#39;,
            &#39;name&#39;      =&gt; env(&#39;STORAGE_NAME&#39;),
            &#39;key&#39;       =&gt; env(&#39;STORAGE_KEY&#39;),
            &#39;container&#39; =&gt; env(&#39;STORAGE_CONTAINER&#39;),
        ],
</code></pre>
<p>I like to also set my storage backend using environment variables in this file, as in this example:</p>
<pre><code class="lang-php">    &#39;default&#39; =&gt; env(&#39;STORAGE_BACKEND&#39;, &#39;local&#39;),
</code></pre>
<p>That way we can easily set a different backend for testing, development and production so we don’t upload files when running PHPUnit. You can also keep your other config settings in your <code>.env</code> file, which is always a better idea than keeping it under version control. You also need to install the <code>microsoft/windowsazure</code> and <code>league/flysystem-azure</code> packages via Composer for this to work.</p>
<p>As I’ve since changed jobs it’s unlikely I’ll ever actually use this Azure integration in production - it’s not a service I’d choose of my own accord to use. However, since it’s so straightforward to implement an adapter like this I imagine I may be doing something similar - I’m currently working on a web app that uses MongoDB for some of its data and currently stores files locally, so it might make sense to create a GridFS integration along similar lines. It may also be useful for someone else, so feel free to use it if you wish.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a Phonegap app with Laravel and Angular - Part 3]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/10/16/building-a-phonegap-app-with-laravel-and-angular-part-3/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/10/16/building-a-phonegap-app-with-laravel-and-angular-part-3/</guid>
            <pubDate>Sun, 16 Oct 2016 17:10:13 GMT</pubDate>
            <description><![CDATA[<p>Apologies for how long it’s taken for this post to appear. I’ve got a lot on my plate at present as I recently started a new job, so I haven’t been able to devote as much time to this series as I’d like.</p>
<p>In this instalment we’ll begin extending our app beyond the basic authentication we’ve already implemented. We’ll start by adding the means to sign up, before adding the list of pets.</p>
<h2 id="adding-a-signup-method-to-our-backend">Adding a signup method to our backend</h2>
<p>We’ll create a controller for our users in the Laravel backend. First we’ll create our tests:</p>
<pre><code class="lang-bash">$ php artisan make:test UserControllerTest
</code></pre>
<p>We’ll create three tests. The first will check to see that an invalid request raises the correct status code (422). The second will check that a valid request returns the correct status code (201) and creates the user. The third will check that trying to create a duplicate user raises an error. Here they are - they should be saved in the new <code>tests/UserControllerTest.php</code> file:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class UserControllerTest extends TestCase
{
    /**
     * Test creating a user - invalid
     *
     * @return void
     */
    public function testPostingInvalidUser()
    {
        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(422);
    }

    /**
     * Test creating a user
     *
     * @return void
     */
    public function testPostingUser()
    {
        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
            &#39;password_confirmation&#39; =&gt; &#39;password&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(201);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Check user exists
        $saved = User::first();
        $this-&gt;assertEquals($saved-&gt;email, &#39;bob@example.com&#39;);
        $this-&gt;assertEquals($saved-&gt;name, &#39;Bob Smith&#39;);
    }

    /**
     * Test creating a duplicate user
     *
     * @return void
     */
    public function testPostingDuplicateUser()
    {
        // Create user
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
            &#39;password_confirmation&#39; =&gt; &#39;password&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(422);
    }
}
</code></pre>
<p>Note the use of <code>$this-&gt;json()</code> to make the request. This method is ideal for testing a REST API.</p>
<p>Running our tests should confirm that they fail:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

........FFF.                                                      12 / 12 (100%)

Time: 827 ms, Memory: 18.00MB

There were 3 failures:

1) UserControllerTest::testPostingInvalidUser
Expected status code 422, got 404.
Failed asserting that 404 matches expected 422.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:21

2) UserControllerTest::testPostingUser
Expected status code 201, got 404.
Failed asserting that 404 matches expected 201.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:39

3) UserControllerTest::testPostingDuplicateUser
Expected status code 422, got 404.
Failed asserting that 404 matches expected 422.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:71

FAILURES!
Tests: 12, Assertions: 43, Failures: 3.
</code></pre>
<p>Next, we create our new controller:</p>
<pre><code class="lang-bash">$ php artisan make:controller UserController --resource
</code></pre>
<p>Let’s populate it:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\User;
use JWTAuth;
use Hash;

class UserController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39;,
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;password&#39; =&gt; &#39;required|confirmed&#39;,
        ]);

        // Create user
        $user = new $this-&gt;user;
        $user-&gt;email = $request-&gt;input(&#39;email&#39;);
        $user-&gt;name = $request-&gt;input(&#39;name&#39;);
        $user-&gt;password = Hash::make($request-&gt;input(&#39;password&#39;));
        $user-&gt;save();

        // Create token
        $token = JWTAuth::fromUser($user);

        // Send response
        return response()-&gt;json([&#39;token&#39; =&gt; $token], 201);
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>For now we’ll leave the other methods blank, but we’ll be using them later so we won’t get rid of them. At the top, note we load not only the <code>User</code> model, but also the <code>JWTAuth</code> and <code>Hash</code> facades. We use <code>JWTAuth::fromUser()</code> to return a JSON web token for the given user model.</p>
<p>In the <code>store()</code> method we first of all use <a href="https://laravel.com/docs/5.3/validation">Laravel’s validation support</a> to validate our input. We specify that the user must provide a unique email address, a username, and a password, which must be confirmed. Note that we don’t need to specify an action if the request is invalid, as Laravel will do that for us. Also, note that the <code>confirmed</code> rule means that the <code>password</code> field must be accompanied by a matching <code>password_confirmation</code> field.</p>
<p>Next, we create the user. Note that we hash the password before storing it, which is a best practice (storing passwords in plain text is a REALLY bad idea!). Then we create the token for the new user and return it. From then on, the user can use that token to authenticate their requests.</p>
<p>We also need to add this route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">Route::resource(&#39;users&#39;, &#39;UserController&#39;);
</code></pre>
<p>Let’s check the test passes:</p>
<pre><code class="lang-php">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 905 ms, Memory: 20.00MB

OK (12 tests, 46 assertions)
</code></pre>
<h2 id="building-the-registration-in-the-app">Building the registration in the app</h2>
<p>With registration in place on the server side, we can move back to the app. We need to create another route for the registration form. Add this to <code>test/routes.spec.js</code>:</p>
<pre><code class="lang-javascript">  it(&#39;should map register route to register controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/register&#39;].controller).toBe(&#39;RegisterCtrl&#39;);
      expect($route.routes[&#39;/register&#39;].templateUrl).toEqual(&#39;templates/register.html&#39;);
    });
  });
</code></pre>
<p>Running the tests should confirm that this fails. So next you should add this to the route provider section of <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">  .when(&#39;/register&#39;, {
    templateUrl: &#39;templates/register.html&#39;,
    controller: &#39;RegisterCtrl&#39;
  })
</code></pre>
<p>We also need to allow the register path to be accessed when not logged in:</p>
<pre><code class="lang-javascript">.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39; &amp;&amp; $location.path() !== &#39;/register&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])
</code></pre>
<p>Our next step is to create a service representing the <code>User</code> endpoint. Here’s the test for it:</p>
<pre><code class="lang-javascript">  describe(&#39;User service&#39;, function () {
    var mockBackend, User;

    beforeEach(inject(function (_User_, _$httpBackend_) {
      User = _User_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can create a new user&#39;, function () {
      mockBackend.expectPOST(&#39;http://localhost:8000/api/users&#39;, &#39;{&quot;email&quot;:&quot;bob@example.com&quot;,&quot;name&quot;:&quot;bobsmith&quot;,&quot;password&quot;:&quot;password&quot;,&quot;password_confirmation&quot;:&quot;password&quot;}&#39;).respond({token: &#39;mytoken&#39;});
      var user = new User({
        email: &#39;bob@example.com&#39;,
        name: &#39;bobsmith&#39;,
        password: &#39;password&#39;,
        password_confirmation: &#39;password&#39;
      });
      user.$save(function (response) {
        expect(response).toEqualData({token: &#39;mytoken&#39;});
      });
      mockBackend.flush();
    });
  });
</code></pre>
<p>We’re only interested in using this model to create new users at this point, so this is the full scope of this test for now. Make sure the test fails, then we’re ready to create the new service in <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">.factory(&#39;User&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/users/:id&#39;, null, {
    &#39;update&#39;: { method: &#39;PATCH&#39; }
  });
})
</code></pre>
<p>Note that <code>angular-resource</code> does not support the <code>PUT</code> or <code>PATCH</code> methods by default, but as shown here it’s easy to implement it ourselves. That should be sufficient to make our test pass.</p>
<p>Next, we need to create the controller for registration. Here’s the test for it:</p>
<pre><code class="lang-javascript">  describe(&#39;Register Controller&#39;, function () {
    var mockBackend, scope;

    beforeEach(inject(function ($rootScope, $controller, _$httpBackend_) {
      mockBackend = _$httpBackend_;
      scope = $rootScope.$new();
      $controller(&#39;RegisterCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test doRegister is defined
    it(&#39;should define the register method&#39;, function () {
      expect(scope.doRegister).toBeDefined();
    });

    // Test doRegister works
    it(&#39;should allow the user to register&#39;, function () {
      // Mock the backend
      mockBackend.expectPOST(&#39;http://localhost:8000/api/users&#39;, &#39;{&quot;email&quot;:&quot;user@example.com&quot;,&quot;name&quot;:&quot;bobsmith&quot;,&quot;password&quot;:&quot;password&quot;,&quot;password_confirmation&quot;:&quot;password&quot;}&#39;).respond({token: 123});

      // Define login data
      scope.credentials = {
        email: &#39;user@example.com&#39;,
        name: &quot;bobsmith&quot;,
        password: &#39;password&#39;,
        password_confirmation: &#39;password&#39;
      };

      //  Submit the request
      scope.doRegister();

      // Flush the backend
      mockBackend.flush();

      // Check login complete
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(&#39;Bearer 123&#39;);
    });
  });
</code></pre>
<p>Make sure the test fails before proceeding. Our <code>RegisterCtrl</code> is very similar to the login controller:</p>
<pre><code class="lang-javascript">.controller(&#39;RegisterCtrl&#39;, function ($scope, $location, User, Auth) {
  $scope.doRegister = function () {
    var user = new User($scope.credentials);
    user.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})
</code></pre>
<p>Check the tests pass,and we’re ready to move on to creating our HTML template. Save this as <code>www/templates/register.html</code>:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Username&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.name&quot; type=&quot;text&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Confirm Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password_confirmation&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doRegister()&quot;&gt;Submit&lt;/md-button&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; href=&quot;/login&quot;&gt;Log in&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>It’s very similar to our login template. Speaking of which, we need to add a link to this route there:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot; /&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot; /&gt;
        &lt;/md-input-container&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doLogin()&quot;&gt;Submit&lt;/md-button&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; href=&quot;register&quot;&gt;Register&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>With that done, you should now be able to run the Gulp server for the app with <code>gulp</code> and the Laravel backend with <code>php artisan serve</code> and create a new user account.</p>
<h2 id="adding-pets-to-the-home-page">Adding pets to the home page</h2>
<p>Our final task for this lesson is to display a list of pets on the home page. Later we’ll refine that functionality, but for now we’ll just get a list of all current pets and display them. First we need to write a test for our <code>Pet</code> service:</p>
<pre><code class="lang-javascript">  describe(&#39;Pet service&#39;, function () {
    var mockBackend, Pet;

    beforeEach(inject(function (_Pet_, _$httpBackend_) {
      Pet = _Pet_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can fetch pets&#39;, function () {
      mockBackend.expectGET(&#39;http://localhost:8000/api/pets&#39;).respond([{id:1,name:&quot;Freddie&quot;,type:&quot;Cat&quot;}]);
      expect(Pet).toBeDefined();
      var pets = Pet.query();
      mockBackend.flush();
      expect(pets).toEqualData([{id: 1,name:&quot;Freddie&quot;,type:&quot;Cat&quot;}]);
    });
  });
</code></pre>
<p>Once you know that fails, it’s time to implement the service:</p>
<pre><code class="lang-javascript">.factory(&#39;Pet&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/pets/:id&#39;, null, {
    &#39;update&#39;: { method: &#39;PATCH&#39; }
  });
})
</code></pre>
<p>Next, we want to add the pets to the scope of the home controller. Amend the test for it as follows:</p>
<pre><code class="lang-javascript">  describe(&#39;Home Controller&#39;, function () {
    var pets, scope;

    beforeEach(inject(function ($rootScope, $controller, Pet) {
      pets = Pet;
      scope = $rootScope.$new();
      $controller(&#39;HomeCtrl&#39;, {
        $scope: scope,
        pets: [{id:1},{id:2}]
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test pets
    it(&#39;should define the pets&#39;, function () {
      expect(scope.pets).toEqualData([{id: 1}, {id: 2}]);
    });
  });
</code></pre>
<p>We check to see if the scope contains the <code>pets</code> variable. Once you have a failing test, amend the home controller as follows:</p>
<pre><code class="lang-javascript">.controller(&#39;HomeCtrl&#39;, function ($scope, Pet, pets) {
  $scope.pets = pets;
});
</code></pre>
<p>We could fetch the via AJAX inside the controller, but there’s a better way. We’ll create a loader for the pet data and have it resolve that before the page is displayed. To do so, first we need to add the loader service to <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">.factory(&#39;PetsLoader&#39;, [&#39;Pet&#39;, &#39;$q&#39;, function (Pet, $q) {
  return function () {
    var delay = $q.defer();
    Pet.query(function (response) {
      delay.resolve(response);
    }, function () {
      delay.reject(&#39;Unable to fetch pets&#39;);
    });
    return delay.promise;
  };
}])
</code></pre>
<p>Then we set that route up to resolve it in <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;,
    resolve: {
      pets: [&#39;PetsLoader&#39;, function (PetsLoader) {
        return PetsLoader();
      }]
    }
  })
</code></pre>
<p>Now, when we load that route, it will first of all fetch those pets and populate <code>$scope.pets</code> with them.</p>
<p>Now, we need to have some pets in the database, so we’ll make a seeder for it. Head back to the backend and run this command:</p>
<pre><code class="lang-bash">$ php artisan make:seeder PetTableSeeder
</code></pre>
<p>Then amend the file at <code>database/seeds/PetTableSeeder.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class PetTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add Pets
        DB::table(&#39;pets&#39;)-&gt;insert([[
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
            &#39;available&#39; =&gt; 1,
            &#39;picture&#39;   =&gt; &#39;https://placekitten.com/300/300&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ], [
            &#39;name&#39; =&gt; &#39;Sophie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
            &#39;available&#39; =&gt; 1,
            &#39;picture&#39;   =&gt; &#39;https://placekitten.com/300/300&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ]]);
    }
}
</code></pre>
<p>And we need to update <code>database/seeds/DatabaseSeeder.php</code> to call our seeder:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(UserTableSeeder::class);
        $this-&gt;call(PetTableSeeder::class);
    }
}
</code></pre>
<p>For now we’ll use placeholder images, but at a later point our backend will be set up to use images uploaded from the admin. Then we need to refresh our migrations and apply the seeders:</p>
<pre><code class="lang-bash">$ php artisan migrate:refresh
$ php artisan db:seed
</code></pre>
<p>Now we just need to amend our home template to show the pets and we’re done for today:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;/logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;

&lt;div layout=&quot;column&quot; flex=&quot;grow&quot; layout-align=&quot;center stretch&quot;&gt;
    &lt;md-card md-theme=&quot;default&quot; ng-repeat=&quot;pet in pets&quot;&gt;
        &lt;md-card-title&gt;
            &lt;md-card-title-text&gt;
                &lt;span class=&quot;md-headline&quot;&gt;{{ pet.name }}&lt;/span&gt;
                &lt;span class=&quot;md-subhead&quot;&gt;{{ pet.type }}&lt;/span&gt;
            &lt;/md-card-title-text&gt;
        &lt;/md-card-title&gt;
        &lt;md-card-content&gt;
            &lt;img class=&quot;md-card-image md-media-lg&quot; ng-src=&quot;{{ pet.picture }}&quot;&gt;&lt;/img&gt;
        &lt;/md-card-content&gt;
    &lt;/md-card&gt;
&lt;/div&gt;
</code></pre>
<p>Now we can see our pets in the app.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>That’s enough for today - the fact that we can log in and out, register, and view the home page is sufficient as a proof of concept for a client. As usual, the results are on Github, tagged <code>lesson-3</code>. </p>
<p>Next time, we’ll concentrate exclusively on the back end. We’ll build upon what we already have using Laravel to create a full REST API for our app. In a later instalment, we’ll move on to build our admin interface for the staff, before switching back to finish off the app. I hope you’ll join me then.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a Phonegap app with Laravel and Angular - Part 2]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/09/18/building-a-phonegap-app-with-laravel-and-angular-part-2/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/09/18/building-a-phonegap-app-with-laravel-and-angular-part-2/</guid>
            <pubDate>Sun, 18 Sep 2016 22:18:06 GMT</pubDate>
            <description><![CDATA[<p>In this lesson, the initial scope of the app will be extremely simple. We will implement functionality that:</p>
<ul>
<li>Allows users to log in and out</li>
<li>Displays the home page</li>
</ul>
<p>That’s fairly simple, and easily achievable within a fairly short timeframe. We’ll also write automated tests for our app. By the end of this lesson, we’ll have built a first pass for our app using Angular.js.</p>
<p>NOTE: As at time of writing, Angular 2 has just come out. I’m using Angular 1 here, and the two are not compatible, so make sure you’re using Angular 1.</p>
<h2 id="creating-our-app">Creating our app</h2>
<p>Start by creating a new folder, separate from the backend, for the app. Then, in there, run the following command:</p>
<pre><code class="lang-bash">$ npm init -y
</code></pre>
<p>Then let’s install our dependencies:</p>
<pre><code class="lang-bash">$ npm install --save-dev gulp karma karma-browserify karma-phantomjs-launcher browserify angular angular-route angular-mocks angular-animate angular-messages angular-sanitize angular-material angular-resource vinyl-buffer vinyl-source-stream gulp-sass karma-coverage karma-jasmine jasmine-core gulp-webserver
</code></pre>
<p>We’re going to use <a href="https://material.angularjs.org/latest/">Angular Material</a> for our user interface as it includes support out of the box for swiping left and right. You’ll notice it mentioned as one of the dependencies above.</p>
<p>We’ll also use Karma for running our tests. Save the following as <code>karma.conf.js</code>:</p>
<pre><code class="lang-javascript">module.exports = function(config) {
    config.set({
        basePath: &#39;&#39;,
        frameworks: [&#39;browserify&#39;, &#39;jasmine&#39;],
        files: [
            &#39;node_modules/angular/angular.min.js&#39;,
            &#39;node_modules/angular-mocks/angular-mocks.js&#39;,
            &#39;node_modules/angular-material/angular-material-mocks.js&#39;,
            &#39;js/*.js&#39;,
            &#39;test/*.js&#39;
        ],
        exclude: [
        ],
        preprocessors: {
            &#39;js/*.js&#39;: [&#39;browserify&#39;, &#39;coverage&#39;],
            &#39;tests/js&#39;: [&#39;browserify&#39;]
        },
        browserify: {
          debug: true
        },
        reporters: [&#39;progress&#39;, &#39;coverage&#39;],
        port: 9876,
        colors: true,
        logLevel: config.LOG_DEBUG,
        autoWatch: true,
        browsers: [&#39;PhantomJS&#39;],
        singleRun: true,
        coverageReporter: {
          dir : &#39;coverage/&#39;,
          reporters: [
            { type: &#39;html&#39;, subdir: &#39;report-html&#39; },
            { type: &#39;cobertura&#39;, subdir: &#39;report-cobertura&#39; }
          ]
        }
    });
};
</code></pre>
<p>This is our Karma configuration. Karma can run the same test in multiple browsers. Here we’re going to use PhantomJS, but it’s trivial to amend the <code>browsers</code> section to add more. You just need to make sure you install the appropriate launchers for those browsers.</p>
<p>We’ll use Gulp to build the app. Here’s the <code>gulpfile.js</code>:</p>
<pre><code class="lang-javascript">var gulp = require(&#39;gulp&#39;);
var source = require(&#39;vinyl-source-stream&#39;);
var buffer = require(&#39;vinyl-buffer&#39;);
var browserify = require(&#39;browserify&#39;);
var sass = require(&#39;gulp-sass&#39;);
var server = require(&#39;gulp-webserver&#39;);

var paths = {
  scripts: [&#39;js/*.js&#39;],
  styles: [&#39;sass/*.scss&#39;]
};

gulp.task(&#39;sass&#39;, function() {
  gulp.src(&#39;sass/style.scss&#39;)
   .pipe(sass().on(&#39;error&#39;, sass.logError))
   .pipe(gulp.dest(&#39;www/css&#39;));
});;

gulp.task(&#39;js&#39;, function () {
  return browserify({ entries: [&#39;js/main.js&#39;], debug: true })
    .bundle()
    .pipe(source(&#39;bundle.js&#39;))
    .pipe(buffer())
    .pipe(gulp.dest(&#39;www/js/&#39;));
});

gulp.task(&#39;server&#39;, function () {
  gulp.src(&#39;www/&#39;)
    .pipe(server({
      livereload: true,
      open: true,
      port: 5000
    }));
});


gulp.task(&#39;watch&#39;, function () {
  gulp.watch(paths.scripts, [&#39;js&#39;]);
  gulp.watch(paths.styles, [&#39;sass&#39;]);
});

gulp.task(&#39;default&#39;, [&#39;sass&#39;,&#39;js&#39;,&#39;server&#39;, &#39;watch&#39;]);
</code></pre>
<p>Note that we’re going to be using Browserify to handle our dependencies. If you haven’t used it before, it lets you use the <code>require()</code> syntax from Node.js to include other JavaScript files, including ones available via NPM such as jQuery or Angular, allowing you to compile them all into a single file.</p>
<p>We should be able to test and run the app using NPM, so add these scripts to <code>package.json</code>:</p>
<pre><code class="lang-javascript">  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;karma start&quot;,
    &quot;run&quot;: &quot;gulp&quot;
  },
</code></pre>
<p>We also need an HTML file. Save this as <code>www/index.html</code>:</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt;
        &lt;title&gt;My New Animal Friend&lt;/title&gt;
        &lt;link href=&quot;/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div&gt;
        &lt;div ng-app=&quot;mynewanimalfriend&quot; ng-cloak&gt;
            &lt;div ng-view&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;/body&gt;
    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;/js/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>Note the use of the Angular directives. <code>ng-app</code> denotes the name of the app namespace, <code>ng-cloak</code> hides the application until it’s fully loaded, and <code>ng-view</code> denotes the area containing our content.</p>
<p>You should also create the files <code>js/main.js</code>, <code>sass/style.scss</code>, and the <code>test</code> folder.</p>
<h2 id="creating-our-first-routes">Creating our first routes</h2>
<p>Our first task is to create the routes we need. Our default route will be <code>/</code>, representing the home page. However, users will need to be logged in to see this. Otherwise, they should be redirected to the login route, which will be <code>/login</code>, appropriately enough. We’ll also have a <code>/logout</code> route, which should be self-explanatory.</p>
<p>Before we implement these routes, we need to write a test for them. We’ll start with our login route, and we’ll test that for this route, the controller will be <code>LoginCtrl</code> and the template will be <code>templates/login.html</code>. The significance of these will become apparent later. Save this as <code>test/routes.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Routes&#39;, function () {

  beforeEach(angular.mock.module(&#39;mynewanimalfriend&#39;));
  it(&#39;should map login route to login controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/login&#39;].controller).toBe(&#39;LoginCtrl&#39;);
      expect($route.routes[&#39;/login&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });
});
</code></pre>
<p>Note the <code>beforeEach()</code> hook. This is used to set up the application.</p>
<p>We can run this test with <code>npm test</code> as that calls Karma directly. Note that we’re using Jasmine to write our tests.</p>
<pre><code class="lang-bash">$ npm test

&gt; mynewanimalfriend-app@1.0.0 test /home/matthew/Projects/mynewanimalfriend-app
&gt; karma start

12 09 2016 22:22:34.168:DEBUG [config]: autoWatch set to false, because of singleRun
12 09 2016 22:22:34.172:DEBUG [plugin]: Loading karma-* from /home/matthew/Projects/mynewanimalfriend-app/node_modules
12 09 2016 22:22:34.176:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-browserify.
12 09 2016 22:22:34.314:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-coverage.
12 09 2016 22:22:34.484:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine.
12 09 2016 22:22:34.485:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-phantomjs-launcher.
12 09 2016 22:22:34.535:DEBUG [framework.browserify]: created browserify bundle: /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:34.553:DEBUG [framework.browserify]: add bundle to config.files at position 3
12 09 2016 22:22:34.559:DEBUG [web-server]: Instantiating middleware
12 09 2016 22:22:34.569:DEBUG [reporter]: Trying to load reporter: coverage
12 09 2016 22:22:34.570:DEBUG [reporter]: Trying to load color-version of reporter: coverage (coverage_color)
12 09 2016 22:22:34.571:DEBUG [reporter]: Couldn&#39;t load color-version.
12 09 2016 22:22:34.596:DEBUG [framework.browserify]: updating js/main.js in bundle
12 09 2016 22:22:34.597:DEBUG [framework.browserify]: building bundle
12 09 2016 22:22:35.302:DEBUG [framework.browserify]: bundling
12 09 2016 22:22:35.328:DEBUG [preprocessor.coverage]: Processing &quot;/home/matthew/Projects/mynewanimalfriend-app/js/main.js&quot;.
12 09 2016 22:22:35.345:INFO [framework.browserify]: bundle built
12 09 2016 22:22:35.352:INFO [karma]: Karma v1.3.0 server started at http://localhost:9876/
12 09 2016 22:22:35.352:INFO [launcher]: Launching browser PhantomJS with unlimited concurrency
12 09 2016 22:22:35.361:INFO [launcher]: Starting browser PhantomJS
12 09 2016 22:22:35.361:DEBUG [temp-dir]: Creating temp dir at /tmp/karma-17657666
12 09 2016 22:22:35.364:DEBUG [launcher]: /home/matthew/Projects/mynewanimalfriend-app/node_modules/phantomjs-prebuilt/lib/phantom/bin/phantomjs /tmp/karma-17657666/capture.js
12 09 2016 22:22:35.466:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/client.html
12 09 2016 22:22:35.478:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/karma.js
12 09 2016 22:22:35.541:DEBUG [karma]: A browser has connected on socket /#dQYjOD4F_HJwPXiYAAAA
12 09 2016 22:22:35.564:DEBUG [web-server]: upgrade /socket.io/?EIO=3&amp;transport=websocket&amp;sid=dQYjOD4F_HJwPXiYAAAA
12 09 2016 22:22:35.629:INFO [PhantomJS 2.1.1 (Linux 0.0.0)]: Connected on socket /#dQYjOD4F_HJwPXiYAAAA with id 17657666
12 09 2016 22:22:35.630:DEBUG [launcher]: PhantomJS (id 17657666) captured in 0.277 secs
12 09 2016 22:22:35.642:DEBUG [phantomjs.launcher]: 

12 09 2016 22:22:35.643:DEBUG [middleware:karma]: custom files null null
12 09 2016 22:22:35.644:DEBUG [middleware:karma]: Serving static request /context.html
12 09 2016 22:22:35.646:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.html
12 09 2016 22:22:35.650:DEBUG [middleware:source-files]: Requesting /base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?b1682a1eb50e00abf147fc1fb28e31006d499aae /
12 09 2016 22:22:35.650:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:22:35.652:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-material/angular-material-mocks.js?9f31553e4bbbad4d6b52638351e3a274352311c2 /
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/boot.js?945a38bf4e45ad2770eb94868231905a04a0bd3e /
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/adapter.js?7975a273517f1eb29d7bd018790fd4c7b9a485d5 /
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular/angular.min.js?78069f9f3a9ca9652cb04c13ccb0670d747666b8 /
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-mocks/angular-mocks.js?cc56136dc551d94abe8195cf8475eb27a3aa3c4b /
12 09 2016 22:22:35.657:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:22:35.657:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:22:35.658:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:22:35.658:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:22:35.659:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:22:35.659:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:22:35.660:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.js
12 09 2016 22:22:35.661:DEBUG [middleware:source-files]: Requesting /absolute/tmp/f8c46bd8d72c5b8578e64552192273be.browserify?8ffde4eef27d38e92cc62da4e8dd0ffa5a3a4a4c /
12 09 2016 22:22:35.661:DEBUG [middleware:source-files]: Fetching /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Requesting /base/js/main.js?41c850cecc07c24d7cd0421e914bd2420671e573 /
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Requesting /base/test/routes.spec.js?92b15bb7c24bc6ead636994fb1c737b91727d887 /
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:22:35.663:DEBUG [web-server]: serving (cached): /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:35.664:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:22:35.664:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
PhantomJS 2.1.1 (Linux 0.0.0) Routes should map login route to login controller FAILED
        Error: [$injector:modulerr] http://errors.angularjs.org/1.5.8/$injector/modulerr?p0=mynewanimalfriend&amp;p1=%5B%24injector%3Anomod%5D%20http%3A%2F%2Ferrors.angularjs.org%2F1.5.8%2F%24injector%2Fnomod%3Fp0%3Dmynewanimalfriend%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A25%3A111%0Ab%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A24%3A143%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A24%3A489%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A39%3A473%0Aq%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A7%3A359%0Ag%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A39%3A320%0Acb%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A43%3A337%0AworkFn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular-mocks%2Fangular-mocks.js%3Fcc56136dc551d94abe8195cf8475eb27a3aa3c4b%3A3074%3A60%0Ainject%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular-mocks%2Fangular-mocks.js%3Fcc56136dc551d94abe8195cf8475eb27a3aa3c4b%3A3054%3A46%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Ftest%2Froutes.spec.js%3F92b15bb7c24bc6ead636994fb1c737b91727d887%3A5%3A11%0AattemptSync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1942%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1930%3A20%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A367%3A28%0Afn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2568%3A44%0AattemptAsync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1972%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1927%3A21%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Afn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2553%3A31%0AattemptAsync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1972%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1927%3A21%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2415%3A25%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A772%3A24%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fkarma-jasmine%2Flib%2Fadapter.js%3F7975a273517f1eb29d7bd018790fd4c7b9a485d5%3A320%3A23%0Aloaded%40http%3A%2F%2Flocalhost%3A9876%2Fcontext.js%3A151%3A17%0Aglobal%20code%40http%3A%2F%2Flocalhost%3A9876%2Fcontext.html%3A50%3A28 in node_modules/angular/angular.min.js (line 40)
        node_modules/angular/angular.min.js:40:260
        q@node_modules/angular/angular.min.js:7:359
        g@node_modules/angular/angular.min.js:39:320
        cb@node_modules/angular/angular.min.js:43:337
        workFn@node_modules/angular-mocks/angular-mocks.js:3074:60
        inject@node_modules/angular-mocks/angular-mocks.js:3054:46
        test/routes.spec.js:5:11
        loaded@http://localhost:9876/context.js:151:17
PhantomJS 2.1.1 (Linux 0.0.0): Executed 1 of 1 (1 FAILED) ERROR (0.044 secs / 0.006 secs)
12 09 2016 22:22:35.778:DEBUG [karma]: Run complete, exiting.
12 09 2016 22:22:35.778:DEBUG [launcher]: Disconnecting all browsers
12 09 2016 22:22:35.778:DEBUG [framework.browserify]: cleaning up
12 09 2016 22:22:35.782:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-html
12 09 2016 22:22:35.876:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-cobertura
12 09 2016 22:22:35.880:DEBUG [launcher]: Process PhantomJS exited with code 0
12 09 2016 22:22:35.881:DEBUG [temp-dir]: Cleaning temp dir /tmp/karma-17657666
12 09 2016 22:22:35.884:DEBUG [launcher]: Finished all browsers
npm ERR! Test failed.  See above for more details.
</code></pre>
<p>Now that we have a failing test, we can set about making it pass. Save this at <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  });
});
</code></pre>
<p>As mentioned earlier, because we’re using Browserify, we can use the <code>require()</code> syntax to import our dependencies. Note we also give our module a name and specify the dependencies. Finally, note that we use <code>$routeProvider</code> to set up our first route, and we map the template URL and controller to match our test.</p>
<p>Let’s run the test again:</p>
<pre><code class="lang-bash">$ npm test

&gt; mynewanimalfriend-app@1.0.0 test /home/matthew/Projects/mynewanimalfriend-app
&gt; karma start

12 09 2016 22:35:51.231:DEBUG [config]: autoWatch set to false, because of singleRun
12 09 2016 22:35:51.235:DEBUG [plugin]: Loading karma-* from /home/matthew/Projects/mynewanimalfriend-app/node_modules
12 09 2016 22:35:51.237:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-browserify.
12 09 2016 22:35:51.354:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-coverage.
12 09 2016 22:35:51.496:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine.
12 09 2016 22:35:51.497:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-phantomjs-launcher.
12 09 2016 22:35:51.547:DEBUG [framework.browserify]: created browserify bundle: /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:51.559:DEBUG [framework.browserify]: add bundle to config.files at position 3
12 09 2016 22:35:51.564:DEBUG [web-server]: Instantiating middleware
12 09 2016 22:35:51.581:DEBUG [reporter]: Trying to load reporter: coverage
12 09 2016 22:35:51.582:DEBUG [reporter]: Trying to load color-version of reporter: coverage (coverage_color)
12 09 2016 22:35:51.582:DEBUG [reporter]: Couldn&#39;t load color-version.
12 09 2016 22:35:51.602:DEBUG [framework.browserify]: updating js/main.js in bundle
12 09 2016 22:35:51.603:DEBUG [framework.browserify]: building bundle
12 09 2016 22:35:52.306:DEBUG [framework.browserify]: bundling
12 09 2016 22:35:54.095:DEBUG [preprocessor.coverage]: Processing &quot;/home/matthew/Projects/mynewanimalfriend-app/js/main.js&quot;.
12 09 2016 22:35:54.170:INFO [framework.browserify]: bundle built
12 09 2016 22:35:54.189:INFO [karma]: Karma v1.3.0 server started at http://localhost:9876/
12 09 2016 22:35:54.189:INFO [launcher]: Launching browser PhantomJS with unlimited concurrency
12 09 2016 22:35:54.197:INFO [launcher]: Starting browser PhantomJS
12 09 2016 22:35:54.198:DEBUG [temp-dir]: Creating temp dir at /tmp/karma-91342786
12 09 2016 22:35:54.201:DEBUG [launcher]: /home/matthew/Projects/mynewanimalfriend-app/node_modules/phantomjs-prebuilt/lib/phantom/bin/phantomjs /tmp/karma-91342786/capture.js
12 09 2016 22:35:54.300:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/client.html
12 09 2016 22:35:54.308:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/karma.js
12 09 2016 22:35:54.366:DEBUG [karma]: A browser has connected on socket /#FpcuZAJUT-u6Dl4sAAAA
12 09 2016 22:35:54.386:DEBUG [web-server]: upgrade /socket.io/?EIO=3&amp;transport=websocket&amp;sid=FpcuZAJUT-u6Dl4sAAAA
12 09 2016 22:35:54.442:INFO [PhantomJS 2.1.1 (Linux 0.0.0)]: Connected on socket /#FpcuZAJUT-u6Dl4sAAAA with id 91342786
12 09 2016 22:35:54.442:DEBUG [launcher]: PhantomJS (id 91342786) captured in 0.253 secs
12 09 2016 22:35:54.447:DEBUG [phantomjs.launcher]: 

12 09 2016 22:35:54.448:DEBUG [middleware:karma]: custom files null null
12 09 2016 22:35:54.448:DEBUG [middleware:karma]: Serving static request /context.html
12 09 2016 22:35:54.449:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.html
12 09 2016 22:35:54.451:DEBUG [middleware:source-files]: Requesting /base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?b1682a1eb50e00abf147fc1fb28e31006d499aae /
12 09 2016 22:35:54.451:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:35:54.452:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-material/angular-material-mocks.js?9f31553e4bbbad4d6b52638351e3a274352311c2 /
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/boot.js?945a38bf4e45ad2770eb94868231905a04a0bd3e /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/adapter.js?7975a273517f1eb29d7bd018790fd4c7b9a485d5 /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-mocks/angular-mocks.js?cc56136dc551d94abe8195cf8475eb27a3aa3c4b /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:35:54.455:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular/angular.min.js?78069f9f3a9ca9652cb04c13ccb0670d747666b8 /
12 09 2016 22:35:54.455:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:35:54.456:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:35:54.457:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Requesting /absolute/tmp/02002698e6d413a542186462d3a0a6ce.browserify?f4c82dc0618d979f84c89967ea1c412e646a5fe5 /
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Fetching /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Requesting /base/js/main.js?41c850cecc07c24d7cd0421e914bd2420671e573 /
12 09 2016 22:35:54.459:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:35:54.460:DEBUG [middleware:source-files]: Requesting /base/test/routes.spec.js?92b15bb7c24bc6ead636994fb1c737b91727d887 /
12 09 2016 22:35:54.461:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:35:54.461:DEBUG [web-server]: serving (cached): /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:54.496:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:35:54.497:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:35:54.497:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.js
12 09 2016 22:35:54.582:DEBUG [phantomjs.launcher]: WARNING: Tried to load angular more than once.

PhantomJS 2.1.1 (Linux 0.0.0) LOG: &#39;WARNING: Tried to load angular more than once.&#39;

PhantomJS 2.1.1 (Linux 0.0.0): Executed 1 of 1 SUCCESS (0.004 secs / 0.358 secs)
12 09 2016 22:35:55.003:DEBUG [karma]: Run complete, exiting.
12 09 2016 22:35:55.003:DEBUG [launcher]: Disconnecting all browsers
12 09 2016 22:35:55.003:DEBUG [framework.browserify]: cleaning up
12 09 2016 22:35:55.006:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-html
12 09 2016 22:35:55.078:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-cobertura
12 09 2016 22:35:55.082:DEBUG [launcher]: Process PhantomJS exited with code 0
12 09 2016 22:35:55.082:DEBUG [temp-dir]: Cleaning temp dir /tmp/karma-91342786
12 09 2016 22:35:55.085:DEBUG [launcher]: Finished all browsers
</code></pre>
<p>Our first test has passed. Let’s add tests for the other routes:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Routes&#39;, function () {

  beforeEach(angular.mock.module(&#39;mynewanimalfriend&#39;));
  it(&#39;should map default route to home controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/&#39;].controller).toBe(&#39;HomeCtrl&#39;);
      expect($route.routes[&#39;/&#39;].templateUrl).toEqual(&#39;templates/home.html&#39;);
    });
  });

  it(&#39;should map login route to login controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/login&#39;].controller).toBe(&#39;LoginCtrl&#39;);
      expect($route.routes[&#39;/login&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });

  it(&#39;should map logout route to logout controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/logout&#39;].controller).toBe(&#39;LogoutCtrl&#39;);
      expect($route.routes[&#39;/logout&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });
});
</code></pre>
<p>Note that the logout route uses the login template. This is because all it will do is redirect the user to the login form.</p>
<p>For the sake of brevity I won’t display the test output, but two of these tests should now fail. We can easily set up the new routes in <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  });
});
</code></pre>
<p>That’s looking good so far. But what if someone navigates to a URL that doesn’t exist? Our router should handle that. Add this to the test:</p>
<pre><code class="lang-javascript">  it(&#39;should redirect other or empty routes to the home controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[null].redirectTo).toEqual(&#39;/&#39;)
    });
  });
</code></pre>
<p>Once again, the test should fail. Fixing it is fairly straightforward - we’ll use the <code>otherwise()</code> method to define a fallback route:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Now our routes are in place, we need to implement the three controllers we will need. However, as two of these controllers deal with authentication, we’ll first create some services to handle that, and they’ll need to be tested. Save this as <code>test/services.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Services&#39;, function () {

  beforeEach(function(){
    jasmine.addMatchers({
      toEqualData: function(util, customEqualityTesters) {
        return {
          compare: function(actual, expected) {
            return {
              pass: angular.equals(actual, expected)
            };
          }
        };
      }
    });
  });

  beforeEach(angular.mock.module(&#39;mynewanimalfriend.services&#39;));

  describe(&#39;Token service&#39;, function () {
    var mockBackend, Token;

    beforeEach(inject(function (_Token_, _$httpBackend_) {
      Token = _Token_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can create a new token&#39;, function () {
      mockBackend.expectPOST(&#39;http://localhost:8000/api/authenticate&#39;, &#39;{&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;password&quot;}&#39;).respond({token: &#39;mytoken&#39;});
      var token = new Token({
        email: &#39;bob@example.com&#39;,
        password: &#39;password&#39;
      });
      token.$save(function (response) {
        expect(response).toEqualData({token: &#39;mytoken&#39;});
      });
      mockBackend.flush();
    });
  });
});
</code></pre>
<p>In this test we use the <code>$httpBackend</code> facility from <code>ngMock</code> to mock out our API endpoints. We already have a REST API capable of generating a token, and we set this test up to behave similarly. We specify that it should expect to receive a certain POST request, and should respond with the token <code>mytoken</code>. Run the test to make sure it fails, then save this as <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
});
</code></pre>
<p>A little explanation is called for. In Angular, the <code>$resource</code> dependency represents an HTTP resource. By default it supports making HTTP requests to the denoted endpoint via GET, POST and DELETE, and it’s trivial to add support for PUT or PATCH methods. Using <code>$resource</code>, you can easily interface with a RESTful web service, and it’s one of my favourite things about Angular.</p>
<p>We also need to load <code>services.js</code> in our <code>main.js</code> file:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.services&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Now, running the tests should show that they pass.</p>
<p>With that in place, we will also create an authentication service that lets the app determine if the user is logged in. Add this to <code>test/services.spec.js</code>:</p>
<pre><code class="lang-javascript">  describe(&#39;Auth service&#39;, function () {
    var Auth;

    beforeEach(inject(function (_Auth_) {
      Auth = _Auth_;
    }));

    it(&#39;can set user&#39;, function () {
      Auth.setUser(&#39;mytoken&#39;);
      var token = localStorage.getItem(&#39;authHeader&#39;);
      expect(token).toEqual(&#39;Bearer mytoken&#39;);
    });

    it(&#39;can return login status&#39;, function () {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer mytoken&#39;);
      expect(Auth.isLoggedIn()).toBeTruthy();
    });

    it(&#39;can log the user out&#39;, function () {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer mytoken&#39;);
      Auth.logUserOut();
      expect(Auth.isLoggedIn()).toBeFalsy();
      expect(localStorage.getItem(&#39;authHeader&#39;)).toBeFalsy();
    });
  });
</code></pre>
<p>This service is expected to do three things:</p>
<ul>
<li>Set the current user’s details in local storage</li>
<li>Return whether the user is logged in</li>
<li>Log the user out</li>
</ul>
<p>Make sure the test fails, then amend <code>js/services.js</code> as follows:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Auth&#39;, function(){
  return{
    setUser : function (aUser) {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer &#39; + aUser);
    },
    isLoggedIn: function () {
      var user = localStorage.getItem(&#39;authHeader&#39;);
      return(user)? user : false;
    },
    logUserOut: function () {
      localStorage.removeItem(&#39;authHeader&#39;);
    }
  }
})

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
});
</code></pre>
<p>When the user is set, we store the authentication details we need in local storage. We can then use that to determine if they are logged in. When they log out, we simply clear local storage,</p>
<p>That should be enough to make these tests pass. Now we can move on to our controllers. We’ll do the login controller first. Save this as <code>test/controllers.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Controllers&#39;, function () {

  beforeEach(function(){
    jasmine.addMatchers({
      toEqualData: function(util, customEqualityTesters) {
        return {
          compare: function(actual, expected) {
            return {
              pass: angular.equals(actual, expected)
            };
          }
        };
      }
    });
  });

  beforeEach(angular.mock.module(&#39;mynewanimalfriend.controllers&#39;));

  describe(&#39;Login Controller&#39;, function () {
    var mockBackend, scope;

    beforeEach(inject(function ($rootScope, $controller, _$httpBackend_) {
      mockBackend = _$httpBackend_;
      scope = $rootScope.$new();
      $controller(&#39;LoginCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test doLogin is defined
    it(&#39;should define the login method&#39;, function () {
      expect(scope.doLogin).toBeDefined();
    });

    // Test doLogin works
    it(&#39;should allow the user to log in&#39;, function () {
      // Mock the backend
      mockBackend.expectPOST(&#39;http://localhost:8000/api/authenticate&#39;, &#39;{&quot;email&quot;:&quot;user@example.com&quot;,&quot;password&quot;:&quot;password&quot;}&#39;).respond({token: 123});

      // Define login data
      scope.credentials = {
        email: &#39;user@example.com&#39;,
        password: &#39;password&#39;
      };

      //  Submit the request
      scope.doLogin();

      // Flush the backend
      mockBackend.flush();

      // Check login complete
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(&#39;Bearer 123&#39;);
    });
  });
});
</code></pre>
<p>We check that the scope and the <code>doLogin()</code> method are defined. We then mock the backend’s <code>/api/authenticate</code> route to respond with a dummy token when our credentials are provided. Then, we set the credentials in the variable <code>$scope.credentials</code>, call <code>doLogin()</code>, flush the backend, and check the authentication header has been set.</p>
<p>Once you’ve verified these tests fail, we can start making them pass. Save this as <code>js/controllers.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
});
</code></pre>
<p>The <code>LoginCtrl</code> controller accepts the scope, location, and our two services. When <code>doLogin()</code> is alled, it picks up the values in <code>$scope.credentials</code>, which we will set in our template later. It then makes a POST request to our endpoint including those credentials. Our API backend should return the new token in the response, and the token is stored using the <code>Auth</code> service. Otherwise, it raises an error.</p>
<p>Check the test now passes before moving onto the logout functionality. Add this to <code>test/controllers.spec.js</code>:</p>
<pre><code class="lang-javascript">  describe(&#39;Logout Controller&#39;, function () {
    var scope;

    beforeEach(inject(function ($rootScope, $controller, Auth) {
      Auth.setUser(&#39;Blah&#39;);
      scope = $rootScope.$new();
      $controller(&#39;LogoutCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test session cleared
    it(&#39;should clear the session&#39;, function () {
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(null);
    });
  });
</code></pre>
<p>We want to ensure that when the user navigates to the route managed by the <code>LogoutCtrl</code> controller, the session is cleared, so we set up an existing session, call the controller, check it’s defined, and then check that local storage is empty.</p>
<p>Once you’ve verified that the test fails, amend the controllers as follows:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})

.controller(&#39;LogoutCtrl&#39;, function ($scope, $location, Auth) {
  // Log user out
  Auth.logUserOut();

  // Redirect to login page
  $location.path(&#39;/login&#39;);
});
</code></pre>
<p>Our <code>LogoutCtrl</code> controller is very simple - it just logs the user out and redirects them back to the login form. Our final controller is for the home page:</p>
<pre><code class="lang-javascript">  describe(&#39;Home Controller&#39;, function () {
    var scope;

    beforeEach(inject(function ($rootScope, $controller) {
      scope = $rootScope.$new();
      $controller(&#39;HomeCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });
  });
</code></pre>
<p>For now our home controller does nothing except define the scope, so it’s easy to implement:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})

.controller(&#39;LogoutCtrl&#39;, function ($scope, $location, Auth) {
  // Log user out
  Auth.logUserOut();

  // Redirect to login page
  $location.path(&#39;/login&#39;);
})

.controller(&#39;HomeCtrl&#39;, function ($scope) {
});
</code></pre>
<p>Verify that the tests pass, and our controllers are done for now. However, we still have some work to do to hook the various elements up. First, of all, our <code>main.js</code> unnecessarily loads our services - since we only use those services in our controllers, we don’t need them there. We also need to be able to keep users out of routes other than <code>login</code> when not logged in. Here’s what you <code>main.js</code> should look like:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./controllers&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.controllers&#39;
])

.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])

.config([&#39;$httpProvider&#39;, function($httpProvider) {
  $httpProvider.interceptors.push(&#39;sessionInjector&#39;);
  $httpProvider.interceptors.push(&#39;authInterceptor&#39;);
}])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Note that we set it up to intercept the HTTP request with the session injector and the auth interceptor. Next we need to create these in <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Auth&#39;, function(){
  return{
    setUser : function (aUser) {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer &#39; + aUser);
    },
    isLoggedIn: function () {
      var user = localStorage.getItem(&#39;authHeader&#39;);
      return(user)? user : false;
    },
    logUserOut: function () {
      localStorage.removeItem(&#39;authHeader&#39;);
    }
  }
})

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
})

.factory(&#39;sessionInjector&#39;, function (Auth) {
  var sessionInjector = {
    request: function (config) {
      if (Auth.isLoggedIn()) {
        config.headers.Authorization = Auth.isLoggedIn();
      }
      return config;
    }
  };
  return sessionInjector;
})

.service(&#39;authInterceptor&#39;, function ($q, Auth, $location) {
  var service = this;

  service.responseError = function (response) {
    if (response.status == 400) {
      Auth.logUserOut();
      $location.path(&#39;/login&#39;);
    }
    return $q.reject(response);
  };
});
</code></pre>
<p>I’ll walk you through these. <code>sessionInjector</code> adds the authorization HTTP header to every request to the server if the user is logged in, so that it returns the right user’s details. <code>authInterceptor</code> catches any 400 errors, denoting that the user is not authenticated with a current JSON web token, and logs the user out. In this way we can handle the expiry of a user’s token.</p>
<p>Now the logic of our app is in place, but that’s no use without some content…</p>
<h2 id="angular-templating">Angular templating</h2>
<p>We have one very basic HTML template, but that’s just a boilerplate for inserting the rest of our content. For the rest of the HTML we’ll need to load templates dynamically, and we’ll use Angular Material to help us build a nice UI quickly. Run the following commands to create the files:</p>
<pre><code class="lang-bash">$ mkdir www/templates
$ touch www/templates/login.html
$ touch www/templates/home.html
</code></pre>
<p>We need to import the CSS for Angular Material. Add this to <code>sass/style.scss</code>:</p>
<pre><code class="lang-scss">// Angular Material
@import &quot;node_modules/angular-material/angular-material.scss&quot;;
</code></pre>
<p>With that done, we need to configure theming in <code>main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./controllers&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.controllers&#39;
])

.config(function ($mdThemingProvider) {
    $mdThemingProvider.theme(&#39;default&#39;)
      .primaryPalette(&#39;purple&#39;)
      .accentPalette(&#39;cyan&#39;);
})

.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])

.config([&#39;$httpProvider&#39;, function($httpProvider) {
  $httpProvider.interceptors.push(&#39;sessionInjector&#39;);
  $httpProvider.interceptors.push(&#39;authInterceptor&#39;);
}])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>You may want to look at the <a href="https://material.angularjs.org/latest/Theming/01_introduction">documentation</a> for Angular Material to choose your own theme options. Next, let’s create our login template at <code>www/templates/login.html</code>:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doLogin()&quot;&gt;Submit&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>We’re using Angular Material’s input and button directives to make our inputs look a bit nicer. Note that the <code>ng-click</code> handler calls the <code>doLogin()</code> method of our controller, and that the <code>ng-model</code> attributes contain the <code>credentials</code> object that gets passed to the API. If you haven’t used Angular before, <code>ng-model</code> essentially lets you bind a variable to an element’s value so, for instance, when an input is changed, it can be easily accessed via the variable.</p>
<p>Next, we’ll implement a placeholder for our home page with a log out button. Save this as <code>www/templates/home.html</code>:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;#logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;
</code></pre>
<p>That should be all we need to demonstrate logging in and out of our app. Let’s try it out. First run the Gulp task to show the app in the browser:</p>
<pre><code class="lang-bash">$ gulp
</code></pre>
<p>Then, in another shell session, switch to the directory with the backend and run the server for that:</p>
<pre><code class="lang-bash">$ php artisan serve
</code></pre>
<p>You should already have a user account set up and ready to use thanks to the seeder we wrote. The browser should show the login page by default, and if you fill in the login form and click the button you should see the home page. You should then be able to log out again.</p>
<p>Congratulations! We’ve got authentication working.</p>
<h2 id="switching-to-html5-routing">Switching to HTML5 routing</h2>
<p>You may note that the URLs use hashes - they are in the format <code>http://localhost:5000/#/login</code>. Wouldn’t it be better if we didn’t use the hash? Fortunately modern browsers support this via the HTML5 pushState API, and Angular has built-in support for this.</p>
<p>To enable it, we first need to declare a base URL in <code>www/index.html</code>. Amend it as follows:</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt;
        &lt;title&gt;My New Animal Friend&lt;/title&gt;
        &lt;link href=&quot;/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
        &lt;base href=&quot;/&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div&gt;
        &lt;div ng-app=&quot;mynewanimalfriend&quot; ng-cloak&gt;
            &lt;div ng-view&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;/body&gt;
    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;/js/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>Here we’ve added the <code>&lt;base href=&quot;/&quot;&gt;</code> tag to denote our base URL. Next we configure Angular to use HTML5 routing in <code>main.js</code>:</p>
<pre><code class="lang-javascript">.config(function($locationProvider) {
  $locationProvider.html5Mode(true);
})
</code></pre>
<p>And amend the URL in the home template:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;/logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;
</code></pre>
<p>Now, we should be using HTML5 routing throughout.</p>
<p>With that done, we can finish for today. We’ve got our basic app skeleton and authentication system up and running, and we’ll be in a good place to continue developing the rest of the app next time. I’ve put the source code on <a href="https://github.com/matthewbdaly/mynewanimalfriend-app">Github</a>, and you can find this lesson’s work under the <code>lesson-2</code> tag.</p>
<p>Next time we’ll develop the app further, including implementing the pet search functionality.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building a Phonegap app with Laravel and Angular - Part 1]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/09/11/building-a-phonegap-app-with-laravel-and-angular-part-1/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/09/11/building-a-phonegap-app-with-laravel-and-angular-part-1/</guid>
            <pubDate>Sun, 11 Sep 2016 18:33:41 GMT</pubDate>
            <description><![CDATA[<p>A lot of my work over the last few years has been on Phonegap apps. Phonegap isn’t terribly hard to use, but the difference in context between that and a more conventional web app means that you have to move a lot of functionality to the client side, and unless you’ve used client-side Javascript frameworks before it can be a struggle.</p>
<p>In this series of tutorials I’ll show you how I might build a Phonegap app. The work involved will include:</p>
<ul>
<li>Building a REST API using Laravel to expose the data</li>
<li>Building an admin interface to manage the data</li>
<li>Building a Phonegap app using Angular.js</li>
<li>Testing and deploying it</li>
</ul>
<p>In the process we’ll cover issues like authentication, authorization, real-time notifications and working with REST APIs. Note that we won’t cover the app submission process - you can find plenty of resources on that. We will, however, be using Phonegap Build to build the app.</p>
<h2 id="the-brief">The brief</h2>
<p>Let’s say our new client is an animal shelter. The brief for the app is as follows:</p>
<blockquote>
<p>My New Animal Friend will be an app for finding a new pet. Once a user signs in, they’ll be able to choose what type of pet they’re looking for, then look through a list of pets available to adopt. They can reject them by swiping left or save them by swiping right. They can see more about the ones they swipe right on, and arrange to meet them, from within the app. Users can also message the staff to ask questions about a pet.</p>
</blockquote>
<p>Nice idea, but there’s a lot of work involved! Our very first task is to build the REST API, since everything else relies on that. Before starting, make sure you have the following installed:</p>
<ul>
<li>PHP (I’m using PHP 7, but 5.6 should be fine)</li>
<li>Composer</li>
<li>Git</li>
<li>A compatible relational database (I use PostgreSQL)</li>
<li>Redis</li>
<li>Your usual text editor</li>
<li>Node.js</li>
</ul>
<p>As long as you have this, you should be ready to go. Using <a href="https://laravel.com/docs/5.3/homestead">Homestead</a> is the simplest way to get started if you don’t have all this stuff already.</p>
<h2 id="starting-the-api">Starting the API</h2>
<p>To start building our REST API, run the following command from the shell:</p>
<pre><code class="lang-bash">$ composer create-project --prefer-dist laravel/laravel mynewanimalfriend-backend
</code></pre>
<p>We also have some other dependencies we need to install, so switch into the new directory and run the following command:</p>
<pre><code class="lang-bash">$ composer require barryvdh/laravel-cors tymon/jwt-auth predis/predis
</code></pre>
<p>Next, we need to add the new packages to the Laravel config. Open up <code>config/app.php</code> and add the following to the <code>providers</code> array:</p>
<pre><code class="lang-php">   Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class,                                                                                                                                              
   Barryvdh\Cors\ServiceProvider::class,   
</code></pre>
<p>And the following to the <code>aliases</code> array:</p>
<pre><code class="lang-php">   &#39;JWTAuth&#39; =&gt; Tymon\JWTAuth\Facades\JWTAuth::class,
</code></pre>
<p>We also need to ensure that the CORS middleware is applied to all API routes. Open up <code>app/Http/Kernel.php</code> and under the <code>api</code> array in <code>protected $middlewareGroups</code> paste the following:</p>
<pre><code class="lang-php">   \Barryvdh\Cors\HandleCors::class,
</code></pre>
<p>Now that the packages are included, we can publish the files for them:</p>
<pre><code class="lang-bash">$ php artisan vendor:publish
</code></pre>
<p>Next, we need to set a key for our API authentication:</p>
<pre><code class="lang-bash">$ php artisan jwt:generate
</code></pre>
<p>And set a custom namespace:</p>
<pre><code class="lang-bash">$ php artisan app:name AnimalFriend
</code></pre>
<p>You’ll also want to set up the <code>.env</code> file with the configuration settings for your application. There’s one at <code>.env.example</code> by default that you can copy and customise. Then run the following command to generate the application key:</p>
<pre><code class="lang-bash">$ php artisan key:generate
</code></pre>
<p>I had to change the namespace for the user model in <code>config/jwt.php</code> as well:</p>
<pre><code class="lang-php">    &#39;user&#39; =&gt; &#39;AnimalFriend\User&#39;,
</code></pre>
<p>I also tend to amend the settings in <code>phpunit.xml</code> as follows so that it uses an in-memory SQLite database for tests:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt;
        &lt;env name=&quot;SESSION_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;QUEUE_DRIVER&quot; value=&quot;sync&quot;/&gt;
        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;redis&quot;/&gt;
        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<p>Also, delete <code>tests/ExampleTest.php</code> and amend <code>tests/TestCase.php</code> as follows in order to use database migrations in tests:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

abstract class TestCase extends Illuminate\Foundation\Testing\TestCase
{
    use DatabaseMigrations;

    /**
     * The base URL to use while testing the application.
     *
     * @var string
     */
    protected $baseUrl = &#39;http://localhost&#39;;

    /**
     * Creates the application.
     *
     * @return \Illuminate\Foundation\Application
     */
    public function createApplication()
    {
        $app = require __DIR__.&#39;/../bootstrap/app.php&#39;;

        $app-&gt;make(Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();

        return $app;
    }
}
</code></pre>
<p>With that in place, we can start work on our API proper.</p>
<h2 id="authenticating-our-api">Authenticating our API</h2>
<p>We’re going to start out with a very limited subset of our API. First, we’ll implement the authentication for our app, then we’ll add the facility to view a list of pets or an individual pet. Other functionality will come later. This will be sufficient to get the app working.</p>
<p>First, we need to create our user model. As we’ll be practicing TDD throughout, we write a test for the user model first. Save the following as <code>tests/UserModelTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use AnimalFriend\User;

class UserModelTest extends TestCase
{
    /**
     * Test creating a user
     *
     * @return void
     */
    public function testCreatingAUser()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Verify it works
        $saved = User::where(&#39;email&#39;, &#39;bob@example.com&#39;)-&gt;first();
        $this-&gt;assertEquals($saved-&gt;id, 1);
        $this-&gt;assertEquals($saved-&gt;name, &#39;bobsmith&#39;);
    }
}
</code></pre>
<p>If we run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 169 ms, Memory: 12.00MB

OK (1 test, 3 assertions)
</code></pre>
<p>We already have a perfectly good <code>User</code> model and the appropriate migrations, so our test already passes.</p>
<p>Next, we need to implement the authentication system. Save this as <code>tests/AuthTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class AuthTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test the auth
     *
     * @return void
     */
    public function testAuth()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; bcrypt(&#39;password&#39;)
        ]);

        // Create request
        $data = array(
            &#39;email&#39; =&gt; $user-&gt;email,
            &#39;password&#39; =&gt; &#39;password&#39;,
        );
        $response = $this-&gt;call(&#39;POST&#39;, &#39;api/authenticate&#39;, $data);
        $this-&gt;assertResponseStatus(200);
        $content = json_decode($response-&gt;getContent());
        $this-&gt;assertTrue(array_key_exists(&#39;token&#39;, $content));
    }

    /**
     * Test the auth when user does not exist
     *
     * @return void
     */
    public function testAuthFailure()
    {
        // Create data for request
        $data = array(
            &#39;email&#39; =&gt; &#39;user@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
        );
        $response = $this-&gt;call(&#39;POST&#39;, &#39;api/authenticate&#39;, $data);

        // Check the status code
        $this-&gt;assertResponseStatus(401);
    }
}
</code></pre>
<p>The first test creates a user and sends an authentication request, then confirms that it returns the JSON Web Token. The second checks that a user that doesn’t exist cannot log in.</p>
<p>Let’s run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

FF.                                                                 3 / 3 (100%)

Time: 328 ms, Memory: 14.00MB

There were 2 failures:

1) AuthTest::testAuth
Expected status code 200, got 404.
Failed asserting that 404 matches expected 200.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/AuthTest.php:29

2) AuthTest::testAuthFailure
Expected status code 401, got 404.
Failed asserting that 404 matches expected 401.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/AuthTest.php:49

FAILURES!
Tests: 3, Assertions: 5, Failures: 2.
</code></pre>
<p>With a failing test in place, we can implement login. First let’s create our controller at <code>app/Http/Controllers/AuthenticateController.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Http\Controllers\Controller;
use JWTAuth;
use Tymon\JWTAuth\Exceptions\JWTException;
use AnimalFriend\User;
use Hash;

class AuthenticateController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    public function authenticate(Request $request)
    {
        // Get credentials
        $credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);

        // Get user
        $user = $this-&gt;user-&gt;where(&#39;email&#39;, $credentials[&#39;email&#39;])-&gt;first();

        try {
            // attempt to verify the credentials and create a token for the user
            if (! $token = JWTAuth::attempt($credentials)) {
                return response()-&gt;json([&#39;error&#39; =&gt; &#39;invalid_credentials&#39;], 401);
            }
        } catch (JWTException $e) {
            // something went wrong whilst attempting to encode the token
            return response()-&gt;json([&#39;error&#39; =&gt; &#39;could_not_create_token&#39;], 500);
        }

        // all good so return the token
        return response()-&gt;json(compact(&#39;token&#39;));
    }
}
</code></pre>
<p>And we need to set up the route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| is assigned the &quot;api&quot; middleware group. Enjoy building your API!
|
*/

Route::post(&#39;authenticate&#39;, &#39;AuthenticateController@authenticate&#39;);
</code></pre>
<p>Note that because it’s an API route, it’s automatically prefixed with <code>api/</code> without us having to do anything.</p>
<p>Now if we run our tests, they should pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

...                                                                 3 / 3 (100%)

Time: 402 ms, Memory: 14.00MB

OK (3 tests, 6 assertions)
</code></pre>
<p>Now we can obtain a JSON Web Token to authenticate users with. To start with we’ll only support existing users, but later we’ll add a method to sign up. However, we need at least one user to test with, so we’ll create a seeder for that at <code>database/seeds/UserTableSeeder.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class UserTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add user
        DB::table(&#39;users&#39;)-&gt;insert([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
            &#39;password&#39; =&gt; Hash::make(&quot;password&quot;)
        ]);
    }
}
</code></pre>
<p>You can run <code>php artisan make:seeder UserTableSeeder</code> to generate the file, or just paste it in. You also need to amend <code>database/seeds/DatabaseSeeder.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(UserTableSeeder::class);
    }
}
</code></pre>
<p>This ensures the seeder will actually be called. Then, run the following commands:</p>
<pre><code class="lang-bash">$ php artisan migrate
$ php artisan db:seed
</code></pre>
<p>That sets up our user in the database.</p>
<h2 id="adding-the-pets-endpoint">Adding the Pets endpoint</h2>
<p>Our next step is to add the pets model and endpoint. Our <code>Pet</code> model should have the following fields:</p>
<ul>
<li>ID</li>
<li>Timestamps (<code>created_at</code> and <code>updated_at</code>)</li>
<li>Name</li>
<li>Path to photo</li>
<li>Availability</li>
<li>Type (eg cat, dog)</li>
</ul>
<p>Let’s create a test for that model:</p>
<pre><code class="lang-php">&lt;?php

use AnimalFriend\Pet;

class PetModelTest extends TestCase
{
    /**
     * Test creating a pet
     *
     * @return void
     */
    public function testCreatingAPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Verify it works
        $saved = Pet::where(&#39;name&#39;, &#39;Freddie&#39;)-&gt;first();
        $this-&gt;assertEquals($saved-&gt;id, 1);
        $this-&gt;assertEquals($saved-&gt;name, &#39;Freddie&#39;);
        $this-&gt;assertEquals($saved-&gt;type, &#39;Cat&#39;);
        $this-&gt;assertEquals($saved-&gt;available, 1);
        $this-&gt;assertEquals($saved-&gt;picture, &#39;1.jpg&#39;);
    }
}
</code></pre>
<p>Save this as <code>tests/PetModelTest.php</code>. Then run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..E.                                                                4 / 4 (100%)

Time: 414 ms, Memory: 16.00MB

There was 1 error:

1) PetModelTest::testCreatingAUser
InvalidArgumentException: Unable to locate factory with name [default] [AnimalFriend\Pet].

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:126
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:2280
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:139
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:106
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:84
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetModelTest.php:16

ERRORS!
Tests: 4, Assertions: 6, Errors: 1.
</code></pre>
<p>First we need to create a factory for creating a pet in <code>database/factories/ModelFactory.php</code>:</p>
<pre><code class="lang-php">$factory-&gt;define(AnimalFriend\Pet::class, function (Faker\Generator $faker) {
    return [
        &#39;name&#39; =&gt; $faker-&gt;firstNameMale,
        &#39;type&#39; =&gt; &#39;Cat&#39;,
        &#39;available&#39; =&gt; 1,
        &#39;picture&#39; =&gt; &#39;1.jpg&#39;
    ];
});
</code></pre>
<p>Then, we create the model:</p>
<pre><code class="lang-bash">$ php artisan make:model Pet
</code></pre>
<p>Next, we create a migration for the <code>Pet</code> model:</p>
<pre><code class="lang-bash">$ php artisan make:migration create_pets_table
Created Migration: 2016_09_11_145010_create_pets_table
</code></pre>
<p>And paste in the following code:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreatePetsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create(&#39;pets&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;name&#39;);
            $table-&gt;string(&#39;type&#39;);
            $table-&gt;string(&#39;available&#39;);
            $table-&gt;string(&#39;picture&#39;)-&gt;nullable();
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::drop(&#39;pets&#39;);
    }
}
</code></pre>
<p>Time to run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

....                                                                4 / 4 (100%)

Time: 412 ms, Memory: 16.00MB

OK (4 tests, 12 assertions)
</code></pre>
<p>With that done, we can start work on implementing the endpoint. We need to check that unauthorised users cannot retrieve the data, and that authorised users can. First, let’s create <code>tests/PetControllerTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class PetControllerTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test fetching pets when unauthorised
     *
     * @return void
     */
    public function testFetchingPetsWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets&#39;);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pets when authorised
     *
     * @return void
     */
    public function testFetchingPets()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets&#39;, [], $headers)
            -&gt;seeJsonStructure([
                &#39;*&#39; =&gt; [
                    &#39;id&#39;,
                    &#39;name&#39;,
                    &#39;type&#39;,
                    &#39;available&#39;,
                    &#39;picture&#39;,
                    &#39;created_at&#39;,
                    &#39;updated_at&#39;
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }
}
</code></pre>
<p>First, we create a pet, make an HTTP request to <code>/api/pets</code>, and check we are not authorised. Next, we do the same, but also create a user and a JSON Web Token, and pass the token through in the request. Then we verify the response data and that it was successful.</p>
<p>Let’s run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..FF..                                                              6 / 6 (100%)

Time: 509 ms, Memory: 16.00MB

There were 2 failures:

1) PetControllerTest::testFetchingPetsWhenUnauthorised
Expected status code 400, got 404.
Failed asserting that 404 matches expected 400.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:25

2) PetControllerTest::testFetchingPets
Failed asserting that null is of type &quot;array&quot;.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:295
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:67

FAILURES!
Tests: 6, Assertions: 17, Failures: 2.
</code></pre>
<p>That looks correct, so we can start building our endpoint. We can generate a boilerplate for it as follows:</p>
<pre><code class="lang-bash">$ $ php artisan make:controller PetController --resource
</code></pre>
<p>Note the <code>--resource</code> flag - this tells Laravel to set it up to be a RESTful controller with certain predefined functions. Next, let’s amend the new file at <code>app\Http\Controllers/PetController.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Pet;

class PetController extends Controller
{
    private $pet;

    public function __construct(Pet $pet) {
        $this-&gt;pet = $pet;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;get();

        // Send response
        return response()-&gt;json($pets, 200);
    }
}
</code></pre>
<p>This implements an index route that shows all pets. Next, we hook up the route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">// Auth routes
Route::group([&#39;middleware&#39; =&gt; [&#39;jwt.auth&#39;]], function () {
    Route::resource(&#39;pets&#39;, &#39;PetController&#39;);
});
</code></pre>
<p>Note that we wrap this resource in the <code>jwt.auth</code> middleware to prevent access by unauthorised users. Implementing this as middleware makes it very easy to reuse. Also note that we can specify it as a resource, meaning we don’t have to explicitly hook up each route to a controller method.</p>
<p>Let’s run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..EE..                                                              6 / 6 (100%)

Time: 511 ms, Memory: 16.00MB

There were 2 errors:

1) PetControllerTest::testFetchingPetsWhenUnauthorised
ReflectionException: Class jwt.auth does not exist

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:734
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:629
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Application.php:709
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:173
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:517
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:24

2) PetControllerTest::testFetchingPets
ReflectionException: Class jwt.auth does not exist

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:734
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:629
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Application.php:709
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:173
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:517
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:72
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:56

ERRORS!
Tests: 6, Assertions: 15, Errors: 2.
</code></pre>
<p>Looks like JWT isn’t configured correctly. We can fix that in <code>app/Http/Kernel.php</code> by adding it to <code>$routeMiddleware</code>:</p>
<pre><code class="lang-php">        &#39;jwt.auth&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\GetUserFromToken&#39;,
        &#39;jwt.refresh&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\RefreshToken&#39;,
</code></pre>
<p>And run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

......                                                              6 / 6 (100%)

Time: 514 ms, Memory: 16.00MB

OK (6 tests, 25 assertions)
</code></pre>
<p>Our final task for today on the API is building a route for fetching a single pet. Our tests need to handle three situations:</p>
<ul>
<li>An unauthorised request</li>
<li>A request for a pet that does not exist</li>
<li>A request for a pet that does exist</li>
</ul>
<p>Add these methods to <code>tests/PetControllerTest.php</code>:</p>
<pre><code class="lang-php">    /**
     * Test fetching pet when unauthorised
     *
     * @return void
     */
    public function testFetchingPetWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Send request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pet which does not exist
     *
     * @return void
     */
    public function testFetchingPetDoesNotExist()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/1&#39;, [], $headers);
        $this-&gt;assertResponseStatus(404);
    }

    /**
     * Test fetching pet when authorised
     *
     * @return void
     */
    public function testFetchingPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id, [], $headers)
            -&gt;seeJsonStructure([
                &#39;id&#39;,
                &#39;name&#39;,
                &#39;type&#39;,
                &#39;available&#39;,
                &#39;picture&#39;,
                &#39;created_at&#39;,
                &#39;updated_at&#39;
            ]);
        $this-&gt;assertResponseStatus(200);
    }
</code></pre>
<p>Let’s check our tests fail:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.....FE..                                                           9 / 9 (100%)

Time: 974 ms, Memory: 16.00MB

There was 1 error:

1) PetControllerTest::testFetchingPet
PHPUnit_Framework_Exception: Argument #2 (No Value) of PHPUnit_Framework_Assert::assertArrayHasKey() must be a array or ArrayAccess

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:304
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:145

--

There was 1 failure:

1) PetControllerTest::testFetchingPetDoesNotExist
Expected status code 404, got 400.
Failed asserting that 400 matches expected 404.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:112

ERRORS!
Tests: 9, Assertions: 31, Errors: 1, Failures: 1.
</code></pre>
<p>Now, we already have the <code>show()</code> method hooked up by default, so we just have to implement it in <code>app/Http/Controllers/PetController.php</code>:</p>
<pre><code class="lang-php">    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($pet, 200);
    }
</code></pre>
<p>And let’s run our tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.........                                                           9 / 9 (100%)

Time: 693 ms, Memory: 16.00MB

OK (9 tests, 39 assertions)
</code></pre>
<p>Now we have all the endpoints we need to get started with the app. You can find the source code for this backend on <a href="https://github.com/matthewbdaly/mynewanimalfriend-backend">Github</a> - check out the <code>lesson-1</code> tag.</p>
<p>That seems like a good place to stop for now. We have our first pass at the back end. It’s not complete by any means, but it’s a good start, and is sufficient for us to get some basic functionality up and running in the app. In the next instalment we’ll start working with Phonegap to build the first pass at the app itself. Later instalments will see us working with both the app and backend to build it into a more useful whole.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Deploying new versions of a Laravel app with Fabric]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/09/05/deploying-new-versions-of-a-laravel-app-with-fabric/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/09/05/deploying-new-versions-of-a-laravel-app-with-fabric/</guid>
            <pubDate>Mon, 05 Sep 2016 21:22:16 GMT</pubDate>
            <description><![CDATA[<p><a href="https://laravel.com/docs/5.3/envoy">Envoy</a> is the official way to run tasks on a remote server for Laravel apps. A typical Envoy task for deploying a new version might look like this:</p>
<pre><code class="lang-blade">@servers([&#39;web&#39; =&gt; &#39;matthew@server1.example.com&#39;])

@task(&#39;deploy&#39;, [&#39;on&#39; =&gt; &#39;web&#39;])
    cd /var/www
    sudo chown -R matthew:matthew .
    git pull origin master
    php artisan migrate
    php artisan view:clear
    composer dump-autoload
    sudo chown -R www-data:www-data .
    sudo supervisorctl restart mail-queue
@endtask
</code></pre>
<p>This would be defined in <code>Envoy.blade.php</code>. With this in place, and Envoy set up globally, you can then run <code>envoy run deploy</code> to run the <code>deploy</code> command.</p>
<p>However, Envoy requires the PHP SSH library, which I haven’t been able to get working with PHP 7. Fortunately I was already familiar with <a href="http://www.fabfile.org/">Fabric</a>, which makes an excellent alternative as long as you don’t mind writing the task in Python.</p>
<p>The same kind of task might look like this in a Fabric script, saved as <code>fabfile.py</code>:</p>
<pre><code class="lang-python">#!/usr/bin/env python
from fabric.api import local, env, run, sudo
from fabric.context_managers import cd, prefix

env.hosts = [&#39;server1.example.com&#39;]
env.path = &quot;/var/www&quot;
env.user = &quot;matthew&quot;
env.password = &quot;password&quot;
# Or...
env.key_filename = &#39;/path/to/ssh/key&#39;

def deploy():
    &quot;&quot;&quot;
    Deploy the latest version
    &quot;&quot;&quot;
    # Push changes to Bitbucket
    local(&quot;git push origin master&quot;)

    # Switch to project directory
    with cd(env.path):
        # Change owner
        sudo(&#39;chown -R matthew:matthew .&#39;)

        # Pull changes to server
        run(&#39;git pull origin master&#39;)

        # Run migrations
        run(&#39;php artisan migrate&#39;)

        # Clear cached files
        run(&#39;php artisan view:clear&#39;)
        run(&#39;composer dump-autoload&#39;)

        # Change owner back
        sudo(&#39;chown -R www-data:www-data .&#39;)

        # restart mail queue
        sudo(&#39;supervisorctl restart mail-queue&#39;)
</code></pre>
<p>Then, assuming Fabric is already installed locally, you can run <code>fab deploy</code> to push up the latest revision.</p>
<p>Either of these solutions will do a fine job of deploying your app. If you do need to store user-specific data in your Fabric script, it’s probably prudent to keep it out of version control.</p>
<p>Whichever way you choose, it’s a really good idea to do what you can to automate deployment. It can be a boring, repetitive job, and both of these solutions make it much easier.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Testing your API documentation with Dredd]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/08/08/testing-your-api-documentation-with-dredd/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/08/08/testing-your-api-documentation-with-dredd/</guid>
            <pubDate>Mon, 08 Aug 2016 16:05:00 GMT</pubDate>
            <description><![CDATA[<p>Documenting your API is something most developers agree is generally a Good Thing, but it’s a pain in the backside, and somewhat boring to do. What you really need is a tool that allows you to specify the details of your API before you start work, generate documentation from that specification, and test your implementation against that specification.</p>
<p>Fortunately, such a tool exists. The <a href="https://apiblueprint.org/">Blueprint</a> specification allows you to document your API using a Markdown-like syntax. You can then create HTML documentation using a tool like <a href="https://github.com/danielgtaylor/aglio">Aglio</a> or <a href="https://apiary.io/">Apiary</a>, and test it against your implementation using <a href="https://github.com/apiaryio/dredd">Dredd</a>.</p>
<p>In this tutorial we’ll implement a very basic REST API using the Lumen framework. We’ll first specify our API, then we’ll implement routes to match the implementation. In the process, we’ll demonstrate the Blueprint specification in action.</p>
<h2 id="getting-started">Getting started</h2>
<p>Assuming you already have PHP 5.6 or better and Composer installed, run the following command to create our Lumen app skeleton:</p>
<pre><code class="lang-bash">$ composer create-project --prefer-dist laravel/lumen demoapi
</code></pre>
<p>Once it has finished installing, we’ll also need to add the Dredd hooks:</p>
<pre><code class="lang-bash">$ cd demoapi
$ composer require ddelnano/dredd-hooks-php
</code></pre>
<p>We need to install Dredd. It’s a Node.js tool, so you’ll need to have that installed. We’ll also install Aglio to generate HTML versions of our documentation:</p>
<pre><code class="lang-bash">$ npm install -g aglio dredd
</code></pre>
<p>We also need to create a configuration file for Dredd, which you can do by running <code>dredd init</code>. Or you can just copy the one below:</p>
<pre><code class="lang-yml">dry-run: null
hookfiles: null
language: php
sandbox: false
server: &#39;php -S localhost:3000 -t public/&#39;
server-wait: 3
init: false
custom:
  apiaryApiKey: &#39;&#39;
names: false
only: []
reporter: apiary
output: []
header: []
sorted: false
user: null
inline-errors: false
details: false
method: []
color: true
level: info
timestamp: false
silent: false
path: []
hooks-worker-timeout: 5000
hooks-worker-connect-timeout: 1500
hooks-worker-connect-retry: 500
hooks-worker-after-connect-wait: 100
hooks-worker-term-timeout: 5000
hooks-worker-term-retry: 500
hooks-worker-handler-host: localhost
hooks-worker-handler-port: 61321
config: ./dredd.yml
blueprint: apiary.apib
endpoint: &#39;http://localhost:3000&#39;
</code></pre>
<p>If you choose to run <code>dredd init</code>, you’ll see prompts for a number of things, including:</p>
<ul>
<li>The server command</li>
<li>The blueprint file name</li>
<li>The endpoint</li>
<li>Any Apiary API key</li>
<li>The language you want to use</li>
</ul>
<p>There are Dredd hooks for many languages, so if you’re planning on building a REST API in a language other than PHP, don’t worry - you can still test it with Dredd, you’ll just get prompted to install different hooks.</p>
<p>Note the <code>hookfiles</code> section, which specifies a hookfile to run during the test in order to set up the API. We’ll touch on that in a moment. Also, note the <code>server</code> setting - this specifies the command we should call to run the server. In this case we’re using the PHP development server.</p>
<p>If you’re using Apiary with your API (which I highly recommend), you can also set the following parameter to ensure that every time you run Dredd, it submits the results to Apiary:</p>
<pre><code class="lang-yml">custom:
  apiaryApiKey: &lt;API KEY HERE&gt;
  apiaryApiName: &lt;API NAME HERE&gt;
</code></pre>
<h2 id="hookfiles">Hookfiles</h2>
<p>As mentioned, the hooks allow you to set up your API. In our case, we’ll need to set up some fixtures for our tests.  Save this file at <code>tests/dredd/hooks/hookfile.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Dredd\Hooks;
use Illuminate\Support\Facades\Artisan;

require __DIR__ . &#39;/../../../vendor/autoload.php&#39;;

$app = require __DIR__ . &#39;/../../../bootstrap/app.php&#39;;

$app-&gt;make(\Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();

Hooks::beforeAll(function (&amp;$transaction) use ($app) {
   putenv(&#39;DB_CONNECTION=sqlite&#39;);
   putenv(&#39;DB_DATABASE=:memory:&#39;);
   Artisan::call(&#39;migrate:refresh&#39;);
   Artisan::call(&#39;db:seed&#39;);
});
Hooks::beforeEach(function (&amp;$transaction) use ($app) {
   Artisan::call(&#39;migrate:refresh&#39;);
   Artisan::call(&#39;db:seed&#39;);
});
</code></pre>
<p>Before the tests run, we set the environment up to use an in-memory SQLite database. We also migrate and seed the database, so we’re working with a clean database. As part of this tutorial, we’ll create seed files for the fixtures we need in the database.</p>
<p>This hookfile assumes that the user does not need to be authenticated to communicate with the API. If that’s not the case for your API, you may want to include something like this in your hookfile’s <code>beforeEach</code> callback:</p>
<pre><code class="lang-php">   $user = App\User::first();
   $token = JWTAuth::fromUser($user);
   $transaction-&gt;request-&gt;headers-&gt;Authorization = &#39;Bearer &#39; . $token;
</code></pre>
<p>Here we’re using the <a href="https://github.com/tymondesigns/jwt-auth">JWT Auth</a> package for Laravel to authenticate users of our API, and we need to set the <code>Authorization</code> header to contain a valid JSON web token for the given user. If you’re using a different method, such as HTTP Basic authentication, you’ll need to amend this code to reflect that.</p>
<p>With that done, we need to create the Blueprint file for our API. Recall the following line in <code>dredd.yml</code>:</p>
<pre><code class="lang-yml">blueprint: apiary.apib
</code></pre>
<p>This specifies the path to our documentation. Let’s create that file:</p>
<pre><code class="lang-bash">$ touch apiary.apib
</code></pre>
<p>Once this is done, you should be able to run Dredd:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
warn: Parser warning in file &#39;apiary.apib&#39;: (warning code undefined) Could not recognize API description format. Falling back to API Blueprint by default.
info: Beginning Dredd testing...
complete: Tests took 619ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/4aab4155-cfc4-4fda-983a-fea280933ad4
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>With that done, we’re ready to start work on our API.</p>
<h2 id="our-first-route">Our first route</h2>
<p>Dredd is not a testing tool in the usual sense. Under no circumstances should you use it as a substitute for something like PHPUnit - that’s not what it’s for. It’s for ensuring that your documentation and your implementation remain in sync. However, it’s not entirely impractical to use it as a Behaviour-driven development tool in the same vein as Cucumber or Behat - you can use it to plan out the endpoints your API will have, the requests they accept, and the responses they return, and then verify your implementation against the documentation.</p>
<p>We will only have a single endpoint, in order to keep this tutorial as simple and concise as possible. Our endpoint will expose products for a shop, and will allow users to fetch, create, edit and delete products. Note that we won’t be implementing any kind of authentication, which in production is almost certainly not what you want - we’re just going for the simplest possible implementation.</p>
<p>First, we’ll implement getting a list of products:</p>
<pre><code class="lang-markdown">FORMAT: 1A

# Demo API

# Products [/api/products]
Product object representation

## Get products [GET /api/products]
Get a list of products

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
                &quot;id&quot;: 1,
                &quot;name&quot;: &quot;Purple widget&quot;,
                &quot;description&quot;: &quot;A purple widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: {
                    &quot;colour&quot;: &quot;Purple&quot;,
                    &quot;size&quot;: &quot;Small&quot;
                }
            }
</code></pre>
<p>A little explanation is called for. First the <code>FORMAT</code> section denotes the version of the API. Then, the <code># Demo API</code> section denotes the name of the API.</p>
<p>Next, we define the <code>Products</code> endpoint, followed by our first method. Then we define what should be contained in the request, and what the response should look like. Blueprint is a little more complex than that, but that’s sufficient to get us started.</p>
<p>Then we run <code>dredd</code> again:</p>
<pre><code class="lang-bash">$ dredd.yml
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
fail: GET /api/products duration: 61ms
info: Displaying failed tests...
fail: GET /api/products duration: 61ms
fail: headers: Header &#39;content-type&#39; has value &#39;text/html; charset=UTF-8&#39; instead of &#39;application/json&#39;
body: Can&#39;t validate real media type &#39;text/plain&#39; against expected media type &#39;application/json&#39;.
statusCode: Status code is not &#39;200&#39;

request: 
method: GET
uri: /api/products
headers: 
    Content-Type: application/json
    User-Agent: Dredd/1.5.0 (Linux 4.4.0-31-generic; x64)

body: 



expected: 
headers: 
    Content-Type: application/json

body: 
{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Purple widget&quot;,
  &quot;description&quot;: &quot;A purple widget&quot;,
  &quot;price&quot;: 5.99,
  &quot;attributes&quot;: {
    &quot;colour&quot;: &quot;Purple&quot;,
    &quot;size&quot;: &quot;Small&quot;
  }
}
statusCode: 200


actual: 
statusCode: 404
headers: 
    host: localhost:3000
    connection: close
    x-powered-by: PHP/7.0.8-0ubuntu0.16.04.2
    cache-control: no-cache
    date: Mon, 08 Aug 2016 10:30:33 GMT
    content-type: text/html; charset=UTF-8

body: 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt;
        &lt;style&gt;
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:&#39;&#39;;}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}
            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
                        .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; cursor: default; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, &quot;Times New Roman&quot;, Times, serif }
            .sf-reset .exception_counter { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; float: left; display: block; }
            .sf-reset .exception_title { margin-left: 3em; margin-bottom: 0.7em; display: block; }
            .sf-reset .exception_message { margin-left: 3em; display: block; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset a { background:none; color:#868686; text-decoration:none; }
            .sf-reset a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
                    &lt;div id=&quot;sf-resetcontent&quot; class=&quot;sf-reset&quot;&gt;
                &lt;h1&gt;Sorry, the page you are looking for could not be found.&lt;/h1&gt;
                                        &lt;h2 class=&quot;block_exception clear_fix&quot;&gt;
                            &lt;span class=&quot;exception_counter&quot;&gt;1/1&lt;/span&gt;
                            &lt;span class=&quot;exception_title&quot;&gt;&lt;abbr title=&quot;Symfony\Component\HttpKernel\Exception\NotFoundHttpException&quot;&gt;NotFoundHttpException&lt;/abbr&gt; in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 450&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 450&lt;/a&gt;:&lt;/span&gt;
                            &lt;span class=&quot;exception_message&quot;&gt;&lt;/span&gt;
                        &lt;/h2&gt;
                        &lt;div class=&quot;block&quot;&gt;
                            &lt;ol class=&quot;traces list_exception&quot;&gt;
       &lt;li&gt; in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 450&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 450&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;handleDispatcherResponse(&lt;em&gt;array&lt;/em&gt;(&#39;0&#39;)) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 387&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 387&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;Laravel\Lumen\Concerns\{closure}() in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 636&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 636&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;sendThroughPipeline(&lt;em&gt;array&lt;/em&gt;(), &lt;em&gt;object&lt;/em&gt;(&lt;abbr title=&quot;Closure&quot;&gt;Closure&lt;/abbr&gt;)) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 389&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 389&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;dispatch(&lt;em&gt;null&lt;/em&gt;) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 334&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 334&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;run() in &lt;a title=&quot;/home/matthew/Projects/demoapi/public/index.php line 28&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;index.php line 28&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;

            &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;



complete: 0 passing, 1 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 533ms
[Mon Aug  8 11:30:33 2016] 127.0.0.1:44472 [404]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/0153d5bf-6efa-4fdb-b02a-246ddd75cb14
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Our route is returning HTML, not JSON, and is also raising a 404 error. So let’s fix that. First, let’s create our <code>Product</code> model at <code>app/Product.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    //
}
</code></pre>
<p>Next, we need to create a migration for the database tables for the <code>Product</code> model:</p>
<pre><code class="lang-bash">$ php artisan make:migration create_product_table
Created Migration: 2016_08_08_105737_create_product_table
</code></pre>
<p>This will create a new file under <code>database/migrations</code>. Open this file and paste in the following:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateProductTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // Create products table
        Schema::create(&#39;products&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;name&#39;);
            $table-&gt;text(&#39;description&#39;);
            $table-&gt;float(&#39;price&#39;);
            $table-&gt;json(&#39;attributes&#39;);
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Drop products table
        Schema::drop(&#39;products&#39;);
    }
}
</code></pre>
<p>Note that we create fields that map to the attributes our API exposes. Also, note the use of the JSON field. In databases that support it, like PostgreSQL, it uses the native JSON support, otherwise it works like a text field. Next, we run the migration to create the table:</p>
<pre><code class="lang-bash">$ php artisan migrate
Migrated: 2016_08_08_105737_create_product_table
</code></pre>
<p>With our model done, we now need to ensure that when Dredd runs, there is some data in the database, so we’ll create a seeder file at <code>database/seeds/ProductSeeder</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class ProductSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add product
        DB::table(&#39;products&#39;)-&gt;insert([
            &#39;name&#39; =&gt; &#39;Purple widget&#39;,
            &#39;description&#39; =&gt; &#39;A purple widget&#39;,
            &#39;price&#39; =&gt; 5.99,
            &#39;attributes&#39; =&gt; json_encode([
                &#39;colour&#39; =&gt; &#39;purple&#39;,
                &#39;size&#39; =&gt; &#39;Small&#39;
            ]),
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ]);
    }
}
</code></pre>
<p>You also need to amend <code>database/seeds/DatabaseSeeder</code> to call it:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(&#39;ProductSeeder&#39;);
    }
}
</code></pre>
<p>I found I also had to run the following command to find the new seeder:</p>
<pre><code class="lang-bash">$ composer dump-autoload
</code></pre>
<p>Then, call the seeder:</p>
<pre><code class="lang-bash">$ php artisan db:seed
Seeded: ProductSeeder
</code></pre>
<p>We also need to enable Eloquent, as Lumen disables it by default. Uncomment the following line in <code>bootstrap/app.php</code>:</p>
<pre><code class="lang-php">$app-&gt;withEloquent();
</code></pre>
<p>With that done, we can move onto the controller.</p>
<h2 id="creating-the-controller">Creating the controller</h2>
<p>Create the following file at <code>app/Http/Controllers/ProductController</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Product;

class ProductController extends Controller
{
    private $product;

    public function __construct(Product $product) {
        $this-&gt;product = $product;
    }

    public function index()
    {
        // Get all products
        $products = $this-&gt;product-&gt;all();

        // Send response
        return response()-&gt;json($products, 200);
    }
}
</code></pre>
<p>This implements the <code>index</code> route. Note that we inject the <code>Product</code> instance into the controller. Next, we need to hook it up in <code>app/Http/routes.php</code>:</p>
<pre><code class="lang-php">&lt;?php

/*
|--------------------------------------------------------------------------
| Application Routes
|--------------------------------------------------------------------------
|
| Here is where you can register all of the routes for an application.
| It is a breeze. Simply tell Lumen the URIs it should respond to
| and give it the Closure to call when that URI is requested.
|
*/

$app-&gt;get(&#39;/api/products&#39;, &#39;ProductController@index&#39;);
</code></pre>
<p>Then we run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
[Mon Aug  8 12:36:28 2016] 127.0.0.1:45466 [200]: /api/products
fail: GET /api/products duration: 131ms
info: Displaying failed tests...
fail: GET /api/products duration: 131ms
fail: body: At &#39;&#39; Invalid type: array (expected object)

request: 
method: GET
uri: /api/products
headers: 
    Content-Type: application/json
    User-Agent: Dredd/1.5.0 (Linux 4.4.0-31-generic; x64)

body: 



expected: 
headers: 
    Content-Type: application/json

body: 
{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Purple widget&quot;,
  &quot;description&quot;: &quot;A purple widget&quot;,
  &quot;price&quot;: 5.99,
  &quot;attributes&quot;: {
    &quot;colour&quot;: &quot;Purple&quot;,
    &quot;size&quot;: &quot;Small&quot;
  }
}
statusCode: 200


actual:
statusCode: 200
headers:
    host: localhost:3000
    connection: close
    x-powered-by: PHP/7.0.8-0ubuntu0.16.04.2
    cache-control: no-cache
    content-type: application/json
    date: Mon, 08 Aug 2016 11:36:28 GMT

body:
[ 
  { 
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Purple widget&quot;,
    &quot;description&quot;: &quot;A purple widget&quot;,
    &quot;price&quot;: &quot;5.99&quot;,
    &quot;attributes&quot;: &quot;{\&quot;colour\&quot;:\&quot;purple\&quot;,\&quot;size\&quot;:\&quot;Small\&quot;}&quot;,
    &quot;created_at&quot;: &quot;2016-08-08 11:32:24&quot;,
    &quot;updated_at&quot;: &quot;2016-08-08 11:32:24&quot;
  }
]



complete: 0 passing, 1 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 582ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/83da2d67-c846-4356-a3b8-4d7c32daa7ef
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Whoops, looks like we made a mistake here. The index route returns an array of objects, but we’re looking for a single object in the blueprint. We also need to wrap our attributes in quotes, and add the <code>created_at</code> and <code>updated_at</code> attributes. Let’s fix the blueprint:</p>
<pre><code class="lang-markdown">FORMAT: 1A

# Demo API

# Products [/api/products]
Product object representation

## Get products [GET /api/products]
Get a list of products

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            [
                {
                    &quot;id&quot;: 1,
                    &quot;name&quot;: &quot;Purple widget&quot;,
                    &quot;description&quot;: &quot;A purple widget&quot;,
                    &quot;price&quot;: 5.99,
                    &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;Purple\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
                    &quot;created_at&quot;: &quot;*&quot;,
                    &quot;updated_at&quot;: &quot;*&quot;
                }
            ]
</code></pre>
<p>Let’s run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 65ms
complete: 1 passing, 0 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 501ms
[Mon Aug  8 13:05:54 2016] 127.0.0.1:45618 [200]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/7c23d4ae-aff2-4daf-bbdf-9fd76fc58b97
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>And now we can see that our test passes.</p>
<p>Next, we’ll implement a test for fetching a single product:</p>
<pre><code class="lang-markdown">## Get a product [GET /api/products/1]
Get a single product

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
              &quot;id&quot;: 1,
              &quot;name&quot;: &quot;Purple widget&quot;,
              &quot;description&quot;: &quot;A purple widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;Purple\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>Note the same basic format - we define the URL that should be fetched, the content of the request, and the response, including the status code.</p>
<p>Let’s hook up our route in <code>app/Http/routes.php</code>:</p>
<pre><code class="lang-php">$app-&gt;get(&#39;/api/products/{id}&#39;, &#39;ProductController@show&#39;);
</code></pre>
<p>And add the <code>show()</code> method to the controller:</p>
<pre><code class="lang-php">    public function show($id)
    {
        // Get individual product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($product, 200);
    }
</code></pre>
<p>Running Dredd again should show this method has been implemented:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 66ms
[Mon Aug  8 13:21:31 2016] 127.0.0.1:45750 [200]: /api/products
pass: GET /api/products/1 duration: 17ms
complete: 2 passing, 0 failing, 0 errors, 0 skipped, 2 total
complete: Tests took 521ms
[Mon Aug  8 13:21:31 2016] 127.0.0.1:45752 [200]: /api/products/1
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/bb6d03c3-8fad-477c-b140-af6e0cc8b96c
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>That’s our read support done. We just need to add support for <code>POST</code>, <code>PATCH</code> and <code>DELETE</code> methods.</p>
<h2 id="our-remaining-methods">Our remaining methods</h2>
<p>Let’s set up the test for our <code>POST</code> method first:</p>
<pre><code class="lang-markdown">## Create products [POST /api/products]
Create a new product

+ name (string) - The product name
+ description (string) - The product description
+ price (float) - The product price
+ attributes (string) - The product attributes

+ Request (application/json)
    + Body

            {
                &quot;name&quot;: &quot;Blue widget&quot;,
                &quot;description&quot;: &quot;A blue widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;
            }

+ Response 201 (application/json)
    + Body

            {
              &quot;id&quot;: 2,
              &quot;name&quot;: &quot;Blue widget&quot;,
              &quot;description&quot;: &quot;A blue widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>Note we specify the format of the parameters that should be passed through, and that our status code should be 201, not 200 - this is arguably a more correct choice for creating a resource. Be careful of the whitespace - I had some odd issues with it. Next, we add our route:</p>
<pre><code class="lang-php">$app-&gt;post(&#39;/api/products&#39;, &#39;ProductController@store&#39;);
</code></pre>
<p>And the <code>store()</code> method in the controller:</p>
<pre><code class="lang-php">    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;description&#39; =&gt; &#39;required|string&#39;,
            &#39;price&#39; =&gt; &#39;required|numeric&#39;,
            &#39;attributes&#39; =&gt; &#39;string&#39;,
        ]);

        // Create product
        $product = new $this-&gt;product;
        $product-&gt;name = $request-&gt;input(&#39;name&#39;);
        $product-&gt;description = $request-&gt;input(&#39;description&#39;);
        $product-&gt;price = $request-&gt;input(&#39;price&#39;);
        $product-&gt;attributes = $request-&gt;input(&#39;attributes&#39;);

        // Save product
        $product-&gt;save();

        // Send response
        return response()-&gt;json($product, 201);
    }
</code></pre>
<p>Note that we validate the attributes, to ensure they are correct and that the required ones exist. Running Dredd again should show the route is now in place:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 69ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47316 [200]: /api/products
pass: GET /api/products/1 duration: 18ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47318 [200]: /api/products/1
pass: POST /api/products duration: 42ms
complete: 3 passing, 0 failing, 0 errors, 0 skipped, 3 total
complete: Tests took 575ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47322 [201]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/cb5971cf-180d-47ed-abf4-002378941134
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Next, we’ll implement <code>PATCH</code>. This targets an existing object, but accepts parameters in the same way as <code>POST</code>:</p>
<pre><code class="lang-markdown">## Update existing products [PATCH /api/products/1]
Update an existing product

+ name (string) - The product name
+ description (string) - The product description
+ price (float) - The product price
+ attributes (string) - The product attributes

+ Request (application/json)
    + Body

            {
                &quot;name&quot;: &quot;Blue widget&quot;,
                &quot;description&quot;: &quot;A blue widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;
            }

+ Response 200 (application/json)
    + Body

            {
              &quot;id&quot;: 2,
              &quot;name&quot;: &quot;Blue widget&quot;,
              &quot;description&quot;: &quot;A blue widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>We add our new route:</p>
<pre><code class="lang-php">$app-&gt;patch(&#39;/api/products/{id}&#39;, &#39;ProductController@update&#39;);
</code></pre>
<p>And our <code>update()</code> method:</p>
<pre><code class="lang-php">    public function update(Request $request, $id)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;name&#39; =&gt; &#39;string&#39;,
            &#39;description&#39; =&gt; &#39;string&#39;,
            &#39;price&#39; =&gt; &#39;numeric&#39;,
            &#39;attributes&#39; =&gt; &#39;string&#39;,
        ]);

        // Get product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Update it
        if ($request-&gt;has(&#39;name&#39;)) {
            $product-&gt;name = $request-&gt;input(&#39;name&#39;);
        }
        if ($request-&gt;has(&#39;description&#39;)) {
            $product-&gt;description = $request-&gt;input(&#39;description&#39;);
        }
        if ($request-&gt;has(&#39;price&#39;)) {
            $product-&gt;price = $request-&gt;input(&#39;price&#39;);
        }
        if ($request-&gt;has(&#39;attributes&#39;)) {
            $product-&gt;attributes = $request-&gt;input(&#39;attributes&#39;);
        }

        // Save product
        $product-&gt;save();

        // Send response
        return response()-&gt;json($product, 200);
    }
</code></pre>
<p>Here we can’t guarantee every parameter will exist, so we test for it. We run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 74ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47464 [200]: /api/products
pass: GET /api/products/1 duration: 19ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47466 [200]: /api/products/1
pass: POST /api/products duration: 36ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47470 [201]: /api/products
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47474 [200]: /api/products/1
pass: PATCH /api/products/1 duration: 34ms
complete: 4 passing, 0 failing, 0 errors, 0 skipped, 4 total
complete: Tests took 2579ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/eae98644-44ad-432f-90fc-5f73fa674f66
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>One last method to implement - the <code>DELETE</code> method. Add this to <code>apiary.apib</code>:</p>
<pre><code class="lang-markdown">## Delete products [DELETE /api/products/1]
Delete an existing product

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
                &quot;status&quot;: &quot;Deleted&quot;
            }
</code></pre>
<p>Next, add the route:</p>
<pre><code class="lang-php">$app-&gt;delete(&#39;/api/products/{id}&#39;, &#39;ProductController@destroy&#39;);
</code></pre>
<p>And the <code>destroy()</code> method in the controller:</p>
<pre><code class="lang-php">    public function destroy($id)
    {
        // Get product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Delete product
        $product-&gt;delete();

        // Return empty response
        return response()-&gt;json([&#39;status&#39; =&gt; &#39;deleted&#39;], 200);
    }
</code></pre>
<p>And let’s run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 66ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48664 [200]: /api/products
pass: GET /api/products/1 duration: 19ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48666 [200]: /api/products/1
pass: POST /api/products duration: 45ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48670 [201]: /api/products
pass: PATCH /api/products/1 duration: 24ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48674 [200]: /api/products/1
pass: DELETE /api/products/1 duration: 27ms
complete: 5 passing, 0 failing, 0 errors, 0 skipped, 5 total
complete: Tests took 713ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48678 [200]: /api/products/1
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/a3e11d59-1dad-404b-9319-61ca5c0fcd15
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Our REST API is now finished.</p>
<h2 id="generating-html-version-of-your-documentation">Generating HTML version of your documentation</h2>
<p>Now we have finished documenting and implementing our API, we need to generate an HTML version of it. One way is to use <code>aglio</code>:</p>
<pre><code class="lang-bash">$ aglio -i apiary.apib -o output.html
</code></pre>
<p>This will write the documentation to <code>output.html</code>. There’s also scope for choosing different themes if you wish.</p>
<p>You can also use Apiary, which has the advantage that they’ll create a stub of your API so that if you need to work with the API before it’s finished being implemented, you can use that as a placeholder.</p>
<h2 id="summary">Summary</h2>
<p>The Blueprint language is a useful way of documenting your API, and makes it simple enough that it’s hard to weasel out of doing so. It’s worth taking a closer look at <a href="https://apiblueprint.org/">the specification</a> as it goes into quite a lot of detail. It’s hard to ensure that the documentation and implementation remain in sync, so it’s a good idea to use Dredd to ensure that any changes you make don’t invalidate the documentation. With Aglio or Apiary, you can easily convert the documentation into a more attractive format.</p>
<p>You’ll find the source code for this demo API <a href="https://github.com/matthewbdaly/demoapi">on Github</a>, so if you get stuck, take a look at that. I did have a fair few issues with whitespace, so bear that in mind if it behaves oddly. I’ve also noticed a few quirks, such as Dredd not working properly if a route returns a 204 response code, which is why I couldn’t use that for deleting - this <a href="https://github.com/apiaryio/dredd/issues/468">appears to be a bug</a>, but hopefully this will be resolved soon.</p>
<p>I’ll say it again, Dredd is not a substitute for proper unit tests, and under no circumstances should you use it as one. However, it can be very useful as a way to plan how your API will work and ensure that it complies with that plan, and to ensure that the implementation and documentation don’t diverge. Used as part of your normal continuous integration setup, Dredd can make sure that any divergence between the docs and the application is picked up on and fixed as quickly as possible, while also making writing documentation less onerous.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Broadcasting events with Laravel and Socket.io]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/05/14/broadcasting-events-with-laravel-and-socket-dot-io/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/05/14/broadcasting-events-with-laravel-and-socket-dot-io/</guid>
            <pubDate>Sat, 14 May 2016 20:00:00 GMT</pubDate>
            <description><![CDATA[<p>PHP frameworks like Laravel aren’t really set up to handle real-time events properly, so if you want to build a real-time app, you’re generally better off with another platform, such as Node.js. However, if that only forms a small part of your application, you may still prefer to work with PHP. Fortunately it’s fairly straightforward to hand off the real-time aspects of your application to a dedicated microservice written using Node.js and still use Laravel to handle the rest of the functionality.</p>
<p>Here I’ll show you how I built a Laravel app that uses a separate Node.js script to handle sending real-time updates to the user.</p>
<h2 id="events-in-laravel">Events in Laravel</h2>
<p>In this case, I was building a REST API to serve as the back end for a Phonegap app that allowed users to message each other. The API includes an endpoint that allows users to create and fetch messages. Now, in theory, we could just repeatedly poll the endpoint for new messages, but that would be inefficient. What we needed was a way to notify users of new messages in real time, which seemed like the perfect opportunity to use Socket.io.</p>
<p>Laravel comes with a simple, but robust system that allows you to broadcast events to a Redis server. Another service can then listen for these events and carry out jobs on them, and there is no reason why this service has to be written in PHP. This makes it easy to decouple your application into smaller parts. In essence the functionality we wanted was as follows:</p>
<ul>
<li>Receive message</li>
<li>Push message to Redis</li>
<li>Have a separate service pick up message on Redis</li>
<li>Push message to clients</li>
</ul>
<p>First off, we need to define an event in our Laravel app. You can create a boilerplate with the following Artisan command:</p>
<pre><code class="lang-bash">$ php artisan make:event NewMessage
</code></pre>
<p>This will create the file <code>app/Events/NewMessage.php</code>. You can then customise this as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Events;

use App\Events\Event;
use App\Message;
use Illuminate\Queue\SerializesModels;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;

class NewMessage extends Event implements ShouldBroadcast
{
    use SerializesModels;

    public $message;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct(Message $message)
    {
        // Get message
        $this-&gt;message = $message;
    }

    /**
     * Get the channels the event should be broadcast on.
     *
     * @return array
     */
    public function broadcastOn()
    {
        return [&#39;room_&#39;.$this-&gt;message-&gt;room_id];
    }
}
</code></pre>
<p>This particular event is a class that accepts a single argument, which is an instance of the <code>Message</code> model. This model includes an attribute of <code>room_id</code> that is used to determine which room the message is posted to - note that this is returned in the <code>broadcastOn()</code> method.</p>
<p>When we want to trigger our new event, we can do so as follows:</p>
<pre><code class="lang-php">use App\Events\NewMessage;
Event::fire(new NewMessage($message));
</code></pre>
<p>Here, <code>$message</code> is the saved Eloquent object containing the message. Note the use of <code>SerializesModels</code> - this means that the Eloquent model is serialized into JSON when broadcasting the event.</p>
<p>We also need to make sure Redis is set as our broadcast driver. Ensure the Composer package <code>predis/predis</code> is installed, and set <code>BROADCAST_DRIVER=redis</code> in your <code>.env</code> file. Also, please note that I found that setting <code>QUEUE_DRIVER=redis</code> in <code>.env</code> as well broke the broadcasting system, so it looks like you can’t use Redis as both a queue and a broadcasting system unless you set up multiple connections.</p>
<p>Next, we need another server-side script to handle processing the received events and pushing the messages out. In my case, this was complicated by the fact that we were using HTTPS, courtesy of Let’s Encrypt. I installed the required dependencies for the Node.js script as follows:</p>
<pre><code class="lang-bash">$ npm install socket.io socket.io-client ioredis --save-dev
</code></pre>
<p>Here’s an example Node.js script for processing the events:</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);
var pkey = fs.readFileSync(&#39;/etc/letsencrypt/live/example.com/privkey.pem&#39;);
var pcert = fs.readFileSync(&#39;/etc/letsencrypt/live/example.com/fullchain.pem&#39;)

var options = {
  key: pkey,
  cert: pcert
};

var app = require(&#39;https&#39;).createServer(options);
var io = require(&#39;socket.io&#39;)(app);

var Redis = require(&#39;ioredis&#39;);
var redis = new Redis();

app.listen(9000, function() {
    console.log(&#39;Server is running!&#39;);
});

function handler(req, res) {
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    res.writeHead(200);
    res.end(&#39;&#39;);
}

io.on(&#39;connection&#39;, function(socket) {
    //
});

redis.psubscribe(&#39;*&#39;, function(err, count) {
    //
});

redis.on(&#39;pmessage&#39;, function(subscribed, channel, message) {
    message = JSON.parse(message);
    console.log(&#39;Channel is &#39; + channel + &#39; and message is &#39; + message);
    io.emit(channel, message.data);
});
</code></pre>
<p>Note we use the <code>https</code> module instead of the <code>http</code> one, and we pass the key and certificate as options to the server. This server runs on port 9000, but feel free to move it to any arbitrary port you wish. In production, you’d normally use something like Supervisor or systemd to run a script like this as a service.</p>
<p>Next, we need a client-side script to connect to the Socket.io instance and handle any incoming messages. Here’s a very basic example that just dumps them to the browser console:</p>
<pre><code class="lang-javascript">var url = window.location.protocol + &#39;//&#39; + window.location.hostname;
var socket = io(url, {
  &#39;secure&#39;: true,
  &#39;reconnect&#39;: true,
  &#39;reconnection delay&#39;: 500,
  &#39;max reconnection attempts&#39;: 10
});
var chosenEvent = &#39;room_&#39; + room.id;
socket.on(chosenEvent, function (data) {
  console.log(data);
});
</code></pre>
<p>Finally, we need to configure our web server. I’m using Nginx with PHP-FPM and PHP 7, and this is how I configured it:</p>
<pre><code class="lang-nginx">upstream websocket {
    server 127.0.0.1:9000;
}

server {
    listen         80;
    server_name example.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name example.com;
    ssl on;
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;
    client_max_body_size 50M;
    server_tokens off;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection &quot;1; mode=block&quot;;

    root /var/www/public;
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip on;
        gzip_proxied any;
        gzip_types text/plain text/css application/javascript application/x-javascript text/xml application/xml application/xml-rss text/javascript text/js application/json;
        expires 1y;
        charset utf-8;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /.well-known {
        root /var/www/public;
        allow all;
    }

    location /socket.io {
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_http_version 1.1;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $host;
        proxy_pass https://websocket;
    }
}
</code></pre>
<p>Any requests to <code>/socket.io</code> are proxied to port 9000, where our chat handling script is listening. Note that we allow the HTTPS connection to be upgraded to a WebSocket one.</p>
<p>Once that’s done, you just need to restart your PHP application and Nginx, and start running your chat script, and everything should be working fine. If it isn’t, the command <code>redis-cli monitor</code> is invaluable in verifying that the event is being published correctly.</p>
<h2 id="summary">Summary</h2>
<p>Getting this all working together did take quite a bit of trial and error, but that was mostly a matter of configuration. Actually implementing this is pretty straightforward, and it’s an easy way to add some basic real-time functionality to an existing Laravel application.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Writing faster Laravel tests]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/04/04/writing-faster-laravel-tests/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/04/04/writing-faster-laravel-tests/</guid>
            <pubDate>Mon, 04 Apr 2016 19:55:15 GMT</pubDate>
            <description><![CDATA[<p>Nowadays, Laravel tends to be my go-to PHP framework, to the point that we use it as our default framework at work. A big part of this is that Laravel is relatively easy to test, making practicing TDD a lot easier.</p>
<p>Out of the box running Laravel tests can be quite slow, which is a big issue - if your test suite takes several minutes to run, that’s a huge disruption. Also, Laravel doesn’t create a dedicated test database - instead it runs the tests against the same database you’re using normally, which is almost always not what you want. I’ll show you how to set up a dedicated test database, and how to use an in-memory SQLite database for faster tests. This results in cleaner and easier-to-maintain tests, since you can be sure the test database is restored to a clean state at the end of every test.</p>
<h2 id="setup">Setup</h2>
<p>Our first step is to make sure that when a new test begins, the following should happen:</p>
<ul>
<li>We should create a new transaction</li>
<li>We should empty and migrate our database</li>
</ul>
<p>Then, at the end of each test:</p>
<ul>
<li>We should roll back our transaction to restore the database to its prior state</li>
</ul>
<p>To do so, we can create custom <code>setUp()</code> and <code>tearDown()</code> methods for our base <code>TestCase</code> class. Save this in <code>tests/TestCase.php</code>:</p>
<pre><code class="lang-php">&lt;?php

class TestCase extends Illuminate\Foundation\Testing\TestCase
{
    /**
     * The base URL to use while testing the application.
     *
     * @var string
     */
    protected $baseUrl = &#39;http://localhost&#39;;
    /**
     * Creates the application.
     *
     * @return \Illuminate\Foundation\Application
     */
    public function createApplication()
    {
        $app = require __DIR__.&#39;/../bootstrap/app.php&#39;;
        $app-&gt;make(Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();
        return $app;
    }

    public function setUp()
    {
        parent::setUp();
        DB::beginTransaction();
        Artisan::call(&#39;migrate:refresh&#39;);
    }

    public function tearDown()
    {
        DB::rollBack();
        parent::tearDown();
    }
}
</code></pre>
<p>That takes care of building up and tearing down our database for each test.</p>
<p>EDIT: Turns out there’s actually a much easier way of doing this already included in Laravel. Just import and add either <code>use DatabaseMigrations;</code> or <code>use DatabaseTransactions;</code> to the <code>TestCase</code> class. The first will roll back the database and migrate it again after each test, while the second wraps each test in a transaction.</p>
<h2 id="using-an-in-memory-sqlite-database-for-testing-purposes">Using an in-memory SQLite database for testing purposes</h2>
<p>It’s not always practical to do this, especially if you rely on database features in PostgreSQL that aren’t available in SQLite, but if it is, it’s probably worth using an in-memory SQLite database for your tests. If you want to do so, here’s some example settings you might want to use in <code>phpunit.xml</code>:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt;
        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<p>This can result in a very significant speed boost.</p>
<p>I would still recommend that you test against your production database, but this can be easily handed off to a continuous integration server such as Jenkins, since that way it won’t disrupt your workflow. </p>
<p>During TDD, you’ll typically run your tests several times for any change you make, so if they’re too slow it can have a disastrous effect on your productivity. But with a few simple changes like this, you can ensure your tests run as quickly as possible. This approach should also be viable for Lumen apps.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[My experience using PHP 7 in production]]></title>
            <link>https://matthewdaly.co.uk/blog/2016/03/18/my-experience-using-php-7-in-production/</link>
            <guid>https://matthewdaly.co.uk/blog/2016/03/18/my-experience-using-php-7-in-production/</guid>
            <pubDate>Fri, 18 Mar 2016 19:42:37 GMT</pubDate>
            <description><![CDATA[<p>In the last couple of weeks I’ve been working on a PHP web app. Nothing unusual there, except this was the first time we’d used PHP 7 in production. We discussed the possibility a while back, and eventually decided that for certain projects we’d use PHP 7 without waiting another year or so (or maybe longer) for a version of Debian stable with it by default. I wanted to talk about how our experience has been using it in production.</p>
<h2 id="background">Background</h2>
<p>We’ve never really had a fixed stack that we work with at work before until recently - it was largely based on personal preferences and experience. For many jobs, especially content-based sites, we generally used WordPress - it has its issues, but it does fine for a lot of work. For more complex websites, I tended to use CodeIgniter because I’d learned it during my previous job and knew it fairly well, but I was not terribly happy with it - it’s a bit too basic and simplistic, as well as being somewhat behind the times, and I only really kept using it through inertia. For mobile app backends, I tended to use Django, partly for the admin interface, and partly because Django REST Framework makes it easy to build a REST API quickly and easily in a way that wasn’t viable with CodeIgniter.</p>
<p>This state of affairs couldn’t really continue. I love Python and Django, but I was the only one at work who had ever used Python, so in the event I got hit by a bus there would have been no-one who could have taken over from me. As for CodeIgniter, it was clearly falling further and further behind the curve, and I was sick of it and looking to replace it. Ideally we needed a PHP framework as both myself and my colleague knew it.</p>
<p>I’d also been playing around with Laravel on a few little projects, but I didn’t get the chance to use it for a new web app until autumn last year. Around the same time, we hired a third developer, who also had some experience using Laravel. In addition, the presence of Lumen meant that we could use that for smaller apps or services that were too small to use Laravel. We therefore decided to adopt Laravel as our default framework - in future we’d only use something else if there was a particular justification for it. I was rather sad to have to abandon Django for work, but pleased to have something more modern than CodeIgniter for PHP projects.</p>
<p>This also enabled us to standardize our new server builds. Over the last year or so I’ve been pushing to automate what we can of our server setup using Ansible. We now have two standard stacks that we plan to use for future projects. One is for WordPress sites and consists of:</p>
<ul>
<li>Debian stable</li>
<li>Apache</li>
<li>MySQL</li>
<li>PHP 5.6</li>
<li>Memcached</li>
<li>Varnish</li>
</ul>
<p>The other is for Laravel or Lumen web apps or APIs and consists of:</p>
<ul>
<li>Debian stable</li>
<li>Nginx</li>
<li>PHP 7</li>
<li>PostgreSQL</li>
<li>Redis</li>
</ul>
<p>It took some time to decide what we wanted to settle on, and indeed we had a mobile app backend that went up around Christmas time that we wrote with Laravel, but deployed to Apache with PHP 5.6 because when we first pushed it up PHP 7 wasn’t out yet. However, given that Laravel 5 already had good support for PHP 7, we decided we’d consider it for the next app. I tend to use PostgreSQL rather than MySQL these days because it has a lot of nifty features like JSON fields and full text search, and using an ORM minimises the learning curve in switching, and Redis is much more versatile than Memcached, so they were vital parts of our stack.</p>
<h2 id="our-first-php-7-app">Our first PHP 7 app</h2>
<p>As it happened, we had a Laravel app in the pipeline that was ideal. In the summer of last year, we were hired to make an existing site responsive. In the end, it turned out not to be viable - it was built with Zend Framework, which none of us had ever touched before, and the front end used a lot of custom widgets and fields tied together with RequireJS. The whole thing was rather unwieldy and extremely difficult to maintain and develop. In the end, we decided to tell the client it wasn’t worth developing further and offer to rewrite the whole thing from scratch using Laravel and AngularJS, with Browserify used to handle JavaScript modules - the basic idea was quite simple, it was just the implementation that was overly complex, and AngularJS made it possible to do the same kind of thing with a fraction of the code, so a rewrite in only a few weeks was perfectly viable.</p>
<p>I’d already built a simple prototype to demonstrate the viability of a from-scratch rewrite using Laravel and Angular, and once the client had agreed to the rewrite, we were able to work on this further. As the web app was going to be particularly useful on mobile devices, I wanted to ensure that the performance was as good as I could possibly make it. By the time we were looking at deploying it to a server, three months had passed since PHP 7 had been first released, and I figured that was long enough for the most serious issues to be resolved, and we could definitely do with the very significant speed boost we’d get from using PHP 7 for this app.</p>
<p>I use Jenkins to run my unit tests, and so I decided to try installing PHP 7 on the Jenkins server and using that to run the tests. The results were encouraging - nothing broke as a result of the switch. So we therefore decided that when we deployed it, we’d try it with PHP 7, and if it failed, we’d switch to PHP 5.6.</p>
<p>I opted to use FPM with Nginx rather than Apache and <code>mod_php</code> as since the web app was purely custom we didn’t really need things like <code>.htaccess</code>, and while the amount of static content was limited, Nginx might well perform better for this use case. The results are fairly encouraging - the document for the home page is typically being returned in under 40ms, with the uncached homepage taking around 1.5s in total to load, despite having to load several external fonts. In its current state, the web app scores a solid 93% on YSlow, which I’m very happy with. I don’t know how much of that is down to using PHP 7, but choosing to use it was definitely a good call. I have had absolutely zero issues with it during that time.</p>
<h2 id="summary">Summary</h2>
<p>As always, you should bear in mind that your needs may not be the same as mine, and it could well be that you need something that PHP 7 doesn’t yet provide. However, I have had a very good experience with PHP 7 in production. I may have had to jump through a few more hoops to get it up and running, and there may be some level of risk associated with using PHP 7 when it’s only been available for three months, but it’s more than justified by the speed we get from our web app. Using a configuration management system like Ansible means that even if you do have to jump through some extra hoops, it’s relatively easy to automate that process so it’s not as much of an issue as you might think. For me, using PHP 7 with a Laravel app has worked as well as I could have possibly hoped.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Setting ETags in Laravel 5]]></title>
            <link>https://matthewdaly.co.uk/blog/2015/06/14/setting-etags-in-laravel-5/</link>
            <guid>https://matthewdaly.co.uk/blog/2015/06/14/setting-etags-in-laravel-5/</guid>
            <pubDate>Sun, 14 Jun 2015 20:29:52 GMT</pubDate>
            <description><![CDATA[<p>Although I’d prefer to use Python or Node.js, there are some times when circumstances dictate that I need to use PHP for a project at work. In the past, I used CodeIgniter, but that was through nothing more than inertia. For some time I’d been planning to switch to Laravel, largely because of the baked-in PHPUnit support, but events conspired against me - one big project that came along had a lot in common with an earlier one, so I forked it rather than starting over.</p>
<p>Recently I built a REST API for a mobile app, and I decided to use that to try out Laravel (if it had been available at the time, I’d have gone for Lumen instead). I was very pleased with the results - I was able to quickly put together the back end I wanted, with good test coverage, and the <code>tinker</code> command in particular was useful in debugging. The end result is fast and efficient, with query caching in place using Memcached to improve response times.</p>
<p>I also implemented a simple middleware to add ETags to HTTP responses and compare them on incoming requests, returning a <code>304 Not Modified</code> status code if they are the same, which is given below:</p>
<pre><code class="lang-php">&lt;?php namespace App\Http\Middleware;

use Closure;

class ETagMiddleware {

    /**
     * Implement Etag support
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        // Get response
        $response = $next($request);

        // If this was a GET request...
        if ($request-&gt;isMethod(&#39;get&#39;)) {
            // Generate Etag
            $etag = md5($response-&gt;getContent());
            $requestEtag = str_replace(&#39;&quot;&#39;, &#39;&#39;, $request-&gt;getETags());

            // Check to see if Etag has changed
            if($requestEtag &amp;&amp; $requestEtag[0] == $etag) {
                $response-&gt;setNotModified();
            }

            // Set Etag
            $response-&gt;setEtag($etag);
        }

        // Send response
        return $response;
    }

}
</code></pre>
<p>This is based on <a href="https://www.nickv.codes/blog/etags-in-laravel-4/">a solution for Laravel 4 by Nick Verwymeren</a>, but implemented as Laravel 5 middleware, not a Laravel 4 filter. To use this with Laravel 5, save this as <code>app/Http/Middleware/ETagMiddleware.php</code>. Then add this to the <code>$middleware</code> array in <code>app/Http/Kernel.php</code>:</p>
<pre><code class="lang-php">        &#39;App\Http\Middleware\ETagMiddleware&#39;,
</code></pre>
<p>It’s quite simple to write this kind of middleware with Laravel, and using something like this is a no-brainer for most web apps considering the bandwidth it will likely save your users.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Running the PHP development server with Laravel]]></title>
            <link>https://matthewdaly.co.uk/blog/2012/12/15/running-the-php-development-server-with-laravel/</link>
            <guid>https://matthewdaly.co.uk/blog/2012/12/15/running-the-php-development-server-with-laravel/</guid>
            <pubDate>Sat, 15 Dec 2012 00:26:00 GMT</pubDate>
            <description><![CDATA[<p>One thing that I’ve really never liked about PHP is the requirement to install a full-blown web server, so I was pleased when PHP 5.4 shipped with a built-in development server. However, it seems like no PHP framework has yet embraced this to the extent that their counterparts for languages like Python have.</p>
<p>I’ve recently decided that CodeIgniter is no longer fulfilling what I need from my main go-to PHP framework, and I’ve been looking at Laravel as a likely replacement. It occurred to me that I could create an Artisan task to run the development server quite easily, and after a little tinkering, I put this together, which worked well:</p>
<pre><code class="lang-php">&lt;?php

class Runserver_Task {

    public function run($arguments)
    {   
        $port = !isset($arguments[0]) ? 8000: $arguments[0];
        echo &#39;Running PHP development server on port &#39;.$port.&#39;...&#39;;
        passthru(&#39;php -S localhost:&#39;.$port.&#39; -t &#39;.getcwd().&#39;/public&#39;);
    }   
}
?&gt;
</code></pre>
<p>Once this is in place, you can just run <code>php artisan runserver</code> to run the development server, and hit <kbd>Ctrl-C</kbd> to stop it, giving you an experience much like that with Django. Note this requires PHP 5.4 or greater. You also have the option of specifying a different port eg <code>php artisan runserver 7000</code> for port 7000.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Testing PHP web applications with Cucumber]]></title>
            <link>https://matthewdaly.co.uk/blog/2012/11/03/testing-php-web-applications-with-cucumber/</link>
            <guid>https://matthewdaly.co.uk/blog/2012/11/03/testing-php-web-applications-with-cucumber/</guid>
            <pubDate>Sat, 03 Nov 2012 16:43:00 GMT</pubDate>
            <description><![CDATA[<p>Ever since I first heard of <a href="http://cukes.info/">Cucumber</a>, it’s seemed like something I would find really useful. Like many developers, especially those who use PHP regularly, I know full well that I should make a point of writing proper automated tests for my web apps, but invariably wind up just thinking “I haven’t got time to get my head around a testing framework and it’ll take ages to set up, so I’ll just click around and look for bugs”. This does get very, very tedious quite quickly, however.</p>
<p>At work I’ve reached a point with  a web app I’m building where I needed to test it extensively to make sure it worked OK. I soon began to get very, very fed up of the repetitive clicking around necessary to test the application, so I began looking around for a solution. I gave Selenium IDE a try, but I found that to be annoyingly unreliable when recording tests. I’d heard of Cucumber, so I did some googling, found some resources, and began tinkering with that. Quite quickly, I had a few basic acceptance tests up and running that were much more reliable than Selenium IDE, and much less tedious to use than manual testing. Within a very short space of time, I realised that Cucumber was one of those tools that was going to dramatically improve my coding experience, much like when I switched from Subversion to Git.</p>
<p>What’s so great about Cucumber compared to other acceptance testing solutions?</p>
<ul>
<li>Cucumber scenarios are written using Gherkin, a simple syntax that makes it easy for customers to set out exactly what behaviour they want to see. Far from being tedious requirement documents, these set out in a simple and intuitive way what should happen once the application is complete. By requiring customers to think carefully about what they want and get it down in writing, you can ensure the customer has a good idea what they want before you write any code, making it much less likely they’ll turn around afterwards and say “No, that’s not what we want”. This, more than anything, is for me the true power of Cucumber - it allows customers and developers to easily collaborate to set out what the web app will do, and gets you automated tests into the bargain as well.</li>
<li>Because Cucumber is packaged as a Ruby gem, it’s easy to install it and any other Ruby modules it may require.</li>
<li>You can use Capybara to test your web app. Capybara is a very handy Ruby gem that allows you to easily interact with your web app, and it allows several different drivers to be used. If you don’t need JavaScript, for instance, you can use Mechanize for faster tests. If you do, you can use selenium-webdriver to automate the browser instead, and it will load an instance of Firefox and use that for testing.</li>
<li>It can also be used for testing RESTful web services. HTTParty is another handy Ruby gem that can be used for testing an API.</li>
</ul>
<p>One question you may ask is ‘Why use a Ruby tool to test PHP apps?’. Well, there is <a href="http://behat.org/">Behat</a>, a very similar tool for PHP, so you can use that if you’d prefer. However, I personally have found that it’s not too much of a problem switching context between writing Ruby code for the acceptance tests and PHP code for the application itself. Ruby also has some advantages here - <a href="https://rvm.io/">RVM</a> is a very handy tool for running multiple instances of Ruby, and RubyGems makes it easy to install any additional modules you may need. You don’t really need to know much Ruby to use it - this is essentially my first encounter with Ruby barring a few small tutorials, but I haven’t had any significant issues with it. Finally, the Cucumber community seems to be very active, which is always a plus.</p>
<p>When searching for a tutorial on getting Cucumber working with PHP, I only found <a href="http://jamieonsoftware.com/journal/2011/1/2/high-level-testing-php-applications-with-cucumber.html">one good one</a>, and that didn’t cover a lot of the issues I’d have liked to cover, not did it cover actually using Cucumber as part of the development process, so I had to puzzle out much of it myself. So hopefully, by covering more of the ground that your average PHP developer is likely to need, I can show you just how useful Cucumber can be when added to your PHP development toolkit.</p>
<p>In this tutorial, we’ll build a very simple todo-list application using the Slim framework, but we’ll use Cucumber to test it throughout to ensure that it works the way we want it to. Hopefully, by doing this, we’ll get a rock-solid web app that meets our requirements exactly.</p>
<p>First of all, you’ll want to install RVM to make it easier to manage multiple Ruby installs. You may be able to use your system’s Ruby install, but RVM is usually a safer bet:</p>
<pre><code class="lang-bash">\curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>
<p>This was sufficient to install RVM on Mac OS X. On Ubuntu, I also had to install the openssl and zlib packages. Before installing RVM, use apt-get to install the required packages:</p>
<pre><code class="lang-bash">sudo apt-get install curl git git-core zlib1g-dev zlibc libxml2-dev libxslt1-dev libyaml-dev build-essential checkinstall openssl libreadline6 libreadline6-dev zlib1g libssl-dev libsqlite3-dev sqlite3 autoconf libc6-dev ncurses-dev automake libtool bison subversion pkg-config
</code></pre>
<p>Once RVM is installed, then close and reopen your terminal so that RVM is loaded. Then, install the correct packages:</p>
<pre><code class="lang-bash">rvm pkg install openssl zlib
</code></pre>
<p>Now we can install our new copy of Ruby. On Ubuntu, I had to install Ruby 1.8.7 first:</p>
<pre><code class="lang-bash">rvm install 1.8.7
rvm use 1.8.7
</code></pre>
<p>Then I installed Ruby 1.9.3:</p>
<pre><code class="lang-bash">rvm install 1.9.3 --with-openssl-dir=$HOME/.rvm/usr
</code></pre>
<p>Whereas on OS X, this is all that was required:</p>
<pre><code class="lang-bash">rvm install 1.9.3
</code></pre>
<p>Once that’s done, run the following to set the version of Ruby being used</p>
<pre><code class="lang-bash">rvm use 1.9.3
</code></pre>
<p>With that done, you should be able to install the required Ruby gems. Now, you could install these manually, like this:</p>
<pre><code class="lang-bash">gem install cucumber
gem install rspec
gem install mechanize
gem install capybara
gem install selenium-webdriver
gem install capybara-mechanize
</code></pre>
<p>However, there’s a more convenient way. First, create a file in the project’s root directory called Gemfile and put the following content into it:</p>
<pre><code class="lang-ruby">source &quot;http://rubygems.org&quot;
gem &quot;cucumber&quot;
gem &quot;rspec&quot;
gem &quot;mechanize&quot;
gem &quot;capybara&quot;
gem &quot;selenium-webdriver&quot;
gem &quot;capybara-mechanize&quot;
</code></pre>
<p>Then install the Bundler gem:</p>
<pre><code class="lang-bash">gem install bundler
</code></pre>
<p>Then use Bundler to install the required gems:</p>
<pre><code class="lang-bash">bundle install
</code></pre>
<p>This makes it easier to get your project set up somewhere else because you can put the Gemfile under version control, making it easier to duplicate this setup elsewhere.</p>
<p>With that out of the way, let’s start work on our app. To save time, we’ll use the Slim framework to do some of the heavy lifting for our application. Download <a href="http://www.slimframework.com/">Slim</a> and put it in a folder on your local web server.</p>
<p>Now, before we actually write any code, we’ll set out our first Cucumber scenario. Create a folder inside the folder you put Slim inside and call it <code>features</code>. Inside it, create a new file called <code>todo.feature</code> and put the following content into it:</p>
<pre><code class="lang-gherkin">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

    Scenario: New item
        Given I am on the home page
        When I click on New Item
        And I fill in the item
        And I click the button Submit
        Then I should see the new item added to the list
</code></pre>
<p>Notice how simple this is? Everything is written as an example of how an end user would interact with the site. There’s nothing hard about this - it just describes what the site needs to do.</p>
<p>The first line is just the name of this feature. The following three lines are just a comment. Then the Scenario line gives a name to this particular scenario - a Scenario is just a series of steps that describes an action.</p>
<p>Then, we see the Given line. This sets out the starting conditions. Note that you can easily set out multiple starting conditions using the And keyword on subsequent lines, as we do later in the file. Here, we’re just making sure we’re on the home page.</p>
<p>Next, we see the When line. This, and the subsequent And lines, set out what actions we want to take when going through this step. In this example, we’re clicking on a link marked ‘New Item’, filling in a text input, and clicking the Submit button. So we’re already thinking about how our application is going to work, before we’ve written a line of code.</p>
<p>Finally, we see the Then line. This sets out what should have happened once we’ve finished going through this step. Here we want to make sure the new item has been added to the list.</p>
<p>Now, go to the folder you unpacked Slim into and run <code>cucumber</code> from the shell. You should see something like this:</p>
<pre><code class="lang-sh">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/todo.feature:8
    When I click on New Item                         # features/todo.feature:9
    And I fill in the item                           # features/todo.feature:10
    And I click the button Submit                    # features/todo.feature:11
    Then I should see the new item added to the list # features/todo.feature:12

1 scenario (1 undefined)
5 steps (5 undefined)
0m0.004s

You can implement step definitions for undefined steps with these snippets:

Given /^I am on the home page$/ do
  pending # express the regexp above with the code you wish you had
end

When /^I click on New Item$/ do
  pending # express the regexp above with the code you wish you had
end

When /^I fill in the item$/ do
  pending # express the regexp above with the code you wish you had
end

When /^I click the button Submit$/ do
  pending # express the regexp above with the code you wish you had
end

Then /^I should see the new item added to the list$/ do
  pending # express the regexp above with the code you wish you had
end

If you want snippets in a different programming language,
just make sure a file with the appropriate file extension
exists where cucumber looks for step definitions.
</code></pre>
<p>At this stage, Cucumber isn’t doing anything much, it’s just telling you that these steps haven’t been defined as yet. To define a step, you simply write some Ruby code that expresses that step.</p>
<p>Let’s do that. Under <code>features</code>, create a new directory called <code>step_definitions</code>. Inside that, create a file called <code>todo_steps.rb</code> and paste the code snippets returned by Cucumber into it. Once that has been saved, run <code>cucumber</code> again and you should see something like this:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
      TODO (Cucumber::Pending)
      ./features/step_definitions/todo_steps.rb:2:in `/^I am on the home page$/&#39;
      features/todo.feature:8:in `Given I am on the home page&#39;
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

1 scenario (1 pending)
5 steps (4 skipped, 1 pending)
0m0.004s
</code></pre>
<p>So far, the steps we’ve written don’t actually do anything - each step contains nothing but the pending statement. We need to replace the code inside each of those steps with some Ruby code that implements that step. As the first step in this scenario is still pending, Cucumber skips all the remaining steps.</p>
<p>Let’s implement these steps. First of all, we need to set some configuration options. In the <code>features</code> folder, create a new folder called <code>support</code>, and under that create a new file called <code>env.rb</code>. In there, place the following code:</p>
<pre><code class="lang-ruby">require &#39;rspec/expectations&#39;
require &#39;capybara&#39;
require &#39;capybara/mechanize&#39;
require &#39;capybara/cucumber&#39;
require &#39;test/unit/assertions&#39;
require &#39;mechanize&#39;

World(Test::Unit::Assertions)

Capybara.default_driver = :mechanize
Capybara.app_host = &quot;http://localhost&quot;
World(Capybara)
</code></pre>
<p>This includes all of the Ruby gems required for our purposes, and sets Capybara to use the Mechanize driver for testing web apps. If you’ve not heard of it before, Capybara can be thought of as a way of scripting a web browser that supports numerous drivers, some of which are headless and some of which aren’t. Here we’re using Mechanize, which is headless, but later on we’ll use Selenium to show you how it would work with a non-headless web browser.</p>
<p>With that done, the next job is to actually implement the steps. Head back to <code>features/step_definitions/todo_steps.rb</code> and edit it as follows:</p>
<pre><code class="lang-ruby">Given /^I am on the home page$/ do
    visit &quot;http://localhost/~matthewdaly/todo/index.php&quot;
end

When /^I click on New Item$/ do
      pending # express the regexp above with the code you wish you had
end

When /^I fill in the item$/ do
      pending # express the regexp above with the code you wish you had
end

When /^I click the button Submit$/ do
      pending # express the regexp above with the code you wish you had
end

Then /^I should see the new item added to the list$/ do
      pending # express the regexp above with the code you wish you had
end
</code></pre>
<p>Don’t forget to replace the URL in that first step with the one pointing at your index.php for your local copy of Slim. At this point we’re only implementing the first step, so that’s all we need to do for now. Once that’s done, go back to the root of the web app and run <code>cucumber</code> again. You should see something like this:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
      TODO (Cucumber::Pending)
      ./features/step_definitions/todo_steps.rb:6:in `/^I click on New Item$/&#39;
      features/todo.feature:9:in `When I click on New Item&#39;
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

1 scenario (1 pending)
5 steps (3 skipped, 1 pending, 1 passed)
0m0.036s
</code></pre>
<p>Our first step has passed! Now, we move onto the next step. Open features/step_definitions/todo_steps.rb again, and amend the second step definition as follows:</p>
<pre><code class="lang-ruby">When /^I click on New Item$/ do
   click_link (&#39;New Item&#39;)
end
</code></pre>
<p>Now, hang on a minute here. This Ruby code is pretty easy to understand - it just clicks on a link with the title, ID or text ‘New Item’. But we don’t want to have to rewrite this step for every single link in the application. Wouldn’t it be great if we could have this step definition accept any text and click on the appropriate link, so we could reuse it elsewhere? Well, we can. Change the second step to look like this:</p>
<pre><code class="lang-ruby">When /^I click on (.*)$/ do |link|
    click_link (link)
end
</code></pre>
<p>What’s happening here is that we capture the text after the word ‘on’ using a regular expression and pass it through to the step definition as the variable <code>link</code>. Then, we have Capybara click on that link. Pretty simple, and it saves us on some work in future.</p>
<p>Now run <code>cucumber</code> again, and you should see something like this:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
      no link with title, id or text &#39;New Item&#39; found (Capybara::ElementNotFound)
      (eval):2:in `send&#39;
      (eval):2:in `click_link&#39;
      ./features/step_definitions/todo_steps.rb:6:in `/^I click on (.*)$/&#39;
      features/todo.feature:9:in `When I click on New Item&#39;
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

Failing Scenarios:
cucumber features/todo.feature:7 # Scenario: New item

1 scenario (1 failed)
5 steps (1 failed, 3 skipped, 1 passed)
0m0.042s
</code></pre>
<p>We’ve got our second step in place, but it’s failing because there is no link with the text ‘New Item’. Let’s remedy that. Head back to the folder you put Slim in, and open index.php.</p>
<pre><code class="lang-php">&lt;?php
require &#39;Slim/Slim.php&#39;;

\Slim\Slim::registerAutoloader();

$app = new \Slim\Slim();

// GET route
$app-&gt;get(&#39;/&#39;, function () {
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;a href=&quot;index.php/newitem&quot;&gt;New Item&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;run();
?&gt;
</code></pre>
<p>Here I’ve stripped out most of the default code and comments so we can see more easily what’s happening. If you haven’t used Slim before, it works by letting you define routes that are accessed via HTTP GET, POST, PUT or DELETE methods, and define what the response will be to each one. Here, we’ve defined a simple controller for GET requests to ‘/‘, and we return a template that includes a link with the text ‘New Item’.</p>
<p>Now, run <code>cucumber</code> again and you should see the following:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
      Received the following error for a GET request to http://localhost/~matthewdaly/todo/newitem: &#39;404 =&gt; Net::HTTPNotFound for http://localhost/~matthewdaly/todo/newitem -- unhandled response&#39; (RuntimeError)
      (eval):2:in `send&#39;
      (eval):2:in `click_link&#39;
      ./features/step_definitions/todo_steps.rb:6:in `/^I click on (.*)$/&#39;
      features/todo.feature:9:in `When I click on New Item&#39;
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

Failing Scenarios:
cucumber features/todo.feature:7 # Scenario: New item

1 scenario (1 failed)
5 steps (1 failed, 3 skipped, 1 passed)
0m0.153s
</code></pre>
<p>Our second step is still failing, but only because we haven’t yet defined a route for the destination when we click on the link, so let’s fix that. Open up index.php again and change it to look like this:</p>
<pre><code class="lang-php">&lt;?php
require &#39;Slim/Slim.php&#39;;

\Slim\Slim::registerAutoloader();

$app = new \Slim\Slim();

// GET route
$app-&gt;get(&#39;/&#39;, function () {
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;a href=&quot;index.php/newitem&quot;&gt;New Item&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;get(&#39;/newitem&#39;, function () {
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action=&quot;index.php/submitnewitem&quot; method=&quot;POST&quot;&gt;
            &lt;label&gt;New todo item text&lt;input type=&quot;text&quot; name=&quot;item&quot; /&gt;&lt;/label&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;run();
?&gt;
</code></pre>
<p>We’re just adding a new route to handle what happens when we click the link here. The new page also has a form for submitting the new item.</p>
<p>With that done, the second step should be in place. Run <code>cucumber</code> again and you should see something like this:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
      TODO (Cucumber::Pending)
      ./features/step_definitions/todo_steps.rb:10:in `/^I fill in the item$/&#39;
      features/todo.feature:10:in `And I fill in the item&#39;
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

1 scenario (1 pending)
5 steps (2 skipped, 1 pending, 2 passed)
0m0.048s
</code></pre>
<p>So onto the third step. We’ve already created the input for filling in the item, so all we need to do to make this step pass is write an appropriate step definition:</p>
<pre><code class="lang-ruby">When /^I fill in the item$/ do
    fill_in &#39;item&#39;, :with =&gt; &#39;Feed cat&#39;
end
</code></pre>
<p>With that done, run <code>cucumber</code> again and this step should pass:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
      TODO (Cucumber::Pending)
      ./features/step_definitions/todo_steps.rb:14:in `/^I click the button Submit$/&#39;
      features/todo.feature:11:in `And I click the button Submit&#39;
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

1 scenario (1 pending)
5 steps (1 skipped, 1 pending, 3 passed)
0m0.117s
</code></pre>
<p>Now we need to implement the step for clicking the Submit button. As with clicking on the New Item link, we can make this step generic to save us time later:</p>
<pre><code class="lang-ruby">When /^I click the button (.*)$/ do |button|
    click_button (button)
end
</code></pre>
<p>With that done, run <code>cucumber</code> again and you should see something like this:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
      Received the following error for a POST request to http://localhost/~matthewdaly/todo/index.php/index.php/submitnewitem: &#39;404 =&gt; Net::HTTPNotFound for http://localhost/~matthewdaly/todo/index.php/index.php/submitnewitem -- unhandled response&#39; (RuntimeError)
      (eval):2:in `send&#39;
      (eval):2:in `click_button&#39;
      ./features/step_definitions/todo_steps.rb:14:in `/^I click the button (.*)$/&#39;
      features/todo.feature:11:in `And I click the button Submit&#39;
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

Failing Scenarios:
cucumber features/todo.feature:7 # Scenario: New item

1 scenario (1 failed)
5 steps (1 failed, 1 skipped, 3 passed)
0m0.210s
</code></pre>
<p>The step is failing here because submitting the new item generates a 404 error. We need to handle the POST. Open up index.php again and edit it to look like this:</p>
<pre><code class="lang-php">&lt;?php
require &#39;Slim/Slim.php&#39;;

\Slim\Slim::registerAutoloader();

$app = new \Slim\Slim();

// GET route
$app-&gt;get(&#39;/&#39;, function () {
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;a href=&quot;index.php/newitem&quot;&gt;New Item&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;get(&#39;/newitem&#39;, function () {
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action=&quot;index.php/submitnewitem&quot; method=&quot;POST&quot;&gt;
            &lt;label&gt;New todo item text&lt;input type=&quot;text&quot; name=&quot;item&quot; /&gt;&lt;/label&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;post(&#39;/submitnewitem&#39;, function () {
    $item = $_POST[&#39;item&#39;];
    $template = &lt;&lt;&lt;EOT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Todo list&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;$item&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
EOT;
    echo $template;
});

$app-&gt;run();
?&gt;
</code></pre>
<p>Here we’re cheating a little bit. In a working application we’d want to store the to-do list items in a database, but to keep this tutorial simple we’ll just output the result of the POST request and leave implementing a database to store the items as an exercise for the reader.</p>
<p>Now, run <code>cucumber</code> again and you should see that this step now passes:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17
      TODO (Cucumber::Pending)
      ./features/step_definitions/todo_steps.rb:18:in `/^I should see the new item added to the list$/&#39;
      features/todo.feature:12:in `Then I should see the new item added to the list&#39;

1 scenario (1 pending)
5 steps (1 pending, 4 passed)
0m0.067s
</code></pre>
<p>On to our final step. We want to make sure the page contains the text we submitted, which is very easy to do with Capybara. Change the final step to look like this:</p>
<pre><code class="lang-ruby">Then /^I should see the new item added to the list$/ do
    page.should have_content(&#39;Feed cat&#39;)
end
</code></pre>
<p>Now run <code>cucumber</code> again and you should see that the scenario has now passed:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  Scenario: New item                                 # features/todo.feature:7
    Given I am on the home page                      # features/step_definitions/todo_steps.rb:1
    When I click on New Item                         # features/step_definitions/todo_steps.rb:5
    And I fill in the item                           # features/step_definitions/todo_steps.rb:9
    And I click the button Submit                    # features/step_definitions/todo_steps.rb:13
    Then I should see the new item added to the list # features/step_definitions/todo_steps.rb:17

1 scenario (1 passed)
5 steps (5 passed)
0m0.068s
</code></pre>
<p>We’re nearly done here, but first there’s a couple of other handy things you can do with Cucumber that I’d like to show you. We’ve been using the Mechanize driver for Capybara, which is very fast and efficient. However, it’s effectively a text-mode browser like Lynx, so it can’t be used to test any functionality that relies on JavaScript. However, Mechanize isn’t the only driver available for Capybara, and you can switch to the JavaScript driver when necessary so you can test. The default JavaScript driver is Selenium, which will launch an instance of Firefox and use that for the test.</p>
<p>It’s easy to switch to the JavaScript driver when you need it. Just tag the scenario with @javascript, as in this example:</p>
<pre><code class="lang-gherkin">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

    @javascript
    Scenario: New item
        Given I am on the home page
        When I click on New Item
        And I fill in the item
        And I click the button Submit
        Then I should see the new item added to the list
</code></pre>
<p>Now run <code>cucumber</code> again and this time it will fire up an instance of Firefox and use that to run the tests. This can also be handy for debugging purposes since, unlike with Mechanize, you can see the pages.</p>
<p>Finally, what about if you want to test the same functionality multiple times with different input? You don’t want to have to write out multiple scenarios that are virtually identical, even if you have refactored them to make them more useful. What you need is a way to repeat the same test, only with different input each time.</p>
<p>Handily, Cucumber can do this too. First, let’s refactor the code for our step definitions so the final step can handle any text:</p>
<pre><code class="lang-ruby">Given /^I am on the home page$/ do
    visit &quot;http://localhost/~matthewdaly/todo/index.php&quot;
end

When /^I click on (.*)$/ do |link|
    click_link (link)
end

When /^I fill in the item with (.*)$/ do |item|
    fill_in &#39;item&#39;, :with =&gt; item
end

When /^I click the button (.*)$/ do |button|
    click_button (button)
end

Then /^I should see the text (.*)$/ do |text|
    page.should have_content(text)
end
</code></pre>
<p>Here we’ve changed the third and fifth items so we can pass any value we want through to them. As I mentioned earlier, this is good practice since it means we don’t have to write more code for our tests than we need to.</p>
<p>With that done, open up the feature file and amend it to look like this:</p>
<pre><code class="lang-gherkin">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

    @javascript
    Scenario Outline: New item
        Given I am on the home page
        When I click on New Item
        And I fill in the item with &lt;item&gt;
        And I click the button Submit
        Then I should see the text &lt;item&gt;
    Examples:
        | item                      |   
        | Feed cat                  |   
        | Stop milk                 |   
        | Take over world           |
</code></pre>
<p>If you then run <code>cucumber</code> again, the scenario should run three times, each time entering different text:</p>
<pre><code class="lang-bash">Feature: Todo

    In order to use the site
    As a user
    I want to be able to submit, view and delete to-do list items

  @javascript
  Scenario Outline: New item           # features/todo.feature:8
    Given I am on the home page        # features/step_definitions/todo_steps.rb:1
    When I click on New Item           # features/step_definitions/todo_steps.rb:5
    And I fill in the item with &lt;item&gt; # features/step_definitions/todo_steps.rb:9
    And I click the button Submit      # features/step_definitions/todo_steps.rb:13
    Then I should see the text &lt;item&gt;  # features/step_definitions/todo_steps.rb:17

    Examples: 
      | item            |
      | Feed cat        |
      | Stop milk       |
      | Take over world |

3 scenarios (3 passed)
15 steps (15 passed)
0m25.936s
</code></pre>
<p>With only a few changes, we’re now running the same scenario over and over again with different input, and testing the output is correct for each one. This makes it very easy to test repetitive content. For instance, if you had an e-commerce site with lots of products and you wanted to test the pages for some of the products, you could put them in a table like this. You can have more than one column if necessary, so you could write a scenario like this:</p>
<pre><code class="lang-gherkin">    Scenario Outline: Test products
        Given I am on the home page
        When I search for &lt;product&gt;
        And I click on the first result
        Then I should not see any errors
        And I should see the text &lt;productname&gt;

    Examples:
        | product           | productname                           |
        | supersprocket     | Super Sprocket 3000                   |
</code></pre>
<p>As you can see, Cucumber is a really simple way to start testing your web apps, and can really improve the quality of your code. Even if you’ve never used Ruby before, <a href="https://github.com/jnicklas/capybara#readme">Capybara’s API</a> is very simple and intuitive, and should adequately cover most of what you need to do when testing a web app.</p>
<p>As I mentioned, the PHP community in general has been a bit slack in terms of getting proper automated tests working. But Cucumber makes it so simple, and offers so many other benefits, such as human-readable tests and getting stakeholders more involved in the development process, that there’s really no excuse not to use it. Hope you’ve enjoyed this tutorial, and that it’s encouraged you to start using Cucumber to test your own web apps.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[New theme]]></title>
            <link>https://matthewdaly.co.uk/blog/2012/02/28/new-theme/</link>
            <guid>https://matthewdaly.co.uk/blog/2012/02/28/new-theme/</guid>
            <pubDate>Tue, 28 Feb 2012 18:25:30 GMT</pubDate>
            <description><![CDATA[<p>For a long time now, I’ve kept meaning to write my own WordPress theme from scratch for this site, but just haven’t been able to find the time to do so. Now, I’ve finally found the time to do so, and here it is!</p>
<p>Please let me know what you think, but be gentle (this is my first solo WordPress theme, and also the only one I’ve built completely from scratch), and if you find any issues with it please let me know. Don’t expect it to look great in IE6 or IE7 however - I’ve given it a very cursory review in those browsers, and that’s all. It’s still perfectly readable, but it uses a fair amount of CSS3 so it’s inevitably not going to look as pretty in those browsers.</p>
<p>The code is <a href="https://github.com/matthewbdaly/Steel-Age">on GitHub</a> if you want to take a look.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[So you REALLY don't know regular expressions?]]></title>
            <link>https://matthewdaly.co.uk/blog/2012/01/29/so-you-really-dont-know-regular-expressions/</link>
            <guid>https://matthewdaly.co.uk/blog/2012/01/29/so-you-really-dont-know-regular-expressions/</guid>
            <pubDate>Sun, 29 Jan 2012 19:52:53 GMT</pubDate>
            <description><![CDATA[<p>Ever since I started my new job, I’ve noticed a curious phenomenon. I work with two wonderfully gifted programmers who both know PHP much better than I do, and I learn something new from them all the time. However, neither one of them really knows or uses regular expressions.</p>
<p>Now, as I learned Perl before I learned PHP, naturally I learned regular expressions quite early on in that process. In Perl, regular expressions are a huge part of the language - you simply cannot get away without learning them to some extent as they are used extensively in so many parts of the language.</p>
<p>Apparently I’m not the only one to notice this. Here’s a quote I found on Stack Exchange:</p>
<blockquote>
<p>In earlier phases of my career (ie. pre-PHP), I was a Perl guru, and one major aspect of Perl gurudom is mastery of regular expressions.</p>
</blockquote>
<blockquote>
<p>On my current team, I’m literally the only one of us who reaches for regex before other (usually nastier) tools. Seems like to the rest of the team they’re pure magic. They’ll wheel over to my desk and ask for a regex that takes me literally ten seconds to put together, and then be blown away when it works. I don’t know–I’ve worked with them so long, it’s just natural at this point.</p>
</blockquote>
<blockquote>
<p>In the absence of regex-fluency, you’re left with combinations of flow-control statements wrapping strstr and strpos statements, which gets ugly and hard to run in your head. I’d much rather craft one elegant regex than thirty lines of plodding string searching.</p>
</blockquote>
<p>While I would hesitate to call myself a Perl guru (at best I would call myself intermediate with Perl), I would say I know enough about regular expressions that I can generally get useful work done with them.</p>
<p>Take the following example in Perl (edited somewhat as it didn’t play nice with TinyMCE):</p>
<pre><code class="lang-perl">$fruit = &quot;apple,banana,cherry&quot;;
print $fruit;
@fruit = split(/,/,$fruit);
foreach(@fruit)
{
    print $_.&quot;\n&quot;;
}
apple,banana,cherry
apple
banana
cherry
</code></pre>
<p>Now, this code should be fairly easy to understand, even if you don’t really know Perl. $fruit is a string containing “apple,banana,cherry”. The split() function takes two arguments, a regular expression defining the character(s) that are used to separate the parts of the string you want to put into an array, and the string you want to split. This returns the array @fruit, which consists of three strings, “apple’, “banana”, and “cherry”.</p>
<p>In PHP, you can do pretty much the same thing, using the explode() function:</p>
<pre><code class="lang-php">&lt;?php
$fruit = &quot;apple,banana,cherry&quot;;
echo $fruit.&quot;\n&quot;;
$fruitArray = explode(&quot;,&quot;,$fruit);
foreach($fruitArray as $fruitArrayItem)
{
    echo $fruitArrayItem.&quot;\n&quot;;
}
?&gt;
apple,banana,cherry
apple
banana
cherry
</code></pre>
<p>As you can see, they work in pretty much the same way here. Both return basically the same output, and the syntax for using the appropriate functions for splitting the strings is virtually identical.</p>
<p>However, it’s once things get a bit more difficult that it becomes obvious how much more powerful regular expressions are. Say you’re dealing with a string that’s similar to that above, but may use different characters to separate the elements. For instance, say you’ve obtained the data that you want to pass through into an array from a text file and it’s somewhat inconsistent - perhaps the information you want is separated by differing amounts and types of whitespace, or different characters. The explode() function simply won’t handle that (at least, not without a lot of pain). But with Perl’s split() function, that’s no problem. Here’s how you might deal with input that had different types and quantities of whitespace as a separator:</p>
<pre><code class="lang-perl">@fruit = split(/\s+/,$fruit);
</code></pre>
<p>Yes, it’s that simple! The \s metacharacter matches any type of whitespace, and the + modifier means that it will match one or more times. Now you can very easily convert the contents of that string into an array.</p>
<p>Or say you want to convert an entire string of text, with all kinds of punctuation and whitespace, into an array, but only keep the actual words. This wouldn’t be practical with explode(), but with split() it’s easy:</p>
<pre><code class="lang-perl">@fruit = split(/\W+/,$fruit);
</code></pre>
<p>The \W metacharacter matches any non-word character (ie anything other than a-z, A-Z or 0-9), and again the + modifier means that it will match one or more times.</p>
<p>And of course, regular expressions are useful for many more tasks than this that, while possible with most language’s existing string functions, can get very nasty quite quickly. Say you want to match a UK postcode to check that it’s valid (note that for the sake of simplicity, I’m going to ignore BFPO and GIR postcodes). These use a format of one or two letters, followed by one digit, then may have an additional digit or letter, then a space, then a digit, then two letters. This would be a nightmare to check using most language’s native string functions, but with a regex in Perl, it’s relatively simple:</p>
<pre><code class="lang-perl">my $postcode = &quot;NR1 1NP&quot;;
if($postcode =~ m/^[a-zA-Z]{1,2}\d{1}(|[a-zA-Z0-9]{1})(|\s+)\d{1}\w{2}$/)
{
    print &quot;It matched!\n&quot;;
}
</code></pre>
<p>And if you wanted to return the first part of the postcode if it matched as well, that’s simple too:</p>
<pre><code class="lang-perl">my $postcode = &quot;NR1 1NP&quot;;
if($postcode =~ s/^([a-zA-Z]{1,2}\d{1}(|[a-zA-Z0-9]{1}))(|\s+)\d{1}\w{2}$/$1/)
{
    print &quot;It matched! $postcode\n&quot;;
}
</code></pre>
<p>Now, you may say “But that’s in Perl! I’m using PHP!’. Well, regular expressions are an extremely powerful part of PHP that are very useful, they’re just not as central to the language as they are in Perl. PHP actually has two distinct types of regular expressions - POSIX-extended regular expressions, and Perl-compatible regular expressions (or PCRE). However, POSIX-extended regular expressions were deprecated from PHP 5.3 onwards, so it’s not really worth taking the time to learn them when PCRE will do exactly the same thing and is going to be around for the future. Furthermore, most other programming languages also support Perl-compatible regular expressions, so they’re fairly portable between languages, and once you’ve learned them in one language, you can easily use them in another. In other words, if you learn how to work with regular expressions in Perl, you can very easily transfer that knowledge to most other programming languages that support regular expressions.</p>
<p>In the first example given above, we can replace explode() with preg_split, and the syntax is virtually identical to split() in Perl, with the only difference being the name of the function and that the pattern to match is wrapped in double quotes:</p>
<pre><code class="lang-php">&lt;?php
$fruit = &quot;apple,banana,cherry&quot;;
echo $fruit.&quot;\n&quot;;
$fruitArray = preg_split(&quot;/,/&quot;,$fruit);
foreach($fruitArray as $fruitArrayItem)
{
    echo $fruitArrayItem.&quot;\n&quot;;
}
?&gt;
apple,banana,cherry
apple
banana
cherry
</code></pre>
<p>Along similar lines, if we want to check if a string matches a pattern, we can use preg_match(), and if we want to search and replace, we can use preg_replace(). PHP’s regular expression support is not appreciably poorer than Perl’s, even if it’s less central to the language as a whole.</p>
<blockquote>
<p>But regular expressions are slower than PHP’s string functions!</p>
</blockquote>
<p>Yes, that’s true. So it’s a mistake to use regular expressions for something that can be handled quickly and easily using string functions. For instance, if in the following string you wanted to replace the word “cow” with “sheep”:</p>
<blockquote>
<p>The cow jumped over the moon</p>
</blockquote>
<p>You could use something like this:</p>
<pre><code class="lang-php">&lt;?php
$text = &quot;The cow jumped over the moon&quot;;
$text = preg_replace(&quot;/cow/&quot;,&quot;sheep&quot;,$text);
?&gt;
</code></pre>
<p>However, because here you are only looking to match literal characters, you don’t need to use a regular expression. Just use the following:</p>
<pre><code class="lang-php">&lt;?php
$text = str_replace(&quot;cow&quot;,&quot;sheep&quot;,$text);
?&gt;
</code></pre>
<p>But, if you have to do some more complex pattern matching, you have to start using strpos to get the location of specific characters and returning substrings between those characters, and it gets very messy, very quickly indeed. In those cases, while I haven’t done any kind of benchmarking on it, it stands to reason that quite quickly you’ll reach a point where a regex would be faster.</p>
<p>However, for a number of common tasks, such as validating email addresses and URLs, there’s another way and you don’t need to resort to regular expressions, or faffing about with loads of string functions. The filter_var() function can be used for validating or sanitising email addresses and URLs, among other things, so this is worth using instead of writing a regex. If you’re using a framework such as CodeIgniter, you may have access to its native functions for validating this kind of thing, so you should use those instead.</p>
<blockquote>
<p>But regular expressions are ugly and make for less readable code!</p>
</blockquote>
<p>Not really. They seem intimidating to the newcomer, and very few people can just glance at a regex and instantly know what it does. But with regexes, you can often do complex things in far fewer lines of code than would be needed to accomplish the same thing using just PHP’s string functions. If you can do something in a line or two using string functions, it’s probably best to do that. But after that, things go downhill very quickly.</p>
<p>Once you learn them, regular expressions really are not that hard, and you’ll probably find enough things to use them for that you’ll get plenty of practice at them. They’re certainly more readable to anyone with even a modicum of experience using them than line after line of flow-control statements.</p>
<blockquote>
<p>But you shouldn’t be using regular expressions for parsing HTML or XML!</p>
</blockquote>
<p>Quite true. Regular expressions are the wrong tool for that. You should probably use an existing library of some kind for that.</p>
<blockquote>
<p>Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems.</p>
</blockquote>
<p>Ah, yes, surely one of the most misused quotes on the web! Again, regular expressions are not the right tool for every job, and there’s a lot of tasks they get used for, and quite frankly, shouldn’t be. Most of us who know regular expressions have been known to use them for things we probably shouldn’t (I actually only just stumbled across filter_var, so I’ve done my share of validating email addresses using regexes, and I’m as guilty as anyone else of overusing them). But there’s still plenty of stuff you should use it for when what you need to do can’t be accomplished quickly and easily using string functions.</p>
<p>Regular expressions are not inherently evil. They’re a tool like any other. What is bad is using them for things where a simple alternative exists. However, they are still extremely useful, and there’s plenty of valid use cases for them.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[First steps with PHP]]></title>
            <link>https://matthewdaly.co.uk/blog/2010/06/08/first-steps-with-php/</link>
            <guid>https://matthewdaly.co.uk/blog/2010/06/08/first-steps-with-php/</guid>
            <pubDate>Tue, 08 Jun 2010 21:24:59 GMT</pubDate>
            <description><![CDATA[<p>I’m currently working on my very first website for anyone other than myself. It’s a simple brochure-style website advertising a friend’s chalet at a seaside resort, which she wants to be able to rent out, and includes a simple contact form so that people can get in touch to ask questions or make a booking enquiry. Now, at present Python is the only programming language I know at all well that’s useful for server-side scripting, but I decided to have a bash at building it using PHP, since that’s pretty well supported and there’s loads of tutorials and resources for teaching PHP to newbies, as well as innumerable third-party scripts and libraries. Also, PHP’s such a popular language that you can’t really get away from it if you want to get into web development - I see loads of PHP jobs advertised but very few Python ones. So I figured it’ll be useful to have picked up a little PHP.</p>
<p>I got the form working, and I’ve added reCAPTCHA support to it to help prevent spam. All in all the form is working well, and it didn’t take a great deal of PHP knowledge to write the script. I’m already pretty confident that it’s a language I can work with in future, possibly even on a professional basis. That said, I can already tell that I will never like working with PHP as much as I like working with Python - the syntax is far less elegant than that of Python, and the object-orientation looks and feels much more clumsy to me.</p>
<p>There’s plenty of things I’d like to be able to do that require PHP, so I will be learning it thoroughly at some point, although I have no plans to do so immediately - I’m about to do my JavaScript Fundamentals exam later this month, and after that I’ve got to learn Perl, so it’s not till I get that done that I’ll be learning PHP properly. In particular, I’m really interested in Wordpress theme development - I want to build a theme of my own for this blog since that’ll say more about my abilities than an off-the-shelf theme, and it also happens to be an increasingly marketable skill.</p>
]]></description>
        </item>
    </channel>
</rss>