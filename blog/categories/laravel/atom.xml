<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id></id>
    <title>laravel | Matthew Daly&apos;s Blog</title>
    <updated>2019-01-03T21:52:42Z</updated>
    <generator>grunt-blogbuilder https://github.com/matthewbdaly/grunt-blogbuilder</generator>
    <author>
        <name>Matthew Daly</name>
        <email>matthew@matthewdaly.co.uk</email>
        <uri>https://matthewdaly.co.uk</uri>
    </author>
    <link rel="alternate" href="https://matthewdaly.co.uk/blog/categories/laravel/"/>
    <subtitle>laravel | I&apos;m a web developer in Norfolk. This is my blog...</subtitle>
    <rights>Matthew Daly 2019</rights>
    <entry>
        <title type="html"><![CDATA[Logging to the ELK stack with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/06/03/logging-to-the-elk-stack-with-laravel/">
        </link>
        <updated>2018-06-03T15:30:54Z</updated>
        <summary type="html"><![CDATA[<p>Logging to text files is the simplest and most common logging setup for web apps, and it works fine for relatively small and simple applications. However, it does have some downsides:</p>
<ul>
<li>It’s difficult to make the log files accessible - normally users have to SSH in to read them.</li>
<li>The tools used to filter and analyse log files have a fairly high technical barrier to access - grep and sed are not exactly easy for non-programmers to pick up, so business information can be hard to get.</li>
<li>It’s hard to visually identify trends in the data.</li>
<li>Log files don’t let you know immediately when something urgent happens</li>
<li>You can’t access logs for different applications through the same interface.</li>
</ul>
<p>For rare, urgent issues where you need to be informed immediately they occur, it’s straightforward to log to an instant messaging solution such as Slack or Hipchat. However, these aren’t easily searchable, and can only be used for the most important errors (otherwise, there’s a risk that important data will be lost in the noise). There are third-party services that allow you to search and filter your logs, but they can be prohibitively expensive.</p>
<p>The <a href="https://www.elastic.co/elk-stack">ELK stack</a> has recently gained a lot of attention as a sophisticated solution for logging application data. It consists of:</p>
<ul>
<li>Logstash for processing log data</li>
<li>Elasticsearch as a searchable storage backend</li>
<li>Kibana as a web interface</li>
</ul>
<p>By making the log data available using a powerful web interface, you can easily expose it to non-technical users. Kibana also comes with powerful tools to aggregate and filter the data. In addition, you can run your own instance, giving you a greater degree of control (as well as possibly being more cost-effective) compared to using a third-party service.</p>
<p>In this post I’ll show you how to configure a Laravel application to log to an instance of the ELK stack. Fortunately, Laravel uses the popular Monolog logging library by default, which is relatively easy to get to work with the ELK stack. First, we need to install support for the GELF logging format:</p>
<pre><code class="lang-bash">$ composer require graylog2/gelf-php
</code></pre>
<p>Then, we create a custom logger class:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Logging;

use Monolog\Logger;
use Monolog\Handler\GelfHandler;
use Gelf\Publisher;
use Gelf\Transport\UdpTransport;

class GelfLogger
{
    /**
     * Create a custom Monolog instance.
     *
     * @param  array  $config
     * @return \Monolog\Logger
     */
    public function __invoke(array $config)
    {
        $handler = new GelfHandler(new Publisher(new UdpTransport($config[&#39;host&#39;], $config[&#39;port&#39;])));
        return new Logger(&#39;main&#39;, [$handler]);
    }
}
</code></pre>
<p>Finally, we configure our application to use this as our custom driver and specify the host and port in <code>config/logging.php</code>:</p>
<pre><code class="lang-php">        &#39;custom&#39; =&gt; [
            &#39;driver&#39; =&gt; &#39;custom&#39;,
            &#39;via&#39; =&gt; App\Logging\GelfLogger::class,
            &#39;host&#39; =&gt; &#39;127.0.0.1&#39;,
            &#39;port&#39; =&gt; 12201,
        ],
</code></pre>
<p>You can then set up whatever logging channels you need for your application, and specify whatever log level you feel is appropriate.</p>
<p>Please note that this requires at least Laravel 5.6 - this file doesn’t exist in Laravel 5.5 and earlier, so you may have more work on your hands to integrate it with older versions.</p>
<p>If you already have an instance of the ELK stack set up on a remote server that’s already set up to accept input as GELF, then you should be able to point it at that and you’ll be ready to go. If you just want to try it out, I’ve been using a <a href="https://github.com/deviantony/docker-elk">Docker-based project</a> that makes it straightforward to run the whole stack locally. However, you will need to amend <code>logstash/pipeline/logstash.conf</code> as follows to allow it to accept log data:</p>
<pre><code class="lang-json">input {
    tcp {
        port =&gt; 5000
    }
   gelf {
       port =&gt; 12201
       type =&gt; gelf
       codec =&gt; &quot;json&quot;
   }
}

## Add your filters / logstash plugins configuration here

output {
    elasticsearch {
        hosts =&gt; &quot;elasticsearch:9200&quot;
    }
}
</code></pre>
<p>Then you can start it up using the instructions in the repository and it should be ready to go. Now, if you run the following command from Tinker:</p>
<pre><code class="lang-php">Log::info(&#39;Just testing&#39;);
</code></pre>
<p>Then if you access the web interface, you should be able to find that log message without any difficulty.</p>
<p>Now, this only covers the Laravel application logs. You may well want to pass other logs through to Logstash, such as Apache, Nginx or MySQL logs, and a quick Google should be sufficient to find ideas on how you might log for these services. Creating visualisations with Kibana is a huge subject, and the existing documentation covers that quite well, so if you’re interested in learning more about that I’d recommend reading the documentation and having a play with the dashboard.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rendering different views for mobile and desktop clients in Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/04/22/rendering-different-views-for-mobile-and-desktop-clients-in-laravel/">
        </link>
        <updated>2018-04-22T22:50:10Z</updated>
        <summary type="html"><![CDATA[<p>This was a bit of a weird post to write. It started out explaining how I resolved an issue years ago on a CodeIgniter site, but amended to work for Laravel. In the process, I realised it made sense to implement it as middleware, and I ended up pulling it out into <a href="https://github.com/matthewbdaly/laravel-dynamic-serving">a package</a>. However, it’s still useful to understand the concept behind it, even if you prefer to just install the complete package, because your needs might be slightly different to mine.</p>
<p>On web development forums, it’s quite common to see variants of the following question:</p>
<blockquote>
<p>How do I redirect a user on a mobile device to a mobile version of the site?</p>
</blockquote>
<p>It’s quite surprising that this is still an issue that crops up. For many years, it’s been widely accepted that the correct solution for this problem is responsive design. However, there are ways in which this may not be adequate for certain applications. For instance, you may have an application where certain functionality only makes sense in a certain context, or your user interface may need to be optimised for specific environments.</p>
<p>The trouble is that a dedicated mobile site isn’t a good idea either. Among other things, it means that users can’t easily use the same bookmarks between desktop and mobile versions, and can result in at least some of the server-side logic being duplicated.</p>
<p>Fortunately, there is another way - <a href="https://developers.google.com/search/mobile-sites/mobile-seo/dynamic-serving">dynamic serving</a> allows you to render different content based on the user agent. You can also easily enable users to switch between desktop and mobile versions themselves if their client isn’t detected correctly or they just prefer the other one. I’ve implemented this years ago for a CodeIgniter site. Here’s how you might implement it in Laravel, although if you understand the principle behind it, it should be easy to adapt for any other framework.</p>
<p>Don’t try to implement mobile user agent detection yourself. Instead, find an implementation that’s actively maintained and install it with Composer. That way you can be reasonably sure that as new mobile devices come onto the market the package will detect them correctly as long as you keep it up to date. I would be inclined to go for <a href="https://github.com/jenssegers/agent">Agent</a>, since it has Laravel support baked in.</p>
<p>We could just use Agent to serve up different content based on the user agent. However, user agent strings are notoriously unreliable - if a new mobile device appears and it doesn’t show up correctly in Agent, users could find themselves forced to use the wrong UI. Instead, we need to check for a flag in the session that indicates if the session is mobile or not. If it’s not set, we set it based on the user agent. That way, if you need to offer functionality to override the detected session type, you can just update that session variable to correct that elsewhere in the application. I would be inclined to use a button in the footer that makes an AJAX request to toggle the flag, then reloads the page.</p>
<p>You also need to set the HTTP response header <code>Vary: User-Agent</code> to notify clients (including not only search engines, but also proxies at either end of the connection, such as Varnish or Squid) that the response will differ by user agent, in order to prevent users being served the wrong version.</p>
<p>Middleware is the obvious place to do this. Here’s a middleware that sets the session variable and the appropriate response headers:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;
use Jenssegers\Agent\Agent;
use Illuminate\Contracts\Session\Session;

class DetectMobile
{
    protected $agent;

    protected $session;

    public function __construct(Agent $agent, Session $session)
    {
        $this-&gt;agent = $agent;
        $this-&gt;session = $session;
    }

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if (!$this-&gt;session-&gt;exists(&#39;mobile&#39;)) {
            if ($this-&gt;agent-&gt;isMobile() || $this-&gt;agent-&gt;isTablet()) {
                $this-&gt;session-&gt;put(&#39;mobile&#39;, true);
            } else {
                $this-&gt;session-&gt;put(&#39;mobile&#39;, false);
            }
        }
        $response = $next($request);
        return $response-&gt;setVary(&#39;User-Agent&#39;);
    }
}
</code></pre>
<p>Now, you could then work with the session directly to retrieve the <code>mobile</code> flag, but as you may be working in the view, it makes sense to create helpers for this:</p>
<pre><code class="lang-php">&lt;?php

if (!function_exists(&#39;is_mobile&#39;)) {
    function is_mobile()
    {
        $session = app()-&gt;make(&#39;Illuminate\Contracts\Session\Session&#39;);
        return $session-&gt;get(&#39;mobile&#39;) == true;
    }
}

if (!function_exists(&#39;is_desktop&#39;)) {
    function is_desktop()
    {
        $session = app()-&gt;make(&#39;Illuminate\Contracts\Session\Session&#39;);
        return $session-&gt;get(&#39;mobile&#39;) == false;
    }
}
</code></pre>
<p>Now, if you want to serve up completely different views, you can use these helpers in your controllers. If you instead want to selectively show and hide parts of the UI based on the user agent, you can instead use these in the views to determine what parts of the page should be shown.</p>
<p>Agent offers more functionality than just detecting if a user agent is a mobile or desktop device, and you may find this useful as a starting point for developing middleware for detecting bots, or showing different content to users based on their device type or operating system. If you just need to detect if a user is a mobile or desktop client, this middleware should be sufficient.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unit testing your Laravel controllers]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/02/25/unit-testing-your-laravel-controllers/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/02/25/unit-testing-your-laravel-controllers/">
        </link>
        <updated>2018-02-25T15:50:44Z</updated>
        <summary type="html"><![CDATA[<p>In <a href="/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/">my previous post</a> I mentioned some strategies for refactoring Laravel controllers to move unnecessary functionality elsewhere. However, I didn’t cover testing them. In this post I will demonstrate the methodology I use for testing Laravel controllers.</p>
<p>Say we have the following method in a controller:</p>
<pre><code class="lang-php">public function store(Request $request)
{    
        $document = new Document($request-&gt;only([
            &#39;title&#39;, 
            &#39;text&#39;, 
        ]));
        $document-&gt;save();

        event(new DocumentCreated($document));

        return redirect()-&gt;route(&#39;/&#39;);
}
</code></pre>
<p>This controller method does three things:</p>
<ul>
<li>Return a response</li>
<li>Create a model instance</li>
<li>Fire an event</li>
</ul>
<p>Our tests therefore need to pass it all its external dependencies and check it carries out the required actions.</p>
<p>First we fake the event facade:</p>
<pre><code class="lang-php">    Event::fake();
</code></pre>
<p>Next, we create an instance of <code>Illuminate\Http\Request</code> to represent the HTTP request passed to the controller:</p>
<pre><code class="lang-php">    $request = Request::create(&#39;/store&#39;, &#39;POST&#39;,[
        &#39;title&#39;     =&gt;     &#39;foo&#39;,
        &#39;text&#39;     =&gt;     &#39;bar&#39;,
    ]);
</code></pre>
<p>If you’re using a custom form request class, you should instantiate that in exactly the same way.</p>
<p>Then, instantiate the controller, and call the method, passing it the request object:</p>
<pre><code class="lang-php">    $controller = new MyController();
    $response = $controller-&gt;store($request);
</code></pre>
<p>You can then test the response from the controller. You can test the status code like this:</p>
<pre><code class="lang-php">    $this-&gt;assertEquals(302, $response-&gt;getStatusCode());
</code></pre>
<p>You may also need to check the content of the response matches what you expect to see, by retrieving <code>$response-&gt;getBody()-&gt;getContent()</code>.</p>
<p>Next, retrieve the newly created model instance, and verify it exists:</p>
<pre><code class="lang-php">    $document = Document::where(&#39;title&#39;, &#39;foo&#39;)-&gt;first();
    $this-&gt;assertNotNull($document);
</code></pre>
<p>You can also use <code>assertEquals()</code> to check the attributes on the model if appropriate. Finally, you check the event was fired:</p>
<pre><code class="lang-php">    Event::assertDispatched(DocumentCreated::class, function ($event) use ($document) { 
        return $event-&gt;document-&gt;id === $document-&gt;id; 
    });
</code></pre>
<p>This test should not concern itself with any functionality triggered by the event, only that the event gets triggered. The event should have separate unit tests in which the event is triggered, and then the test verifies it carried out the required actions.</p>
<p>Technically, these don’t quite qualify as being unit tests because they hit the database, but they should cover the controller adequately. To make them true unit tests, you’d need to implement the repository pattern for the database queries rather than using Eloquent directly, and mock the repository, so you can assert that the mocked repository receive the right data and have it return the expected response.</p>
<p>Here is how you might do that with Mockery:</p>
<pre><code class="lang-php">$mock = Mockery::mock(&#39;App\Contracts\Repositories\Document&#39;);
$mock-&gt;shouldReceive(&#39;create&#39;)-&gt;with([
    &#39;title&#39;    =&gt;        &#39;foo&#39;,
    &#39;text&#39;    =&gt;        &#39;bar&#39;,
])-&gt;once()-&gt;andReturn(true);
$controller = new MyController($mock);
</code></pre>
<p>As long as your controllers are kept as small as possible, it’s generally not too hard to test them. Unfortunately, fat controllers become almost impossible to test, which is another good reason to avoid them.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Put your Laravel controllers on a diet]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/02/18/put-your-laravel-controllers-on-a-diet/">
        </link>
        <updated>2018-02-18T18:10:10Z</updated>
        <summary type="html"><![CDATA[<p>MVC frameworks are a tremendously useful tool for modern web development. They offer easy ways to carry out common tasks, and enforce a certain amount of structure on a project.</p>
<p>However, that doesn’t mean using them makes you immune to bad practices, and it’s quite easy to wind up falling into certain anti-patterns. Probably the most common is the Fat Controller.</p>
<h2 id="what-is-a-fat-controller-">What is a fat controller?</h2>
<p>When I first started out doing professional web development, CodeIgniter 2 was the first MVC framework I used. While I hadn’t used it before, I was familiar with the general concept of MVC. However, I didn’t appreciate that when referring to the model layer as a place for business logic, that wasn’t necessarily the same thing as the database models.</p>
<p>As such, my controllers became a dumping ground for anything that didn’t fit into the models. If it didn’t interact with the database, I put it in the controller. They quickly became bloated, with many methods running to hundreds of lines of code. The code base became hard to understand, and when I was under the gun on projects I found myself copying and pasting functionality between controllers, making the situation even worse. Not having an experienced senior developer on hand to offer criticism and advice, it was a long time before I realised that this was a problem or how to avoid it.</p>
<h2 id="why-are-fat-controllers-bad-">Why are fat controllers bad?</h2>
<p>Controllers are meant to be simple glue code that receives requests and returns responses. Anything else should be handed off to the model layer. As noted above, however, that’s not the same as putting it in the models. Your model layer can consist of many different classes, not just your Eloquent models, and you should not fall into the trap of thinking your application should consist of little more than models, views and controllers.</p>
<p>Placing business logic in controllers can be bad for many reasons:</p>
<ul>
<li>Code in controllers can be difficult to write automated tests for</li>
<li>Any logic in a controller method may need to be repeated elsewhere if the same functionality is needed for a different route, unless it’s in a private or protected method that is called from elsewhere, in which case it’s very hard to test in isolation</li>
<li>Placing it in the controller makes it difficult to pull out and re-use on a different project</li>
<li>Making your controller methods too large makes them complex and hard to follow</li>
</ul>
<p>As a general rule of thumb, I find that 10 lines of code for any one method for a controller is where it starts getting a bit much. That said, it’s not a hard and fast rule, and for very small projects it may not be worthwhile. But if a project is large and needs to be maintained for any reasonable period of time, you should take the trouble to ensure your controllers are as skinny as is practical.</p>
<p>Nowadays Laravel is my go-to framework and I’ve put together a number of strategies for avoiding the fat controller anti-pattern. Here’s some examples of how I would move various parts of the application out of my controllers.</p>
<h2 id="validation">Validation</h2>
<p>Laravel has a nice, easy way of getting validation out of the controllers. Just create a custom <a href="https://laravel.com/docs/5.6/validation#form-request-validation">form request</a> for your input data, as in this example:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class CreateRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            &#39;email&#39; =&gt; &#39;required|email&#39;
        ];
    }
}
</code></pre>
<p>Then type-hint the form request in the controller method, instead of <code>Illuminate\Http\Request</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Requests\CreateRequest;

class HomeController extends Controller
{
    public function store(CreateRequest $request)
    {
        // Process request here..
    }
}
</code></pre>
<h2 id="database-access-and-caching">Database access and caching</h2>
<p>For non-trivial applications I normally use <a href="/blog/2017/03/01/decorating-laravel-repositories/">decorated repositories</a> to handle caching and database access in one place. That way my caching and database layers are abstracted out into separate classes, and caching is nearly always handled seamlessly without having to do much work.</p>
<h2 id="complex-object-creation-logic">Complex object creation logic</h2>
<p>If I have a form or API endpoint that needs to:</p>
<ul>
<li>Create more than one object</li>
<li>Transform the incoming data in some way</li>
<li>Or is non-trivial in any other way</li>
</ul>
<p>I will typically pull it out into a separate persister class. First, you should create an interface for this persister class:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts\Persisters;

use Illuminate\Database\Eloquent\Model;

interface Foo
{
    /**
     * Create a new Model
     *
     * @param array $data
     * @return Model
     */
    public function create(array $data);

    /**
     * Update the given Model
     *
     * @param array $data
     * @param Model $model
     * @return Model
     */
    public function update(array $data, Model $model);
}
</code></pre>
<p>Then create the persister class itself:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Persisters;

use Illuminate\Database\Eloquent\Model;
use App\Contracts\Repositories\Foo as Repository;
use App\Contracts\Persisters\Foo as FooContract;
use Illuminate\Database\DatabaseManager;
use Carbon\Carbon;

class Foo implements FooContract
{
    protected $repository;

    protected $db;

    public function __construct(DatabaseManager $db, Repository $repository)
    {
        $this-&gt;db = $db;
        $this-&gt;repository = $repository;
    }

    /**
     * Create a new Model
     *
     * @param array $data
     * @return Model
     */
    public function create(array $data)
    {
        $this-&gt;db-&gt;beginTransaction();
        $model = $this-&gt;repository-&gt;create([
             &#39;date&#39; =&gt; Carbon::parse($data[&#39;date&#39;])-&gt;toDayDateTimeString(),
        ]);
        $this-&gt;db-&gt;commit();
        return $model;
    }

    /**
     * Update the given Model
     *
     * @param array $data
     * @param Model $model
     * @return Model
     */
    public function update(array $data, Model $model)
    {
        $this-&gt;db-&gt;beginTransaction();
        $updatedmodel = $this-&gt;repository-&gt;update([
             &#39;date&#39; =&gt; Carbon::parse($data[&#39;date&#39;])-&gt;toDayDateTimeString(),
             $model
        ]);
        $this-&gt;db-&gt;commit();
        return $updatedmodel;
    }
}
</code></pre>
<p>Then you can set up the persister in a service provider so that type-hinting the interface returns the persister:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
       $this-&gt;app-&gt;bind(
            &#39;App\Contracts\Persisters\Foo&#39;,
            &#39;App\Persisters\Foo&#39;,
       });
    }
}
</code></pre>
<p>This approach means that complex logic, such as creating multiple related objects, can be handled in a consistent way, even if it needs to be called from multiple places.</p>
<h2 id="triggering-actions-as-a-result-of-something">Triggering actions as a result of something</h2>
<p><a href="https://laravel.com/docs/5.6/events">Events</a> are tailor-made for this use case, and Laravel documents them very well, so I won’t repeat it here. Suffice to say, if something needs to happen, but the response sent by the application doesn’t necessarily depend on it returning something immediately, then it’s probably worth considering making it an event. If it’s going to be called from multiple places, it’s even more worthwhile.</p>
<p>For instance, if you have a contact form, it’s worth taking the time to create an event for when a new contact is received, and handle proessing the contact within the listener for that event. Also, doing so means you can queue that event and have it handled outside the context of the application, so that it responds to the user more quickly. If you’re sending an acknowledgement email for a new user registration, you don’t need to wait for that email to be sent before you return the response, so queueing it can improve response times.</p>
<h2 id="interacting-with-third-party-services">Interacting with third-party services</h2>
<p>If you have some code that needs to interact with a third-party service or API, it can get quite complex, especially if you need to process the content in some way. It therefore makes sense to pull that functionality out into a separate class.</p>
<p>For instance, say you have some code in your controller that uses an HTTP client to fetch some data from a third-party API and display it in the view:</p>
<pre><code class="lang-php">public function index(Request $request)
{
   $data = $this-&gt;client-&gt;get(&#39;http://api.com/api/items&#39;);
   $items = [];
   foreach ($data as $k =&gt; $v) {
         $item = [
           &#39;name&#39; =&gt; $v[&#39;name&#39;],
              &#39;description&#39; =&gt; $v[&#39;data&#39;][&#39;description&#39;],
              &#39;tags&#39; =&gt; $v[&#39;data&#39;][&#39;metadata&#39;][&#39;tags&#39;]
         ];
         $items[] = $item;
   }
   return view(&#39;template&#39;, [
       &#39;items&#39; =&gt; $items
   ]);
}
</code></pre>
<p>This is a very small example (and a lot simpler than most real-world instances of this issue), but it illustrates the principle. Not only does this code bloat the controller, it might also be used elsewhere in the application, and we don’t want to copy and paste it elsewhere - therefore it makes sense to extract it to a service class.</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services

use GuzzleHttp\ClientInterface as GuzzleClient;

class Api
{
   protected $client;

   public function __construct(GuzzleClient $client)
   {
      $this-&gt;client = $client;
   }

    public function fetch()
    {
      $data = $this-&gt;client-&gt;get(&#39;http://api.com/api/items&#39;);
      $items = [];
      foreach ($data as $k =&gt; $v) {
         $item = [
            &#39;name&#39; =&gt; $v[&#39;name&#39;],
            &#39;description&#39; =&gt; $v[&#39;data&#39;][&#39;description&#39;],
            &#39;tags&#39; =&gt; $v[&#39;data&#39;][&#39;metadata&#39;][&#39;tags&#39;]
         ];
         $items[] = $item;
      }
      return $items;
    }
}
</code></pre>
<p>Our controller can then type-hint the service and refactor that functionality out of the method:</p>
<pre><code class="lang-php">public function __construct(App\Services\Api $api)
{
    $this-&gt;api = $api;
}

public function index(Request $request)
{
   $items = $this-&gt;api-&gt;fetch();
   return view(&#39;template&#39;, [
       &#39;items&#39; =&gt; $items
   ]);
}
</code></pre>
<h2 id="including-common-variables-in-the-view">Including common variables in the view</h2>
<p>If data is needed in more than one view (eg show the user’s name on every page when logged in), consider using <a href="https://laravel.com/docs/5.6/views#view-composers">view composers</a> to retrieve this data rather than fetching them in the controller. That way you’re not having to repeat that logic in more than one place.</p>
<h2 id="formatting-content-for-display">Formatting content for display</h2>
<p>Logically this belongs in the view layer, so you should <a href="/blog/2018/01/09/creating-laravel-helpers/">write a helper</a> to handle things like formatting dates. For more complex stuff, such as formatting HTML, you should be doing this in Blade (or another templating system, if you’re using one) - for instance, when generating an HTML table, you should consider <a href="https://laravel.com/docs/5.6/blade#rendering-views-for-collections">using a view partial</a> to loop through them. For particularly tricky functionality, you have the option of <a href="https://laravel.com/docs/5.6/blade#extending-blade">writing a custom Blade directive</a>.</p>
<p>The same applies for rendering other content - for rendering JSON you should consider using <a href="https://laravel.com/docs/5.6/eloquent-resources">API resources</a> or <a href="https://fractal.thephpleague.com/">Fractal</a> to get any non-trivial logic for your API responses out of the controller. Blade templates can also work for non-HTML content such as XML.</p>
<h2 id="anything-else-">Anything else…</h2>
<p>These examples are largely to get you started, and there will be occasions where something doesn’t fall into any of the above categories. However, the same principle applies. Your controllers should stick to just receiving requests and sending responses, and anything else should normally be deferred to other classes.</p>
<p>Fat controllers make developer’s lives very difficult, and if you want your code base to be easily maintainable, you should be willing to refactor them ruthlessly. Any functionality you can pull out of the controller becomes easier to reuse and test, and as long as you name your classes and methods sensibly, they’re easier to understand.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[How I deploy Laravel apps]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/29/how-i-deploy-laravel-apps/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/29/how-i-deploy-laravel-apps/">
        </link>
        <updated>2018-01-29T22:00:35Z</updated>
        <summary type="html"><![CDATA[<p>A while back I provided details of the web server setup I used for Django applications. Nowadays I tend to use Laravel most of the time, so I thought I’d share an example of the sort of setup I use to deploy that.</p>
<h2 id="server-os">Server OS</h2>
<p>As before I generally prefer Debian Stable where possible. If that’s not possible for any reason then the current Ubuntu LTS is an acceptable substitute.</p>
<h2 id="web-server">Web server</h2>
<p>My usual web server these days is Nginx with PHP 7 or better via FPM. I generally use HTTP2 where possible, with SSL via Let’s Encrypt.</p>
<p>Here’s my typical Nginx config:</p>
<pre><code class="lang-nginx">fastcgi_cache_path /etc/nginx/cache levels=1:2 keys_zone=my-app:100m inactive=60m;
fastcgi_cache_key &quot;$scheme$request_method$host$request_uri&quot;;
add_header Content-Security-Policy &quot;default-src &#39;self&#39;; script-src &#39;self&#39;; img-src &#39;self&#39; https://placehold.it; style-src &#39;self&#39; https://fonts.googleapis.com ; font-src &#39;self&#39; https://themes.googleusercontent.com; frame-src &#39;none&#39;; object-src &#39;none&#39;&quot;;
server_tokens off;

server {
    listen 80;
    listen [::]:80;
    server_name my-app.domain;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    include snippets/ssl-my-app.domain.conf;
    include snippets/ssl-params.conf;
    client_max_body_size 50M;
    fastcgi_param HTTP_PROXY &quot;&quot;;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    root /var/www/my-app.domain/current/public;
    index index.php index.html index.htm;

    server_name my-app.domain;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.0-fpm-my-app.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_cache my-app;
        fastcgi_cache_valid 200 60m;
    }

    location ~ /.well-known {
        allow all;
    }

    location ~* \.(?:manifest|appcache|html?|xml|json)$ {
        expires -1;
        gzip on;
        gzip_vary on;
        gzip_types application/json text/xml application/xml;
    }

    location ~* \.(?:rss|atom)$ {
        expires 1h;
        add_header Cache-Control &quot;public&quot;;
        gzip on;
        gzip_vary on;
        gzip_types application/xml+rss;
    }

    location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
        expires 1M;
        access_log off;
        add_header Cache-Control &quot;public&quot;;
    }

    location ~* \.(?:css|js)$ {
        expires 1y;
        access_log off;
        add_header Cache-Control &quot;public&quot;;
        gzip on;
        gzip_vary on;
        gzip_types text/css application/javascript text/javascript;
    }
}
</code></pre>
<p>The times for FastCGI caching tend to vary in practice - sometimes it’s not appropriate to use it all, while for others it can be cached for some time.</p>
<p>It’s generally fairly safe to cache CSS and JS for a long time with a Laravel app if you’re using Mix to version those assets, so I feel comfortable caching them for a year. Images are a bit dicier, but still don’t change often so a month seems good enough.</p>
<p>I’ll typically give each application its own pool, which means copying the file at <code>/etc/php/7.0/fpm/pool.d/www.conf</code> to another file in the same directory, amending the pool name and path to set a new location for the socket, and then restarting Nginx and PHP-FPM. Here are the fields that should be changed:</p>
<pre><code class="lang-ini">; Start a new pool named &#39;www&#39;.
; the variable $pool can be used in any directive and will be replaced by the
; pool name (&#39;www&#39; here)
[my-app.domain]
...
listen = /var/run/php/php7.0-fpm-my-app.sock
</code></pre>
<h2 id="database">Database</h2>
<p>I’m a fan of PostgreSQL - it’s stricter than MySQL/MariaDB, and has some very useful additional field types, so where possible I prefer to use it over MySQL or MariaDB.</p>
<h2 id="cache-and-session-backend">Cache and session backend</h2>
<p>Redis is my usual choice here - I make heavy use of cache tags so I need a backend for the cache that supports them, and Memcached doesn’t seem to have as much inertia as Redis these days. Neither needs much in the way of configuration, but you can get a slight speed boost by using phpiredis.</p>
<h2 id="queue">Queue</h2>
<p>I sometimes use Redis for this too, but it can be problematic if you’re using Redis as the queue and broadcast backend, so these days I’m more likely to use Beanstalk and keep Redis for other stuff. I use Supervisor for running the queue worker, and this is an example of the sort of configuration I would use:</p>
<pre><code class="lang-ini">[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/artisan queue:work --sleep=3 --tries=3
autostart=true
autorestart=true
user=www-data
numprocs=8
redirect_stderr=true
stdout_logfile=/var/log/worker.log
</code></pre>
<p>This is fairly standard for Laravel applications.</p>
<h2 id="scheduler">Scheduler</h2>
<p>I often make use of the Laravel scheduled tasks system. Here’s the typical cron job that would be used for that:</p>
<pre><code class="lang-cron">* * * * * php /var/www/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1
</code></pre>
<p>Again, this is standard for Laravel applications. It runs the scheduler every minute, and the scheduler then determines if it needs to do something.</p>
<h2 id="provisioning">Provisioning</h2>
<p>To set all this up, I’ll generally use Ansible. In addition to this, I’ll generally also set up fail2ban to block various attacks via both HTTP and SSH.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deploying your Laravel application with Deployer]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/22/deploying-your-laravel-application-with-deployer/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/22/deploying-your-laravel-application-with-deployer/">
        </link>
        <updated>2018-01-22T12:00:14Z</updated>
        <summary type="html"><![CDATA[<p>Deployment processes have a nasty tendency to be a mish-mash of cobbled-together scripts or utilities in many web shops, with little or no consistency in practice between them. As a result, it’s all too easy for even the most experienced developer to mess up a deployment.</p>
<p>I personally have used all kinds of bodged-together solutions. For a while I used Envoy scripts to deploy my Laravel apps, but then there was an issue with the SSH library in PHP 7 that made it impractical to use it. Then I adopted Fabric, which I’d used before for deploying Django apps and will do fine for deploying PHP apps too, but it wasn’t much more sophisticated than using shell scripts for deployment purposes. There are third-party services like Deploybot, but these are normally quite expensive for what they are.</p>
<p>A while back I heard of <a href="https://deployer.org/">Deployer</a>, but I didn’t have the opportunity to try it until recently on a personal project as I was working somewhere that had its own in-house deployment process. It’s a PHP-specific deployment tool with recipes for deploying applications built with various frameworks and CMS’s, including Laravel, Symfony, CodeIgniter and Drupal.</p>
<h2 id="installing-deployer">Installing Deployer</h2>
<p>Deployer is installed as a <code>.phar</code> file, much like you would with Composer:</p>
<pre><code class="lang-bash">$ curl -LO https://deployer.org/deployer.phar
$ mv deployer.phar /usr/local/bin/dep
$ chmod +x /usr/local/bin/dep
</code></pre>
<p>With that done, you should be able to run the following command in your project’s directory to create a Deployer script:</p>
<pre><code class="lang-bash">$ dep init
</code></pre>
<p>In response, you should see a list of project types:</p>
<pre><code class="lang-bash">  Welcome to the Deployer config generator  



 This utility will walk you through creating a deploy.php file.
 It only covers the most common items, and tries to guess sensible defaults.

 Press ^C at any time to quit.

 Please select your project type [Common]:
  [0] Common
  [1] Laravel
  [2] Symfony
  [3] Yii
  [4] Yii2 Basic App
  [5] Yii2 Advanced App
  [6] Zend Framework
  [7] CakePHP
  [8] CodeIgniter
  [9] Drupal
 &gt;
</code></pre>
<p>Here I chose Laravel as I was deploying a Laravel project. I was then prompted for the repository URL - this will be filled in with the origin remote if the current folder is already a Git repository:</p>
<pre><code class="lang-bash">Repository [git@gitlab.com:Group/Project.git]:
 &gt; 
</code></pre>
<p>You’ll also see a message about contributing anonymous usage data. After answering this, the file <code>deploy.php</code> will be generated:</p>
<pre><code class="lang-php">&lt;?php
namespace Deployer;

require &#39;recipe/laravel.php&#39;;

// Configuration

set(&#39;repository&#39;, &#39;git@gitlab.com:Group/Project.git&#39;);
set(&#39;git_tty&#39;, true); // [Optional] Allocate tty for git on first deployment
add(&#39;shared_files&#39;, []);
add(&#39;shared_dirs&#39;, []);
add(&#39;writable_dirs&#39;, []);


// Hosts

host(&#39;project.com&#39;)
    -&gt;stage(&#39;production&#39;)
    -&gt;set(&#39;deploy_path&#39;, &#39;/var/www/project.com&#39;);

host(&#39;beta.project.com&#39;)
    -&gt;stage(&#39;beta&#39;)
    -&gt;set(&#39;deploy_path&#39;, &#39;/var/www/project.com&#39;);  


// Tasks

desc(&#39;Restart PHP-FPM service&#39;);
task(&#39;php-fpm:restart&#39;, function () {
    // The user must have rights for restart service
    // /etc/sudoers: username ALL=NOPASSWD:/bin/systemctl restart php-fpm.service
    run(&#39;sudo systemctl restart php-fpm.service&#39;);
});
after(&#39;deploy:symlink&#39;, &#39;php-fpm:restart&#39;);

// [Optional] if deploy fails automatically unlock.
after(&#39;deploy:failed&#39;, &#39;deploy:unlock&#39;);

// Migrate database before symlink new release.

before(&#39;deploy:symlink&#39;, &#39;artisan:migrate&#39;);
</code></pre>
<p>By default it has two hosts, <code>beta</code> and <code>production</code>, and you can refer to them by these names. You can also add or remove hosts, and amend the existing ones. Note the deploy path as well - this sets the place where the application gets deployed to.</p>
<p>Note that it’s set up to expect the server to be using PHP-FPM and Nginx by default, so if you’re using Apache you may need to amend the command to restart the server. Also, note that if like me you’re using PHP 7 on a distro like Debian that also has PHP 5 around, you’ll probably need to change the references to <code>php-fpm</code> as follows:</p>
<pre><code class="lang-php">desc(&#39;Restart PHP-FPM service&#39;);
task(&#39;php-fpm:restart&#39;, function () {
    // The user must have rights for restart service
    // /etc/sudoers: username ALL=NOPASSWD:/bin/systemctl restart php-fpm.service
    run(&#39;sudo systemctl restart php7.0-fpm.service&#39;);
});
after(&#39;deploy:symlink&#39;, &#39;php-fpm:restart&#39;);
</code></pre>
<p>You will also need to make sure the <code>acl</code> package is installed - on Debian and Ubuntu you can install it as follows:</p>
<pre><code class="lang-bash">$ sudo apt-get install acl
</code></pre>
<p>Now, the recipe for deploying a Laravel app will include the following:</p>
<ul>
<li>Pulling from the Git remote</li>
<li>Updating any Composer dependencies to match <code>composer.json</code></li>
<li>Running the migrations</li>
<li>Optimizing the application</li>
</ul>
<p>In addition, one really great feature Deployer offers is rollbacks. Rather than checking out your application directly into the project root you specify, it numbers each release and deploys it in a separate folder, before symlinking that folder to the project root as <code>current</code>. That way, if a release cannot be deployed successfully, rather than leaving your application in an unfinished state, Deployer will symlink the previous version so that you still have a working version of your application.</p>
<p>If you have configured Deployer for that project, you can deploy using the following command where <code>production</code> is the name of the host you’re deploying to:</p>
<pre><code class="lang-bash">$ dep deploy production
</code></pre>
<p>The output will look something like this:</p>
<pre><code class="lang-bash">✔ Executing task deploy:prepare
✔ Executing task deploy:lock
✔ Executing task deploy:release
➤ Executing task deploy:update_code
Counting objects: 761, done.
Compressing objects: 100% (313/313), done.
Writing objects: 100% (761/761), done.
Total 761 (delta 384), reused 757 (delta 380)
Connection to linklater.shellshocked.info closed.
✔ Ok
✔ Executing task deploy:shared
✔ Executing task deploy:vendors
✔ Executing task deploy:writable
✔ Executing task artisan:storage:link
✔ Executing task artisan:view:clear
✔ Executing task artisan:cache:clear
✔ Executing task artisan:config:cache
✔ Executing task artisan:optimize
✔ Executing task artisan:migrate
✔ Executing task deploy:symlink
✔ Executing task php-fpm:restart
✔ Executing task deploy:unlock
✔ Executing task cleanup
✔ Executing task success
Successfully deployed!
</code></pre>
<p>As you can see, we first of all lock the application and pull the latest version from the Git remote. Next we copy the files shared between releases (eg the <code>.env</code> file, the <code>storage/</code> directory etc), update the dependencies, and make sure the permissions are correct. Next we link the storage, clear all the cached content, optimize our app, and migrate the database, before we set up the symlink. Finally we restart the web server and unlock the application.</p>
<p>In the event you discover a problem after deploy and need to rollback manually, you can do so with the following command:</p>
<pre><code class="lang-bash">$ dep rollback production
</code></pre>
<p>That makes it easy to ensure that in the event of something going wrong, you can quickly switch back to an earlier version with zero downtime.</p>
<p>Deployer has made deployments a lot less painful for me than any other solution I’ve tried. The support for rollbacks means that if something goes wrong it’s trivial to switch back to an earlier revision.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Creating a caching user provider for Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/12/creating-a-caching-user-provider-for-laravel/">
        </link>
        <updated>2018-01-12T13:16:51Z</updated>
        <summary type="html"><![CDATA[<p>If you have a Laravel application that requires users to log in and you use Clockwork or Laravel DebugBar to examine the queries that take place, you’ll probably notice a query that fetches the user model occurs quite a lot. This is because the user’s ID gets stored in the session, and is then used to retrieve the model.</p>
<p>This query is a good candidate for caching because not only is that query being made often, but it’s also not something that changes all that often. If you’re careful, it’s quite easy to set your application up to cache the user without having to worry about invalidating the cache.</p>
<p>Laravel allows you to define your own user providers in order to fetch the user’s details. These must implement <code>Illuminate\Contracts\Auth\UserProvider</code> and must return a user model from the identifier provided. Out of the box it comes with two implementations, <code>Illuminate\Auth\EloquentUserProvider</code> and <code>Illuminate\Auth\DatabaseUserProvider</code>, with the former being the default. Our caching user provider can extend the Eloquent one as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Auth;

use Illuminate\Auth\EloquentUserProvider;
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Contracts\Hashing\Hasher as HasherContract;

class CachingUserProvider extends EloquentUserProvider
{
    /**
     * The cache instance.
     *
     * @var Repository
     */
    protected $cache;

    /**
     * Create a new database user provider.
     *
     * @param  \Illuminate\Contracts\Hashing\Hasher  $hasher
     * @param  string  $model
     * @param  Repository  $cache
     * @return void
     */
    public function __construct(HasherContract $hasher, $model, Repository $cache)
    {
        $this-&gt;model = $model;
        $this-&gt;hasher = $hasher;
        $this-&gt;cache = $cache;
    }

    /**
     * Retrieve a user by their unique identifier.
     *
     * @param  mixed  $identifier
     * @return \Illuminate\Contracts\Auth\Authenticatable|null
     */
    public function retrieveById($identifier)
    {
        return $this-&gt;cache-&gt;tags($this-&gt;getModel())-&gt;remember(&#39;user_by_id_&#39;.$identifier, 60, function () use ($identifier) {
            return parent::retrieveById($identifier);
        });
    }
}
</code></pre>
<p>Note that we override the constructor to accept a cache instance as well as the other arguments. We also override the <code>retrieveById()</code> method to wrap a call to the parent’s implementation inside a callback that caches the response. I usually tag anything I cache with the model name, but if you need to use a cache backend that doesn’t support tagging this may not be an option. Our cache key also includes the identifier so that it’s unique to that user.</p>
<p>We then need to add our user provider to the auth service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Gate;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use App\Auth\CachingUserProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        Auth::provider(&#39;caching&#39;, function ($app, array $config) {
            return new CachingUserProvider(
                $app-&gt;make(&#39;Illuminate\Contracts\Hashing\Hasher&#39;),
                $config[&#39;model&#39;],
                $app-&gt;make(&#39;Illuminate\Contracts\Cache\Repository&#39;)
            );
        });
    }
}
</code></pre>
<p>Note here that we call this provider <code>caching</code>, and we pass it the hasher, the model name, and an instance of the cache. Then, we need to update <code>config/auth.php</code> to use this provider:</p>
<pre><code class="lang-php">    &#39;providers&#39; =&gt; [
        &#39;users&#39; =&gt; [
            &#39;driver&#39; =&gt; &#39;caching&#39;,
            &#39;model&#39; =&gt; App\Eloquent\Models\User::class,
        ],
    ],
</code></pre>
<p>The only issue now is that our user models will continue to be cached, even when they are updated. To be able to flush the cache, we can create a model event that fires whenever the user model is updated:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Eloquent\Models;

use Illuminate\Notifications\Notifiable;
use Illuminate\Foundation\Auth\User as Authenticatable;
use App\Events\UserAmended;

class User extends Authenticatable
{
    use Notifiable;

    protected $dispatchesEvents = [
        &#39;saved&#39; =&gt; UserAmended::class,
        &#39;deleted&#39; =&gt; UserAmended::class,
        &#39;restored&#39; =&gt; UserAmended::class,
    ];
}
</code></pre>
<p>This will call the <code>UserAmended</code> event when a user model is created, updated, deleted or restored. Then we can define that event:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use App\Eloquent\Models\User;

class UserAmended
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct(User $model)
    {
        $this-&gt;model = $model;
    }
}
</code></pre>
<p>Note our event contains an instance of the user model. Then we set up a listener to do the work of clearing the cache:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Listeners;

use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use App\Events\UserAmended;
use Illuminate\Contracts\Cache\Repository;

class ClearUserId
{
    /**
     * Create the event listener.
     *
     * @return void
     */
    public function __construct(Repository $cache)
    {
        $this-&gt;cache = $cache;
    }

    /**
     * Handle the event.
     *
     * @param  object  $event
     * @return void
     */
    public function handle(UserAmended $event)
    {
        $this-&gt;cache-&gt;tags(get_class($event-&gt;model))-&gt;forget(&#39;user_by_id_&#39;.$event-&gt;model-&gt;id);
    }
}
</code></pre>
<p>Here, we get the user model’s class again, and clear the cache entry for that user model.</p>
<p>Finally, we hook up the event and listener in the event service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Event;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;

class EventServiceProvider extends ServiceProvider
{
    /**
     * The event listener mappings for the application.
     *
     * @var array
     */
    protected $listen = [
        &#39;App\Events\UserAmended&#39; =&gt; [
            &#39;App\Listeners\ClearUserId&#39;,
        ],
    ];

    /**
     * Register any events for your application.
     *
     * @return void
     */
    public function boot()
    {
        parent::boot();

        //
    }
}
</code></pre>
<p>With that done, our user should be cached after the first load, and flushed when the model is amended.</p>
<h2 id="handling-eager-loaded-data">Handling eager-loaded data</h2>
<p>It may be that you’re pulling in additional data from the user model in your application, such as roles, permissions, or a separate profile model. Under those circumstances it makes sense to treat that data in the same way by eager-loading it along with your user model.</p>
<pre><code class="lang-php">&lt;?php

namespace App\Auth;

use Illuminate\Auth\EloquentUserProvider;
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Contracts\Hashing\Hasher as HasherContract;

class CachingUserProvider extends EloquentUserProvider
{
    /**
     * The cache instance.
     *
     * @var Repository
     */
    protected $cache;

    /**
     * Create a new database user provider.
     *
     * @param  \Illuminate\Contracts\Hashing\Hasher  $hasher
     * @param  string  $model
     * @param  Repository  $cache
     * @return void
     */
    public function __construct(HasherContract $hasher, $model, Repository $cache)
    {
        $this-&gt;model = $model;
        $this-&gt;hasher = $hasher;
        $this-&gt;cache = $cache;
    }

    /**
     * Retrieve a user by their unique identifier.
     *
     * @param  mixed  $identifier
     * @return \Illuminate\Contracts\Auth\Authenticatable|null
     */
    public function retrieveById($identifier)
    {
        return $this-&gt;cache-&gt;tags($this-&gt;getModel())-&gt;remember(&#39;user_by_id_&#39;.$identifier, 60, function () use ($identifier) {
          $model = $this-&gt;createModel();
          return $model-&gt;newQuery()
            -&gt;with(&#39;roles&#39;, &#39;permissions&#39;, &#39;profile&#39;)
            -&gt;where($model-&gt;getAuthIdentifierName(), $identifier)
            -&gt;first();
        });
    }
}
</code></pre>
<p>Because we need to amend the query itself, we can’t just defer to the parent implementation like we did above and must instead copy it over and amend it to eager-load the data.</p>
<p>You’ll also need to set up model events to clear the cache whenever one of the related fields is updated, but it should be fairly straightforward to do so.</p>
<h2 id="summary">Summary</h2>
<p>Fetching a user model (and possibly some relations) on every page load while logged in can be a bit much, and it makes sense to cache as much as you can without risking serving stale data. Using this technique you can potentially cache a lot of repetitive, unnecessary queries and make your application faster.</p>
<p>This technique will also work in cases where you’re using other methods of maintaining user state, such as JWT, as long as you’re making use of a guard for authentication purposes, since all of these guards will still be using the same user provider. In fact, I first used this technique on a REST API that used JWT for authentication, and it’s worked well in that case.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Easy repositories and decorators with Laravel Repositories]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/10/easy-repositories-and-decorators-with-laravel-repositories/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/10/easy-repositories-and-decorators-with-laravel-repositories/">
        </link>
        <updated>2018-01-10T12:22:44Z</updated>
        <summary type="html"><![CDATA[<p>Creating repositories for your Laravel models, as well as creating caching decorators for them, is a useful way of not only implementing caching in your web app, but decoupling the application from a specific ORM. Unfortunately, it can involve writing a fair amount of boilerplate code.</p>
<p><a href="https://github.com/matthewbdaly/laravel-repositories">Laravel Repositories</a> is a set of base classes and interfaces for creating repositories and decorators in your application. It consists of:</p>
<ul>
<li>A generic interface for repositories</li>
<li>A base repository that implements the interface and can be extended for your own repositories</li>
<li>A base decorator that also implements the interface and can similarly be extended</li>
</ul>
<p>By using these, not only are you able to implement caching quickly and easily for most use cases, but you can easily extend the base classes to add additional methods for your use case. By creating new interfaces that extend the base interface, then having your repositories extend the repository and decorator, you can minimise the amount of work required to set up new repositories.</p>
<p>The main interface used is <code>Matthewbdaly\LaravelRepositories\Repositories\Interfaces\AbstractRepositoryInterface</code>, and your interfaces should extend this. Your decorators should extend <code>Matthewbdaly\LaravelRepositories\Repositories\Decorators\BaseDecorator</code>, and your repositories should extend <code>Matthewbdaly\LaravelRepositories\Repositories\Base</code>. Then, if you add any additional methods to your interface and ensure your repository and decorator implement that interface, it should be straightforward to type-hint the interface and get back the decorated repository, which will handle caching for you.</p>
<p>To be able to type-hint the repositories, you need to set them up in a service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;singleton(&#39;App\Repositories\Interfaces\ExampleRepositoryInterface&#39;, function () {
            $baseRepo = new \App\Repositories\EloquentExampleRepository(new \App\Example);
            $cachingRepo = new \App\Repositories\Decorators\ExampleDecorator($baseRepo, $this-&gt;app[&#39;cache.store&#39;]);
            return $cachingRepo;
        });
    }
}
</code></pre>
<p>Also, note that the cache backend used must be one that supports tags, such as Redis or Memcached. Data is cached using a tag derived from the model name. This also means you have to be careful when eager-loading relations, as the data will be cached under the main model’s name, not that of the relation. You may want to set up separate model events to flush those tags when the related field is updated.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Creating Laravel Helpers]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/09/creating-laravel-helpers/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/09/creating-laravel-helpers/">
        </link>
        <updated>2018-01-09T17:26:26Z</updated>
        <summary type="html"><![CDATA[<p>Although helpers are an important part of Laravel, the documentation doesn’t really touch on creating them. Fortunately, doing so it fairly easy.</p>
<p>Here I’m building a helper for formatting dates for the HTML5 <code>datetime-local</code> form input. First we define the helper function in <code>app\Helpers.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Carbon\Carbon;

if (!function_exists(&#39;format_date&#39;)) {
    function format_date(string $date)
    {
        return Carbon::parse($date, config(&#39;app.timezone&#39;))-&gt;format(&#39;Y-m-d\TH:i:s&#39;);
    }
}
</code></pre>
<p>Then we create a service provider to load them:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class HelperServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap the application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register the application services.
     *
     * @return void
     */
    public function register()
    {
        //
        require_once app_path() . &#39;/Helpers.php&#39;;
    }
}
</code></pre>
<p>Finally,we register the service provider in <code>config/app.php</code>:</p>
<pre><code class="lang-php">    &#39;providers&#39; =&gt; [

       ...
        App\Providers\HelperServiceProvider::class,
   ],
</code></pre>
<p>Of course, once you have this all set up for one helper, it’s easy to add more because they can all go in <code>app/Helpers.php</code>.</p>
<p>Creating your own helpers is a good way of refactoring unwanted logic out of your Blade templates or controllers and making it more reusable and maintainable, particularly for things like formatting dates or strings.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Getting the type of an unsupported Postgres field in Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/08/getting-the-type-of-an-unsupported-postgres-field-in-laravel/">
        </link>
        <updated>2018-01-08T14:00:15Z</updated>
        <summary type="html"><![CDATA[<p>Today I’ve been working on a generic, reusable Laravel admin interface, loosely inspired by the Django admin, that dynamically picks up the field types and generates an appropriate input field accordingly.</p>
<p>One problem I’ve run into is that getting a representation of a database table’s fields relies on <code>doctrine/dbal</code>, and its support for the more unusual PostgreSQL field types is spotty at best. I’ve been testing it out on a Laravel-based blogging engine, which has full-text search using the <code>TSVECTOR</code> field type, which isn’t supported, and it threw a nasty <code>Unknown database type tsvector requested</code> error.</p>
<p>Fortunately, it’s possible to register custom field type mappings easily enough. In this case we can safely treat a <code>TSVECTOR</code> field as a string` type anyway, so we can map it to the string type. We can do so in the boot method of a service provider:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        // Register the TSVECTOR column
        $conn = $this-&gt;app-&gt;make(&#39;Illuminate\Database\ConnectionInterface&#39;);
        $conn-&gt;getDoctrineSchemaManager()
            -&gt;getDatabasePlatform()
            -&gt;registerDoctrineTypeMapping(&#39;tsvector&#39;, &#39;string&#39;);
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
       //
    }
}
</code></pre>
<p>We register a Doctrine type mapping that maps the <code>tsvector</code> type to a string. Now Doctrine will just treat it as a string.</p>
<p>We can then retrieve the field types as follows:</p>
<pre><code class="lang-php">        $table = $this-&gt;model-&gt;getTable();
        $fields = array_values(Schema::getColumnListing($table));
        $fielddata = [];
        foreach ($fields as $field){
            if ($field != &#39;id&#39; &amp;&amp; $field != &#39;created_at&#39; &amp;&amp; $field != &#39;updated_at&#39; &amp;&amp; $field != &#39;deleted_at&#39;) {
                try {
                    $fielddata[$field] = Schema::getColumnType($table, $field);
                } catch (\Exception $e) {
                    $fielddata[$field] = &#39;unknown&#39;;
                }
            }
        }
</code></pre>
<p>Note that we specifically don’t want to retrieve the ID or timestamps, so we exclude them - the user should never really have the need to update them manually. We fetch the table from the model and then call <code>Schema::getColumnListing()</code> to retrieve a list of fields for that table. Finally we call <code>Schema::getColumnType()</code> to actually get the type of each column.</p>
<p>Now, I suspect the performance of this admin interface is going to be inferior to a more specific one because it has to retrieve the fields all the time, but that’s not the point here - with a non-user facing admin interface, performance isn’t quite as much of an issue. For the same reason the admin doesn’t do any caching at all. It’s still useful under certain circumstances to be able to reverse-engineer the table structure and render an appropriate form dynamically.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Creating an Artisan task to set up a user account]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/08/creating-an-artisan-task-to-set-up-a-user-account/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/08/creating-an-artisan-task-to-set-up-a-user-account/">
        </link>
        <updated>2018-01-08T12:52:39Z</updated>
        <summary type="html"><![CDATA[<p>When working with any Laravel application that implements authentication, you’ll need to set up a user account to be able to work with it. One way of doing that is to add a user in a seeder, but that’s only really suitable if every user is going to use the same details.</p>
<p>Instead, you may want to create an Artisan command to set up the user account. Here’s an example of a command that does that:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Hash;

class CreateUser extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &#39;create:user&#39;;

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &#39;Creates a single user&#39;;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        // Get user model from config
        $model = config(&#39;auth.providers.users.model&#39;);

        // Let user know what this will do
        $this-&gt;info(&#39;I\&#39;ll ask you for the details I need to set up the user&#39;);

        // Get username
        $name = $this-&gt;ask(&#39;Please provide the username&#39;);

        // Get email
        $email = $this-&gt;ask(&#39;Please provide the email address&#39;);

        // Get password
        $password = $this-&gt;secret(&#39;Please provide the password&#39;);

        // Create model
        $user = new $model;
        $user-&gt;name = $name;
        $user-&gt;email = $email;
        $user-&gt;password = Hash::make($password);
        $user-&gt;save();
        $this-&gt;info(&#39;User saved&#39;);
    }
}
</code></pre>
<p>We fetch the user model from the config, before asking the user for the data we need. Then we insert it into the database and confirm it to the user.</p>
<p>Then we just need to register the command in <code>App\Console\Kernel.php</code>:</p>
<pre><code class="lang-php">    protected $commands = [
        \App\Console\Commands\CreateUser::class,
    ];
</code></pre>
<p>And we can run our command with <code>php artisan create:user</code>.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Adding comments to models in Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/07/adding-comments-to-models-in-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/07/adding-comments-to-models-in-laravel/">
        </link>
        <updated>2018-01-07T17:21:50Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://github.com/matthewbdaly/laravel-comments">Laravel Comments</a> is a package I recently released that allows you to add comments to any model in your application. Possible models you could use it to enable comments on might include:</p>
<ul>
<li>Blog posts</li>
<li>Forum posts</li>
<li>Issues on an issue tracker</li>
</ul>
<p>It’s loosely inspired by Django’s comments system.</p>
<h2 id="installation">Installation</h2>
<p>Run this command to install it:</p>
<pre><code class="lang-bash">$ composer require matthewbdaly/laravel-comments
</code></pre>
<p>You will also need to run <code>php artisan migrate</code> to create the appropriate tables.</p>
<h2 id="making-a-model-commentable">Making a model commentable</h2>
<p>Add the following trait to a model to make it commentable:</p>
<pre><code class="lang-php">Matthewbdaly\LaravelComments\Eloquent\Traits\Commentable
</code></pre>
<p>The comments table uses a polymorphic relation, so it should be possible to attach it to pretty much any model. The model should now have a <code>comments</code> relation, allowing you to get the comments for a model instance.</p>
<h2 id="displaying-the-comments">Displaying the comments</h2>
<p>Obviously you can just render the comments in a view you can create yourself, but it’s usually going to be more convenient to use the existing view, even if just as a starting point, which includes the ability to submit new comments and flag existing ones. Include it in your views as follows:</p>
<pre><code class="lang-php">@include(&#39;comments::comments&#39;, [&#39;parent&#39; =&gt; $post])
</code></pre>
<p>The argument passed to <code>parent</code> should be the model instance for which you want to display the comments form. Obviously, you can easily override this to use your own custom form instead.</p>
<p>The package also contains the following views:</p>
<ul>
<li><code>comments::commentsubmitted</code></li>
<li><code>comments::flagsubmitted</code></li>
</ul>
<p>These are basically just acknowledgement screens for when a comment has been submitted or flagged, and you’ll probably want to override them.</p>
<p>The package also has its own routes and controller included for submitting comments and flags.</p>
<h2 id="using-the-models-directly">Using the models directly</h2>
<p>Of course there’s nothing stopping you creating your own routes and controllers for creating, viewing and flagging comments, and if, for instance, you wish to build a REST API that allows for adding comments to objects you can just use these models directly:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Eloquent\Models\Comment</code></li>
<li><code>Matthewbdaly\LaravelComments\Eloquent\Models\Comment\Flag</code></li>
</ul>
<p>I recommend that you use my repositories, which are as follows:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Contracts\Repositories\Comment</code></li>
<li><code>Matthewbdaly\LaravelComments\Contracts\Repositories\Comment\Flag</code></li>
</ul>
<p>These use <code>matthewbdaly/laravel-repositories</code> and so implement caching on the decorated repository, making it simple to ensure your models get cached appropriately. However, they aren’t compulsory.</p>
<h2 id="events">Events</h2>
<p>You can set up listeners for the following events:</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Events\CommentReceived</code></li>
</ul>
<p>Fired when a new comment is submitted. The package does not include any kind of validation of comments, so you can instead listen for this event and implement your own functionality to validate them (eg, check it with Akismet, check for links). That way you can easily customise how it handles potentially spammy comments for your own particular use case.</p>
<ul>
<li><code>Matthewbdaly\LaravelComments\Events\CommentFlagged</code></li>
</ul>
<p>This event indicates that a comment has been flagged for moderator attention. You can use this event to send whatever notification is most appropriate (eg, email, Slack, SMS).</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[More tricks for speeding up your Laravel test suite]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/07/more-tricks-for-speeding-up-your-laravel-test-suite/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/07/more-tricks-for-speeding-up-your-laravel-test-suite/">
        </link>
        <updated>2018-01-07T16:32:03Z</updated>
        <summary type="html"><![CDATA[<p>When you first start doing test-driven development with Laravel, it can be quite hard to produce a test suite that runs quickly enough. The first time I used Laravel for a large project, I had a test suite that at one time, took over seven minutes to run, which was pretty awful considering that the ideal time for a test suite to take to run is no more than ten seconds.</p>
<p>Fortunately, with experience you can pick up some techniques which can quite drastically speed up your test suite. Here are some of the ones I’ve learned that can be useful.</p>
<p>Note that some of these are contradictory, and what works for one use case won’t necessarily work for another, so my advice is to try these and see what makes a difference for your use case.</p>
<h2 id="reduce-the-cost-of-hashing">Reduce the cost of hashing</h2>
<p>Inside the <code>createApplication()</code> method of <code>tests\CreatesApplication.php</code>, place the following statement:</p>
<pre><code class="lang-php">        Hash::setRounds(4);
</code></pre>
<p>This makes hashing passwords quicker and less demanding, and since you don’t care about the security of a password in a test, you’re not losing out in any way by doing so.</p>
<p>This, by itself, can <em>massively</em> reduce the time taken by your test suite - your mileage may vary, but I’ve personally seen it cut to a third of the previous time by using this. In fact, it’s recently been added to Laravel by default.</p>
<h2 id="if-you-re-creating-a-lot-of-fixtures-for-tests-do-so-in-a-transaction">If you’re creating a lot of fixtures for tests, do so in a transaction</h2>
<p>Sometimes, your application requires a lot of data to be added to the database just to be usable, and it’s quite common to use seeders for this purpose. However, it can take some time to insert a lot of data, especially if it has to be re-run for every test. If you do have to insert a lot of data before a test, you can cut down the time substantially by wrapping the seeder calls in a transaction:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Illuminate\Database\Eloquent\Model;
use DB;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        Model::unguard();

        DB::beginTransaction();
        $this-&gt;call(GroupTableSeeder::class);
        $this-&gt;call(UserTableSeeder::class);
        $this-&gt;call(ProjectTableSeeder::class);
        DB::commit();

        Model::reguard();
    }
}
`
</code></pre>
<p>I’ve personally seen this trick cut the insert time by over half, every single time the database is seeded. If you don’t have much data to insert, it may not help, but for large amounts of data it can make a big difference.</p>
<h2 id="if-a-lot-of-tests-need-the-same-data-migrate-and-seed-it-first-then-wrap-the-tests-in-transactions-and-roll-them-back-afterwards">If a lot of tests need the same data, migrate and seed it first, then wrap the tests in transactions and roll them back afterwards</h2>
<p>If multiple tests need to work with the same dataset, you should consider running the migrations and seeders before the first test, and then wrapping each test inside a transaction. That way the data will only be inserted once, and will be rolled back to that initial good state after each test.</p>
<pre><code class="lang-php">    protected static $migrated = false;

    public function setUp()
    {
        parent::setUp();
        DB::beginTransaction();
    }

    public function tearDown()
    {
        DB::rollback();
        parent::tearDown();
    }

    public static function setUpBeforeClass()
    {
        if (!self::$migrated) {
            Artisan::call(&#39;migrate:fresh&#39;);
            Artisan::call(&#39;db:seed&#39;);
            self::$migrated = true;
        }
    }
</code></pre>
<p>Using something like this instead of one of the existing testing traits may be a better fit under those circumstances. However, if your application uses transactions for some functionality this might cause problems.</p>
<h2 id="don-t-create-a-full-instance-of-the-laravel-application-unless-you-have-to">Don’t create a full instance of the Laravel application unless you have to</h2>
<p>Not every test requires that you instantiate the full Laravel application, and doing so slows your tests down. If you don’t absolutely need the full application instantiated in the test, consider having your test inherit from the below simple test case class instead:</p>
<pre><code class="lang-php">&lt;?php

namespace Tests;

use Mockery\Adapter\Phpunit\MockeryPHPUnitIntegration;
use PHPUnit\Framework\TestCase as BaseTestCase;

class SimpleTestCase extends BaseTestCase
{
    use MockeryPHPUnitIntegration;
}
</code></pre>
<p>For properly isolated unit tests, using this base class instead can have a noticeable effect on performance.</p>
<h2 id="if-you-can-use-an-in-memory-sqlite-database-for-testing">If you can, use an in-memory SQLite database for testing</h2>
<p>This isn’t an option if you’re relying on the features of another database, but if it is, this is usually the fastest way to go. Configure it as follows in <code>phpunit.xml</code>:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<h2 id="use-the-new-refresh-database-trait">Use the new Refresh Database trait</h2>
<pre><code class="lang-php">   use RefreshDatabase;
</code></pre>
<p>This testing trait is generally more efficient than migrating down and up, because it empties the database afterwards rather than stepping through the changes of each migration. If you have a non-trivial number of migrations, it will almost certainly be quicker than migrating down, then back up for the next test.</p>
<h2 id="mock-what-you-can-t-control">Mock what you can’t control</h2>
<p>You should never, ever be making calls to external APIs in your test suite, because you can’t control whether those external API’s work - if a third-party API goes down, you may get a failed test run even if your application is working perfectly, not to mention it will add the time taken to send the request and receive a response to the test time. Instead, mock the calls to the third-party API.</p>
<h2 id="for-large-applications-consider-moving-parts-into-a-separate-package">For large applications, consider moving parts into a separate package</h2>
<p>If you have a particularly large application, it’s worth considering moving parts of it out into standalone packages and requiring them using Composer’s support for private Git repositories. That way, those packages can have their own test suites, and the main application’s test suite can cover the remaining functionality.</p>
<p>For instance, it’s fairly straightforward to pull out your models and migrations and put them in a separate package, and the tests for them can go with them to that package.</p>
<p>You should also consider whether parts of your application would be useful as standalone packages, and if so pull them out along with their tests. That way, not only are you making your test suite quicker, but you’re also saving yourself work by creating a reusable solution for a problem you might encounter again in the future.</p>
<h2 id="turn-off-xdebug">Turn off XDebug</h2>
<p>XDebug has a horrendous effect on the performance of the test suite. Turn it off unless you need it to generate test coverage. Better yet, set up continuous integration and have that generate the coverage for you.</p>
<h2 id="summary">Summary</h2>
<p>When you first start using Laravel, it can be hard to keep your test suite lean, and the longer a test suite takes to run, the less likely it is to actually get run regularly. To practice TDD properly, your test suite should not take long enough that your mind starts to wander, and ten seconds is a good target to aim for in this regard - you need to be able to run it several times a minute without problem. Obviously things like having a faster computer or an SSD will help, but there’s a lot you can do to make your test suite more efficient, even when running on a quite basic machine.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Adding dynamic flat pages to your Laravel app]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/03/adding-dynamic-flat-pages-to-your-laravel-app/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/03/adding-dynamic-flat-pages-to-your-laravel-app/">
        </link>
        <updated>2018-01-03T11:49:11Z</updated>
        <summary type="html"><![CDATA[<p>Most web apps have at least some need for some additional flat pages, for purposes such as:</p>
<ul>
<li>Terms and conditions</li>
<li>Cookie/privacy policy</li>
<li>FAQ</li>
</ul>
<p>You can of course hard-code this content in a view file, but if this content is likely to change often it may be useful to give the site owners the capability to manage this themselves.</p>
<p><a href="https://github.com/matthewbdaly/laravel-flatpages">Laravel Flatpages</a> is a package I wrote that adds a flatpage model, controller and view to your application. It’s loosely inspired by Django’s flatpages app. Using it, you can quickly and easily build a very simple brochure-style CMS. Each page contains fields for the title, content, slug, and an optional template field that specifies which view to use.</p>
<p>Note that it doesn’t include any kind of admin functionality, so you’ll need to add this yourself or find a package for it. It uses my <a href="http://github.com/matthewbdaly/laravel-repositories">repositories package</a> to access the database, and this has caching built in, so when you create, update or delete a flatpage, you should either resolve <code>Matthewbdaly\LaravelFlatpages\Contracts\Repositories\Flatpage</code> and use the methods on that to make the changes (in which case the appropriate caches should be flushed automatically), or flush the cache. It also requires a cache backend that supports tags, such as Memcached or Redis.</p>
<p>It does not include routing in the package itself because I couldn’t find a way to guarantee that it would always be the last route, so instead you should put this in your <code>routes/web.php</code> and make sure it’s always the last route:</p>
<pre><code class="lang-php">Route::get(&#39;{path}&#39;, &#39;\Matthewbdaly\LaravelFlatpages\Http\Controllers\FlatpageController@page&#39;);
</code></pre>
<p>Otherwise you could wind up with problems. The reason for that is that it has to check the path against the slugs of the flat pages in the database, and if it doesn’t find any it raises a 404.</p>
<p>Or, if you prefer, you can use the middleware at <code>Matthewbdaly\LaravelFlatpages\Http\Middleware\FlatpageMiddleware</code>, which may be more convenient in many case. This should be added as the last global middleware in <code>app\Http\Kernel.php</code>.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[A Laravel package boilerplate]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/02/a-laravel-package-boilerplate/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/02/a-laravel-package-boilerplate/">
        </link>
        <updated>2018-01-02T12:12:15Z</updated>
        <summary type="html"><![CDATA[<p>The second package I’ve been working on recently is <a href="https://github.com/matthewbdaly/laravel-package-boilerplate">Laravel Package Boilerplate</a>. It’s a basic starter boilerplate for building your own Laravel packages.</p>
<p>It’s not meant to be installed as a project dependency. Instead, run the following command to create a new project boilerplate with it:</p>
<pre><code class="lang-bash">composer create-project --prefer-dist matthewbdaly/laravel-package-boilerplate &lt;YOUR_NEW_PACKAGE_DIRECTORY&gt;
</code></pre>
<p>This will create a new folder that includes a <code>src</code> folder containing a service provider, and a <code>tests</code> folder containing a preconfigured base test case, as well as a simple test case for tests that don’t need the full application instantiated, in order to help keep your test suite as fast as possible.</p>
<p>In addition, it includes configuration files for:</p>
<ul>
<li>PHPUnit</li>
<li>PHP CodeSniffer</li>
<li>Travis CI</li>
</ul>
<p>That way you can start your project off the right way with very little effort.</p>
<p>I’ve also added my Artisan Standalone project as a dependency - that way you can access any Artisan commands you need to generate files you need as follows:</p>
<pre><code class="lang-bash">$ vendor/bin/artisan
</code></pre>
<p>Hopefully this package should make it a lot easier to create new Laravel packages in future.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using Artisan from standalone Laravel packages]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/02/using-artisan-from-standalone-laravel-packages/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/02/using-artisan-from-standalone-laravel-packages/">
        </link>
        <updated>2018-01-02T12:01:10Z</updated>
        <summary type="html"><![CDATA[<p>Recently I’ve been building and publishing a significant number of Laravel packages, and I thought I’d share details of some of them over the next few days.</p>
<p><a href="https://github/com/matthewbdaly/artisan-standalone">Artisan Standalone</a> is a package that, when installed in a standalone Laravel package (eg, not in an actual Laravel install, but in a package that you’re building that is intended for use with Laravel), allows you to use Artisan. It’s intended largely to make it quicker and easier to build functionality as separate packages by giving you access to the same generator commands as you have when working with a Laravel application. It came about largely from a need to scratch my own itch, as when building packages I was having to either run Artisan commands in a Laravel app and move them over, or copy them from existing files, which was obviously a pain in the proverbial.</p>
<p>You can install it with the following command:</p>
<pre><code class="lang-bash">$ composer require --dev matthewbdaly/artisan-standalone
</code></pre>
<p>Once it’s installed, you can access Artisan as follows:</p>
<pre><code class="lang-bash">$ vendor/bin/artisan
</code></pre>
<p>Note that it doesn’t explicitly include Laravel as a dependency - you’ll need to add that in the parent package to pull in the libraries it needs (which you should be doing anyway). It’s possible that there are some commands that won’t work in this context, but they’re almost certainly ones you won’t need here, such as the <code>migrate</code> command. As far as I can tell the generator commands, which are the only ones we’re really interested in here, all work OK.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Creating Artisan tasks that generate files]]></title>
        <id>https://matthewdaly.co.uk/blog/2018/01/01/creating-artisan-tasks-that-generate-files/</id>
        <link href="https://matthewdaly.co.uk/blog/2018/01/01/creating-artisan-tasks-that-generate-files/">
        </link>
        <updated>2018-01-01T16:06:21Z</updated>
        <summary type="html"><![CDATA[<p>While the documentation for creating Artisan tasks is generally pretty good, it doesn’t really touch on creating tasks that generate new files. The only way to figure it out was to go digging through the source code. In this case, I was building an Artisan command to create Fractal transformers as part of a package I’m working on.</p>
<p>There’s a specialised class for generating files at <code>Illuminate\Console\GeneratorCommand</code>, which your command class should extend instead of <code>Illuminate\Console\Command</code>. In addition to the usual properties such as the signature and description, you also need to specify <code>$type</code> to give the type of class being generated. Also, note that the constructor is different, so if you use <code>php artisan make:console</code> to create the boilerplate for this command, you’ll need to delete the constructor.</p>
<pre><code class="lang-php">&lt;?php

namespace Matthewbdaly\MyPackage\Console\Commands;

use Illuminate\Console\GeneratorCommand;
use Symfony\Component\Console\Input\InputArgument;

class TransformerMakeCommand extends GeneratorCommand
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &#39;make:transformer {name : The required name of the transformer class}&#39;;

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &#39;Create a Fractal transformer&#39;;

    /**
     * The type of class being generated.
     *
     * @var string
     */
    protected $type = &#39;Fractal transformer&#39;;

    /**
     * Get the stub file for the generator.
     *
     * @return string
     */
    protected function getStub()
    {
        return __DIR__.&#39;/stubs/transformer.stub&#39;;
    }

    /**
     * Get the console command arguments.
     *
     * @return array
     */
    protected function getArguments()
    {
        return [
            [&#39;name&#39;, InputArgument::REQUIRED, &#39;The name of the command.&#39;],
        ];
    }

    /**
     * Get the default namespace for the class.
     *
     * @param  string  $rootNamespace
     * @return string
     */
    protected function getDefaultNamespace($rootNamespace)
    {
        return $rootNamespace.&#39;\Transformers&#39;;
    }
}
</code></pre>
<p>Note the <code>getDefaultNamespace()</code> method. If your class will live directly under the <code>app</code> folder this is not necessary. Otherwise, it needs to return the root namespace, with the folder structure you want after it. Here my class will live under <code>app\Transformers</code>, so I’ve set it to reflect that.</p>
<p>Also, note the <code>getStub()</code> method. This tells Artisan that it should use the specified stub file as the basis for our class. Below you’ll find the stub file I used for my transformer:</p>
<pre><code class="lang-php">&lt;?php

namespace DummyNamespace;

use Matthewbdaly\MyPackage\Transformers\BaseTransformer;
use Illuminate\Database\Eloquent\Model;

class DummyClass extends BaseTransformer
{
    public function transform(Model $model)
    {
        return [
            &#39;id&#39;            =&gt; (int) $model-&gt;id,
        ];
    }
}
</code></pre>
<p>Note that the <code>DummyNamespace</code> and <code>DummyClass</code> fields will be overwritten with the correct values.</p>
<p>Once this Artisan command is registered in the usual way, you can then run it as follows:</p>
<pre><code class="lang-bash">$ php artisan make:transformer Example
</code></pre>
<p>And it will generate a boilerplate class something like this:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Transformers;

use Matthewbdaly\MyPackage\Transformers\BaseTransformer;
use Illuminate\Database\Eloquent\Model;

class Example extends BaseTransformer
{
    public function transform(Model $model)
    {
        return [
            &#39;id&#39;            =&gt; (int) $model-&gt;id,
        ];
    }
}
</code></pre>
<p>You can then replace the model with your own one as necessary, and add any further content to this class.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using UUIDs as primary keys with Laravel and PostgreSQL]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/12/29/using-uuids-as-primary-keys-with-laravel-and-postgresql/">
        </link>
        <updated>2017-12-29T18:01:04Z</updated>
        <summary type="html"><![CDATA[<p>For many applications, using UUID’s as the primary keys on a database table can make a lot of sense. For mobile or offline apps, in particular, they mean you can create new objects locally and assign them a primary key without having to worry about it colliding with another object that was created in the meantime once it gets synchronised to the server. Also, they are less informative to nefarious users - an autoincrementing value in a URL tells a user that that value is the primary key, and means the app may potentially allow gathering of information via user enumeration (eg calling <code>/api/v1/users/1</code>, <code>/api/v1/users/2</code> etc).</p>
<p>It’s fairly straightforward to use UUID’s as primary keys on your models when using PostgreSQL. First, you need to set up your migrations to use the <code>uuid-ossp</code> extension and set up the <code>id</code> field as both a UUID and the primary key. You also need to set a default value manually so that if it’s left empty it will generate a UUID for it.</p>
<pre><code class="lang-php">DB::statement(&#39;CREATE EXTENSION IF NOT EXISTS &quot;uuid-ossp&quot;;&#39;);
Schema::create(&#39;items&#39;, function (Blueprint $table) {
    $table-&gt;uuid(&#39;id&#39;)-&gt;primary();
    $table-&gt;text(&#39;text&#39;)-&gt;nullable();
    $table-&gt;timestamps();
});
DB::statement(&#39;ALTER TABLE items ALTER COLUMN id SET DEFAULT uuid_generate_v4();&#39;);
</code></pre>
<p>Then, in the model definition, you need to tell Laravel to cast the <code>id</code> field to a string, and explicitly set the primary key to <code>id</code>:</p>
<pre><code class="lang-php">class Item extends Model
{
    protected $casts = [
        &#39;id&#39; =&gt; &#39;string&#39;,
    ];

    protected $primaryKey = &quot;id&quot;;
}
</code></pre>
<p>Once this is done, the model should generate the primary keys for you as usual, except as UUID’s. If your application needs to accept UUID primary keys that were created offline, such as in a mobile app, you will probably want to add the <code>id</code> field to the <code>$fillable</code> array on the model to allow this.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Full text search with Laravel and PostgreSQL]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/12/02/full-text-search-with-laravel-and-postgresql/">
        </link>
        <updated>2017-12-02T23:30:44Z</updated>
        <summary type="html"><![CDATA[<p>I’ve touched on <a href="/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/">using PostgreSQL to implement fuzzy search with Laravel before</a>, but another type of search that PostgreSQL can handle fairly easily is full-text search. Here I’ll show you how to use it in a Laravel application.</p>
<p>An obvious use case for this kind of search is a personal blogging engine. It’s unlikely something like this is going to have enough content for it to be worth using a heavier solution like Elasticsearch, but a <code>LIKE</code> or <code>ILIKE</code> statement doesn’t really cut it either, so Postgres’s full text search is a good fit. Below you’ll see a Laravel migration for the blog posts table:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreatePostsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create(&#39;posts&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;title&#39;);
            $table-&gt;datetime(&#39;pub_date&#39;);
            $table-&gt;text(&#39;text&#39;);
            $table-&gt;string(&#39;slug&#39;);
            $table-&gt;integer(&#39;author_id&#39;);
            $table-&gt;timestamps();
        });
        DB::statement(&quot;ALTER TABLE posts ADD COLUMN searchtext TSVECTOR&quot;);
        DB::statement(&quot;UPDATE posts SET searchtext = to_tsvector(&#39;english&#39;, title || &#39;&#39; || text)&quot;);
        DB::statement(&quot;CREATE INDEX searchtext_gin ON posts USING GIN(searchtext)&quot;);
        DB::statement(&quot;CREATE TRIGGER ts_searchtext BEFORE INSERT OR UPDATE ON posts FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(&#39;searchtext&#39;, &#39;pg_catalog.english&#39;, &#39;title&#39;, &#39;text&#39;)&quot;);
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        DB::statement(&quot;DROP TRIGGER IF EXISTS tsvector_update_trigger ON posts&quot;);
        DB::statement(&quot;DROP INDEX IF EXISTS searchtext_gin&quot;);
        DB::statement(&quot;ALTER TABLE posts DROP COLUMN searchtext&quot;);
        Schema::dropIfExists(&#39;posts&#39;);
    }
}
</code></pre>
<p>Note that after we create the basic layout of our <code>posts</code> table, we then have to drop down to raw DB statements to achieve the next steps:</p>
<ul>
<li>We add a column called <code>searchtext</code> with a type of <code>TSVECTOR</code> (unfortunately Laravel doesn’t have a convenient method to create this column type, so we need to do it with a raw statement). This column will hold our searchable document.</li>
<li>We use the <code>to_tsvector()</code> method to generate a document on each row that combines the title and text fields and store it in the <code>searchtext</code> column. Note also that we specify the language as the first argument. This is because Postgres’s full text search understands so-called “stopwords”, which are words that are so common as to not be worth bothering with at all, such as “the” - these will obviously differ between languages, so it’s prudent to explicitly state this so Postgres knows what stopwords to expect.</li>
<li>We create a <code>GIN</code> index on the <code>posts</code> table using our new <code>searchtext</code> column.</li>
<li>Finally we create a trigger which, when the table is amended, regenerates the search text.</li>
</ul>
<p>With that done, we can now look at actually performing a full-text search. To facilitate easy re-use, we’ll create a local scope on our <code>Post</code> model. If you haven’t used scopes in Laravel before, they essentially allow you to break queries into reusable chunks. In this case, we expect our scope to receive two arguments, the query instance (which is passed through automatically), and the search text:</p>
<pre><code class="lang-php">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    protected $fillable = [
        &#39;title&#39;,
        &#39;pub_date&#39;,
        &#39;text&#39;,
        &#39;slug&#39;,
        &#39;author_id&#39;
    ];

    public function scopeSearch($query, $search)
    {
        if (!$search) {
            return $query;
        }
        return $query-&gt;whereRaw(&#39;searchtext @@ to_tsquery(\&#39;english\&#39;, ?)&#39;, [$search])
            -&gt;orderByRaw(&#39;ts_rank(searchtext, to_tsquery(\&#39;english\&#39;, ?)) DESC&#39;, [$search]);
    }
}
</code></pre>
<p>If <code>$search</code> is empty, we just return the query object as is. Otherwise, we first of all construct a <code>WHERE</code> clause that matches our search text against the <code>searchtext</code> column. Note the syntax used here:</p>
<pre><code class="lang-sql">searchtext @@ to_tsquery(&#39;english&#39;, &#39;foo&#39;)
</code></pre>
<p>We use the <code>to_tsquery()</code> method to match our text against our search document. As before, note that we specify the language.</p>
<p>Finally, we specify an order - we want the highest ranked matches to appear first, and this section of the query does that:</p>
<pre><code class="lang-sql">ts_rank(searchtext, to_tsquery(&#39;english&#39;, &#39;foo&#39;)) DESC
</code></pre>
<p>Here we use <code>ts_rank()</code> to ensure we get our results in the appropriate order. Note that for both queries, we passed the arguments through as parameterized queries, rather than constructing a raw string - we have to watch out for SQL injection when we’re writing raw queries, but we can use PDO’s parameterized queries from Eloquent in a raw statement, which makes things a bit easier.</p>
<p>Now we can call our new search scope as follows:</p>
<pre><code class="lang-php">$posts = Post::search($search)-&gt;get();
</code></pre>
<p>Because the scope receives and returns a query builder instance, you can continue to add the rest of your query, or paginate it, as necessary:</p>
<pre><code class="lang-php">$posts = Post::search($search)-&gt;where(&#39;draft&#39;, false)-&gt;simplePaginate(5);
</code></pre>
<p>If you’re working in a language that makes heavy use of accents, such as French, you might also want to install the <code>unaccent</code> extension (you can do this in the migration with <code>CREATE EXTENSION unaccent</code>). Then, any time we call <code>to_tsvector()</code>, you should pass any strings through the <code>unaccent()</code> method to strip out the accents.</p>
<h2 id="do-we-need-the-migrations-">Do we need the migrations?</h2>
<p>Technically, we could do without the additional changes to the database structure - we could create a document on the fly inside a subquery and use that to query against, which would look something like this in SQL:</p>
<pre><code class="lang-sql">SELECT *
FROM
  (SELECT *,
          to_tsvector(&#39;english&#39;, posts.title) || to_tsvector(&#39;english&#39;, posts.text) AS document
   FROM &quot;posts&quot;) search
WHERE search.document @@ to_tsquery(&#39;Redis&#39;)
ORDER BY ts_rank(search.document, to_tsquery(&#39;english&#39;, &#39;Redis&#39;)) DESC;
</code></pre>
<p>However, the performance is likely to be significantly worse using this approach as it has to recreate the document, and doesn’t have an existing index to query against. It’s also a pig to write something like this with an ORM.</p>
<p>I’m currently working on a more generic solution for implementing full text search with Postgres and Laravel, however so far it looks like that solution will not only be considerably more complex than this (consistently producing a suitable query for unknown data is rather fiddly), but you can’t create a column for the vector ahead of time, meaning the query will be slower. This approach, while it requires more work than simply installing a package, is not terribly hard to implement on a per-model basis and is easy to customise for your use case.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[An Azure Filesystem integration for Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/">
        </link>
        <updated>2017-10-29T19:31:34Z</updated>
        <summary type="html"><![CDATA[<p><a href="/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/">My earlier post about integrating Laravel and Azure storage</a> seems to have become something of a go-to resource on this subject (I suspect this is because very few developers actually use Laravel and Azure together). Unfortunately it hasn’t really aged terribly well - changes to the namespace and to Guzzle mean that it needs some work to integrate it.</p>
<p>I’ve therefore <a href="https://github.com/matthewbdaly/laravel-azure-storage">created a package for it</a>. That way, it’s easier to keep it up to date as if someone finds and fixes an issue with it, they can submit their changes back.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using phpiredis with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/10/20/using-phpiredis-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/10/20/using-phpiredis-with-laravel/">
        </link>
        <updated>2017-10-20T21:55:26Z</updated>
        <summary type="html"><![CDATA[<p>Laravel has support out of the box for using Redis. However, by default it uses a Redis client written in PHP, which will always be a little slower than one written in C. If you’re making heavy use of Redis, it may be worth using the <a href="https://github.com/nrk/phpiredis">phpiredis</a> extension to squeeze a little more performance out of it.</p>
<p>I’m using PHP 7.0 on Ubuntu Zesty and I installed the dependencies with the following command:</p>
<pre><code class="lang-bash">$ sudo apt-get install libhiredis-dev php-redis php7.0-dev
</code></pre>
<p>Then I installed phpiredis as follows:</p>
<pre><code class="lang-bash">git clone https://github.com/nrk/phpiredis.git &amp;&amp; \
       cd phpiredis &amp;&amp; \
       phpize &amp;&amp; \
       ./configure --enable-phpiredis &amp;&amp; \
       make &amp;&amp; \
       sudo make install
</code></pre>
<p>Finally, I configured Redis to use phpiredis in the <code>redis</code> section of <code>config/database.php</code> for a Laravel app:</p>
<pre><code class="lang-php">    &#39;redis&#39; =&gt; [

        &#39;cluster&#39; =&gt; false,

        &#39;default&#39; =&gt; [
            &#39;host&#39;     =&gt; env(&#39;REDIS_HOST&#39;, &#39;localhost&#39;),
            &#39;password&#39; =&gt; env(&#39;REDIS_PASSWORD&#39;, null),
            &#39;port&#39;     =&gt; env(&#39;REDIS_PORT&#39;, 6379),
            &#39;database&#39; =&gt; 0,
            &#39;options&#39; =&gt; [
                &#39;connections&#39; =&gt; [
                    &#39;tcp&#39; =&gt; &#39;Predis\Connection\PhpiredisStreamConnection&#39;, // PHP streams
                    &#39;unix&#39; =&gt; &#39;Predis\Connection\PhpiredisSocketConnection&#39;, // ext-socket
                ],
            ]
        ],
    ],
</code></pre>
<p>Now, I’m going to be honest - in a casual comparison I couldn’t see much difference in terms of speed. I would probably only bother with setting this up on a site where high Redis performance was absolutely necessary. If you just want a quicker cache response it might make more sense to put Varnish in front of the site instead. However, in cases where Redis gets used heavily, it’s probably worth doing.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Simple fuzzy search with Laravel and PostgreSQL]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/10/03/simple-fuzzy-search-with-laravel-and-postgresql/">
        </link>
        <updated>2017-10-03T22:56:11Z</updated>
        <summary type="html"><![CDATA[<p>When implementing fuzzy search, many developers reach straight for specialised tools like Elasticsearch. However, for simple implementations, this is often overkill. PostgreSQL, my relational database of choice, can natively handle fuzzy search quite easily if you know how. Here’s how you might use this with Laravel.</p>
<p>Suppose we have the following migration to create a <code>locations</code> table, storing towns, cities and villages:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateLocations extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // Create locations table
        Schema::create(&#39;locations&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;)-&gt;unsigned();
            $table-&gt;string(&#39;name&#39;);
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Drop locations table
        Schema::drop(&#39;locations&#39;);
    }
}
</code></pre>
<p>The key to this implementation of fuzzy search is <em>trigrams</em>. A trigram is a group of three consecutive characters taken from a string. Using the <code>pg_trgm</code> module, which comes with PostgreSQL, we can break a string into as many trigrams as possible, and then return the strings with the most matching trigrams.</p>
<p>We can ensure that <code>pg_trgm</code> is set up on the database by creating a migration:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddTrgmExtension extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        DB::statement(&#39;CREATE EXTENSION IF NOT EXISTS pg_trgm&#39;);
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        DB::statement(&#39;DROP EXTENSION IF EXISTS pg_trgm&#39;);
    }
}
</code></pre>
<p>Make sure you run the migration as well. Once that is done, we can make a raw fuzzy query against the <code>name</code> field as follows:</p>
<pre><code class="lang-sql">SELECT * FROM locations WHERE &#39;burgh&#39; % name;
</code></pre>
<p>Translating that to work with the Eloquent ORM, we can perform fuzzy queries against the <code>name</code> field as follows:</p>
<pre><code class="lang-php">$location = Location::whereRaw(&quot;&#39;burgh&#39; % name&quot;)-&gt;get();
</code></pre>
<p>This query might match both <code>Aldeburgh</code> and <code>Edinburgh</code>. It’s also able to handle slight misspellings, as in this example:</p>
<pre><code class="lang-php">$location = Location::whereRaw(&quot;&#39;hendrad&#39; % name&quot;)-&gt;get();
</code></pre>
<p>This query will match <code>East Hendred</code> or <code>West Hendred</code> successfully. As you can see, we can match strings at any point in the name string, and handle slight mis-spellings without any problems.</p>
<p>In practice, rather than using <code>whereRaw()</code> every time, you’ll probably want to create a local scope that accepts the name you want to match against. You’ll also want to use query parameters to prevent SQL injection:</p>
<pre><code class="lang-php">$location = Location::whereRaw(&quot;? % name&quot;, [$name])-&gt;get();
</code></pre>
<h2 id="improving-performance-with-an-index">Improving performance with an index</h2>
<p>The performance of these queries isn’t that great out of the box. We can improve them by creating an index:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddTrgmExtension extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        DB::statement(&#39;CREATE EXTENSION IF NOT EXISTS pg_trgm&#39;);
        DB::statement(&#39;CREATE INDEX locations_name_trigram ON locations USING gist(name gist_trgm_ops);&#39;);
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        DB::statement(&#39;DROP INDEX IF EXISTS locations_name_trigram&#39;);
        DB::statement(&#39;DROP EXTENSION IF EXISTS pg_trgm&#39;);
    }
}
</code></pre>
<p>Adding an index should produce a noticeable improvement in the response time.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>PostgreSQL’s <code>pg_trgm</code> module is a fairly straightforward way of implementing fuzzy search. It’s not much more involved than a <code>LIKE</code> or <code>ILIKE</code> clause in your query, and for many use cases, it’s more than sufficient. If you don’t have a huge number of records, it’s probably a more appropriate choice than something like Elasticsearch, and has the advantage of a simpler stack. However, if you have a larger dataset, you may be better off with a dedicated search solution. As always, if you’re unsure it’s a good idea to try both and see what works best for that particular use case.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Making internal requests with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/09/02/making-internal-requests-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/09/02/making-internal-requests-with-laravel/">
        </link>
        <updated>2017-09-02T13:45:27Z</updated>
        <summary type="html"><![CDATA[<p>Recently I’ve been working on a Phonegap app that needs to work offline. The nature of relational databases can often make this tricky if you’re dealing with related objects and you’re trying to retrofit it to something that wasn’t built with this use case in mind.</p>
<p>Originally my plan was to push each request that would have been made to a queue in WebSQL, and then on reconnect, make every request individually. It quickly became apparent, however, that this approach had a few problems:</p>
<ul>
<li>If one request failed, the remaining requests had to be stopped from executing</li>
<li>It didn’t allow for storing the failed transactions in a way that made them easy to retrieve</li>
</ul>
<p>Instead, I decided to create a single <code>sync</code> endpoint for the API that would accept an object containing all the requests that would be made, and then step through each one. If it failed, it would get the failed request and all subsequent ones in the object, and store them in the database. That way, even if the data didn’t sync correctly, it wasn’t lost, and if necessary it could be resolved manually.</p>
<p>Since the necessary API endpoints already existed, and were thoroughly tested, it was not a good idea to start duplicating that functionality. Instead, I implemented the functionality to carry out internal requests, and I thought I’d share how you can do this.</p>
<p>For any service you may build for your Laravel applications, it’s a good idea to create an interface for it first:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Contracts;

interface MakesInternalRequests
{
    /**
     * Make an internal request
     *
     * @param string $action   The HTTP verb to use.
     * @param string $resource The API resource to look up.
     * @param array  $data     The request body.
     * @return \Illuminate\Http\Response
     */
    public function request(string $action, string $resource, array $data = []);
}
</code></pre>
<p>That way you can resolve the service using dependency injection, making it trivial to replace it with a mock when testing.</p>
<p>Now, actually making an internal request is pretty easy. You get the app instance (you can do so by resolving it using dependency injection as I do below, or call the <code>app()</code> helper). Then you put together the request you want to make and pass it as an argument to the app’s <code>handle()</code> method:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Services;

use Illuminate\Http\Request;
use App\Contracts\MakesInternalRequests;
use Illuminate\Foundation\Application;
use App\Exceptions\FailedInternalRequestException;

/**
 * Internal request service
 */
class InternalRequest implements MakesInternalRequests
{
    /**
     * The app instance
     *
     * @var $app
     */
    protected $app;

    /**
     * Constructor
     *
     * @param Application $app        The app instance.
     * @return void
     */
    public function __construct(Application $app)
    {
        $this-&gt;app = $app;
    }

    /**
     * Make an internal request
     *
     * @param string $action   The HTTP verb to use.
     * @param string $resource The API resource to look up.
     * @param array  $data     The request body.
     * @throws FailedInternalRequestException Request could not be synced.
     * @return \Illuminate\Http\Response
     */
    public function request(string $action, string $resource, array $data = [])
    {
        // Create request
        $request = Request::create(&#39;/api/&#39; . $resource, $action, $data, [], [], [
            &#39;HTTP_Accept&#39;             =&gt; &#39;application/json&#39;,
        ]);

        // Get response
        $response = $this-&gt;app-&gt;handle($request);
        if ($response-&gt;getStatusCode() &gt;= 400) {
            throw new FailedInternalRequestException($request, $response);
        }

        // Dispatch the request
        return $response;
    }
}
</code></pre>
<p>Also note that I’ve created a custom exception, called <code>FailedInternalRequestException</code>. This is fired if the status code returned from the internal requests is greater than or equal to 400 (thus denoting an error):</p>
<pre><code class="lang-php">&lt;?php

namespace App\Exceptions;

use Illuminate\Http\Request;
use Illuminate\Http\Response;

/**
 * Exception for when a bulk sync job fails
 */
class FailedInternalRequestException extends \Exception
{
    /**
     * Request instance
     *
     * @var $request
     */
    protected $request;

    /**
     * Response instance
     *
     * @var $response
     */
    protected $response;

    /**
     * Constructor
     *
     * @param Request  $request  The request object.
     * @param Response $response The response object.
     * @return void
     */
    public function __construct(Request $request, Response $response)
    {
        parent::__construct();
        $this-&gt;request = $request;
        $this-&gt;response = $response;
    }

    /**
     * Get request object
     *
     * @return Request
     */
    public function getRequest()
    {
        return $this-&gt;request;
    }

    /**
     * Get response object
     *
     * @return Response
     */
    public function getResponse()
    {
        return $this-&gt;response;
    }
}
</code></pre>
<p>You can catch this exception in an appropriate place and handle it as you wish. Now, if you import the internal request class as <code>$dispatcher</code>, you can just call <code>$dispatcher-&gt;request($action, $resource, $data)</code>, where <code>$action</code> is the HTTP verb, <code>$resource</code> is the API resource to send to, and <code>$data</code> is the data to send.</p>
<p>It’s actually quite rare to have to do this. In this case, because this was a REST API and every request made to it was changing the state of the application (there were no GET requests, only POST, PUT, PATCH and DELETE), it made sense to just break down the request body and do internal requests against the existing API, since otherwise I’d have to duplicate the existing functionality. I would not recommend this approach for something like fetching data to render a page on the server side, as there are more efficient ways of accomplishing it. In all honesty I can’t think of any other scenario where this would genuinely be the best option. However, it worked well for my use case and allowed me to implement this functionality quickly and simply.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Profiling your Laravel application with Clockwork]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/08/14/profiling-your-laravel-application-with-clockwork/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/08/14/profiling-your-laravel-application-with-clockwork/">
        </link>
        <updated>2017-08-14T11:40:00Z</updated>
        <summary type="html"><![CDATA[<p>If you’re building any non-trivial application, it’s always a good idea to profile it to find performance problems. <a href="https://github.com/barryvdh/laravel-debugbar">Laravel Debugbar</a> is the usual solution for profiling Laravel web applications, but it isn’t really much use for REST API’s or single-page web apps that consume them.</p>
<p>Recently I was introduced to <a href="https://github.com/itsgoingd/clockwork">Clockwork</a>, which is a server-side extension for profiling PHP applications. It’s made it a whole lot easier to track down issues like excessive numbers of queries when building an API, and as a result I’ve been able to dramatically improve the performance of an API I’ve been working on. Here I’ll show you how you can use it on a project.</p>
<h2 id="installing-clockwork">Installing Clockwork</h2>
<p>Clockwork is available via Composer:</p>
<pre><code class="lang-bash">$ composer require itsgoingd/clockwork
</code></pre>
<p>You also need to register the service provider in <code>config/app.php</code>:</p>
<pre><code class="lang-php">   Clockwork\Support\Laravel\ClockworkServiceProvider::class,
</code></pre>
<p>And register the middleware globally in <code>app/Http/Kernel.php</code>:</p>
<pre><code class="lang-php">protected $middleware = [
      \Clockwork\Support\Laravel\ClockworkMiddleware::class,
]
</code></pre>
<p>Note that it only works when <code>APP_DEBUG</code> is set to true in your <code>.env</code> file. This means that you can keep it in your application without worrying about exposing too much data in production, as long as debug mode is not active on your production server (which it shouldn’t be anyway).</p>
<p>You will also need to install the <a href="https://chrome.google.com/webstore/detail/clockwork/dmggabnehkmmfmdffgajcflpdjlnoemp?hl=en">Chrome extension</a> in order to actually work with the returned data. Clockwork works by adding its own route to your Laravel application, and this extension makes sure that it makes the appropriate request on loading a page, and then displays the data in the dev tools.</p>
<p>Once it’s all installed and your application is running, open the dev tools and you should see the new <strong>Clockwork</strong> tab in there. On the left of this tab is a list of requests - if you make a request, you’ll see it added to the list. When you click on each request, you’ll see the following tabs, where applicable:</p>
<h2 id="request">Request</h2>
<p><img src="/static/images/clockwork1.png" alt="Request tab"></p>
<p>This is similar to Chrome’s network tab in that it shows all of the headers for a given request. It’s not anything you can’t get using Chrome’s existing dev tools, but because it doesn’t show any static content it’s arguably a bit easier to navigate.</p>
<h2 id="timeline">Timeline</h2>
<p><img src="/static/images/clockwork2.png" alt="Timeline tab"></p>
<p>This shows how long the response takes to respond, which can be helpful in identifying slower requests.</p>
<p>In addition, you can create your own events using the <code>clock()</code> helper, which will appear in the timeline, as in this example:</p>
<pre><code class="lang-php">clock()-&gt;startEvent(&#39;email_sent&#39;, &#39;Email sent.&#39;);
clock()-&gt;endEvent(&#39;email_sent&#39;);
</code></pre>
<h2 id="log">Log</h2>
<p><img src="/static/images/clockwork8.png" alt="Log tab"></p>
<p>The log tab is only displayed if you use the <code>clock()</code> helper to log data. You can log text or JSON objects as appropriate:</p>
<pre><code class="lang-php">clock(&#39;Message text.&#39;); // &#39;Message text.&#39; appears in Clockwork log tab
clock([&#39;hello&#39; =&gt; &#39;world&#39;]); // logs json representation of the array
</code></pre>
<p>This is arguably more convenient than using the <code>Log</code> facade to write to the application log, since it’s kept in the browser and you can easily see what request caused what message to be logged.</p>
<h2 id="database">Database</h2>
<p><img src="/static/images/clockwork3.png" alt="Database tab"></p>
<p>The database tab displays details of the queries made by a request. This is useful for identifying things such as:</p>
<ul>
<li>Repeated queries that should be cached</li>
<li>The n+1 problem (which can be resolved by use of eager loading)</li>
<li>Slow queries that need to be optimised</li>
</ul>
<p>Note that if a particular endpoint does not trigger a query, this tab will not be visible.</p>
<h2 id="cookies">Cookies</h2>
<p><img src="/static/images/clockwork4.png" alt="Cookies tab"></p>
<p>For a REST API, you shouldn’t really have much use for cookies, but if you do, this tab lets you view the cookies set on the request.</p>
<h2 id="session">Session</h2>
<p><img src="/static/images/clockwork5.png" alt="Session tab"></p>
<p>As with cookies, the session isn’t normally something you’d use for an API, but this tab lets you view it.</p>
<h2 id="views">Views</h2>
<p><img src="/static/images/clockwork6.png" alt="Views tab"></p>
<p>This tab shows the views used on the page, and all of the data passed to them.</p>
<h2 id="routes">Routes</h2>
<p><img src="/static/images/clockwork7.png" alt="Routes tab"></p>
<p>This tab shows all of the routes defined within your application.</p>
<p>Clockwork isn’t limited to Laravel - you can also use it with Lumen, Slim 2, and CodeIgniter 2.1, and it’s possible to write your own integration for other frameworks. It’s still fundamentally browser-based, so it’s difficult to use it if your API doesn’t have at least some kind of web front end (whether that’s a single page web app or Phonegap app that consumes the API, or that the API is itself browseable and returns HTML in a web browser), but I’ve found it to be superior to Laravel Debugbar for most of what I do.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Decorating Laravel repositories]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/03/01/decorating-laravel-repositories/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/03/01/decorating-laravel-repositories/">
        </link>
        <updated>2017-03-01T23:16:57Z</updated>
        <summary type="html"><![CDATA[<p><a href="/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/">As mentioned previously</a>, when building any nontrivial Laravel application, it’s prudent to decouple our controllers from the Eloquent ORM (or any other ORM or data source we may be using) by creating an interface, and then writing a repository that implements that interface. We can then resolve the interface to our repository, and use the repository to interact with our data source. Should we need to switch to a different implementation, we then need only create the new repository and amend how Laravel resolves that interface.</p>
<p>The same principle applies when it comes to caching. Database queries are typically a major bottleneck in a web application, and so it’s prudent to implement some form of caching for your queries. However, it’s a bad idea to do so in your controllers, because just as with Eloquent models, you’re tying yourself to one particular implementation and won’t be able to switch without rewriting a good chunk of your controllers, as well as possibly having to maintain large amounts of duplicate code for when a query is made in several places.</p>
<p>Alternatively, you could implement caching within the methods of your repository, which might make sense for smaller projects. However, it means that your repository is now dependent on both the ORM and cache you chose. If you decide you want to change your ORM but retain the same caching system, or vice versa, you’re stuck with writing a new repository to handle both, duplicating work you’ve already done.</p>
<p>Fortunately, there’s a more elegant solution. Using the <a href="http://designpatternsphp.readthedocs.io/en/latest/Structural/Decorator/README.html">decorator pattern</a>, we can create a second repository that implements the same interface and “wraps” the original repository. Each of its methods will call its counterpart in the original, and if appropriate cache the response. That way, our caching is implemented separately from our database interactions, and we can easily create a repository for a new data source without affecting the caching in the slightest.</p>
<p>Say we have the following interface for our <code>User</code> model:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories\Interfaces;

interface UserRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>And the following repository implements that interface:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories;

use App\User;
use App\Repositories\Interfaces\UserRepositoryInterface;
use Hash;

class EloquentUserRepository implements UserRepositoryInterface {

    private $model;

    public function __construct(User $model)
    {
        $this-&gt;model = $model;
    }

    public function all()
    {
        return $this-&gt;model-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;model-&gt;findOrFail($id);
    }

    public function create($input)
    {
        $user = new $this-&gt;model;
        $user-&gt;email = $input[&#39;email&#39;];
        $user-&gt;name = $input[&#39;name&#39;];
        $user-&gt;password = Hash::make($input[&#39;password&#39;]);
        $user-&gt;save();
        return $user;
    }
}
</code></pre>
<p>We might implement the following repository class to handle caching:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Repositories\Decorators;

use App\Repositories\Interfaces\UserRepositoryInterface;
use Illuminate\Contracts\Cache\Repository as Cache;

class CachingUserRepository implements UserRepositoryInterface {

    protected $repository;

    protected $cache;

    public function __construct(UserRepositoryInterface $repository, Cache $cache)
    {
        $this-&gt;repository = $repository;
        $this-&gt;cache = $cache;
    }

    public function all()
    {
        return $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;remember(&#39;all&#39;, 60, function () {
            return $this-&gt;repository-&gt;all();
        });
    }

    public function findOrFail($id)
    {
        return $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;remember($id, 60, function () use ($id) {
            return $this-&gt;repository-&gt;findOrFail($id);
        });
    }

    public function create($input)
    {
        $this-&gt;cache-&gt;tags(&#39;users&#39;)-&gt;flush();
        return $this-&gt;repository-&gt;create($input);
    }
}
</code></pre>
<p>Note how each method doesn’t actually do any querying. Instead, the constructor accepts an implementation of the same interface and the cache, and we defer all interactions with the database to that implementation. Each call that queries the database is wrapped in a callback so that it’s stored in Laravel’s cache when it’s returned, without touching the original implementation. When a user is created, the users tag is flushed from the cache so that stale results don’t get served.</p>
<p>To actually use this implementation, we need to update our service provider so that it resolves the interface to an implementation of our decorator:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;singleton(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;, function () {
            $baseRepo = new \App\Repositories\EloquentUserRepository(new \App\User);
            $cachingRepo = new \App\Repositories\Decorators\CachingUserRepository($baseRepo, $this-&gt;app[&#39;cache.store&#39;]);
            return $cachingRepo;
        });
    }
}
</code></pre>
<p>We instantiate the base repository, passing it the appropriate model. Then we instantiate the decorator, passing it the base repository and the cache, and return it. Now our controllers will start using the new decorator.</p>
<h2 id="testing-the-decorator">Testing the decorator</h2>
<p>Now that we have a working decorator, how do we test it? Just as with the decorator itself, we want our tests to be completely decoupled from any particular implementation of the dependencies. If in future we’re asked to migrate the database to MongoDB, say, we’ll have plenty of work writing our new database repositories, so we don’t want to have to rewrite the tests for our decorator as well. Fortunately, using Mockery we can just mock the interface for the repository, and pass that mock into the constructor of the decorator in our test. That way we can have the mock return a known response and not involve either the database repository or the underlying models in any way.</p>
<p>We will also want to mock the cache itself, as this is a unit test and so as far as possible it should not be testing anything outside of the repository class. Here’s an example of how we might test the above decorator.</p>
<pre><code class="lang-php">&lt;?php

namespace Tests\Repositories\Decorators;

use Tests\TestCase;
use App\Repositories\Decorators\CachingUserRepository;
use Mockery as m;

class UserTest extends TestCase
{
    /**
     * Test fetching all items
     *
     * @return void
     */
    public function testFetchingAll()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;all&#39;)-&gt;andReturn([]);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;users&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;remember&#39;)-&gt;andReturn([]);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $items = $repository-&gt;all();
        $this-&gt;assertCount(0, $items);
    }

    /**
     * Test fetching a single item
     *
     * @return void
     */
    public function testFindOrFail()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;findOrFail&#39;)-&gt;with(1)-&gt;andReturn(null);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;users&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;remember&#39;)-&gt;andReturn(null);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $item = $repository-&gt;findOrFail(1);
        $this-&gt;assertNull($item);
    }

    /**
     * Test creating a single item
     *
     * @return void
     */
    public function testCreate()
    {
        // Create mock of decorated repository
        $repo = m::mock(&#39;App\Repositories\Interfaces\UserRepositoryInterface&#39;);
        $repo-&gt;shouldReceive(&#39;create&#39;)-&gt;with([&#39;email&#39; =&gt; &#39;bob@example.com&#39;])-&gt;andReturn(true);

        // Create mock of cache
        $cache = m::mock(&#39;Illuminate\Contracts\Cache\Repository&#39;);
        $cache-&gt;shouldReceive(&#39;tags&#39;)-&gt;with(&#39;usersUser&#39;)-&gt;andReturn($cache);
        $cache-&gt;shouldReceive(&#39;flush&#39;)-&gt;andReturn(true);

        // Instantiate the repository
        $repository = new CachingUserRepository($repo, $cache);

        // Get all
        $item = $repository-&gt;create([&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);
        $this-&gt;assertTrue($item);
    }

    public function tearDown()
    {
        m::close();
        parent::tearDown();
    }
}
</code></pre>
<p>As you can see, all we care about is that the underlying repository interface receives the correct method calls and arguments, nothing more. That way our test is fast and repository-agnositc.</p>
<h2 id="other-applications">Other applications</h2>
<p>Here I’ve used this technique to cache the queries, but that’s not the only use case for decorating a repository. For instance, you could decorate a repository to fire events when certain methods are called, and write different decorators when reusing these repositories for different applications. You could create one to log interactions with the repository, or you could use an external library to cache your queries, all without touching your existing repository. Should we need to switch back to our base repository, it’s just a matter of amending the service provider accordingly as both the decorator and the repository implement the same interface.</p>
<p>Creating decorators does mean you have to implement all of the interface’s methods again, but if you have a base repository that your other ones inherit from, you can easily create a base decorator in a similar fashion that wraps methods common to all the repositories, and then just implement the additional methods for each decorator as required. Also, each method is likely to be fairly limited in scope so it’s not generally too onerous.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[My first Laravel package]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/02/19/my-first-laravel-package/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/02/19/my-first-laravel-package/">
        </link>
        <updated>2017-02-19T15:50:11Z</updated>
        <summary type="html"><![CDATA[<p>For some time now I’ve had a Laravel middleware I use extensively to add ETags to HTTP requests. I often use it for work projects, but obviously copying and pasting it all the time was a pain. I always meant to create a package for it, but I didn’t want to do so until such time as I had some proper tests for it. Now I’ve finally figured out how to test middleware in isolation and I’ve got around to adding tests and creating a proper package for it.</p>
<p>It’s available on <a href="https://github.com/matthewbdaly/laravel-etag-middleware">Github</a> and <a href="https://packagist.org/packages/matthewbdaly/laravel-etag-middleware">Packagist</a> if you want to use it.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Integrating Behat with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2017/02/18/integrating-behat-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2017/02/18/integrating-behat-with-laravel/">
        </link>
        <updated>2017-02-18T21:25:57Z</updated>
        <summary type="html"><![CDATA[<p>The Gherkin format used by tools like Cucumber is a really great way of specifying how your application will work. It’s easy for even non-technical stakeholders to understand, it makes it natural to break your tests into easily reusable steps, and it encourages you to think about the application from an end-user’s perspective. It’s also one of the easiest ways to get started writing automated tests when you first start out - it’s much more intuitive to a junior developer than lower-level unit tests, and is easier to add to a legacy project that may not have been built with testability in mind - if you can drive a browser, you can test it.</p>
<p><a href="http://behat.org/en/latest/">Behat</a> is a PHP equivalent. Combined with <a href="http://mink.behat.org/en/latest/">Mink</a>, it allows for easy automated acceptance tests of a PHP application. However, out of the box it doesn’t integrate well with Laravel. There is <a href="https://github.com/laracasts/Behat-Laravel-Extension">Jeffrey Way’s Behat Laravel extension</a>, but it doesn’t seem to be actively maintained and seems to be overkill for this purpose. I wanted something that I could use to run integration tests using PHPUnit’s assertions and Laravel’s testing utilities, and crucially, I wanted to do so as quickly as possible. That meant running a web server and using an automated web browser wasn’t an option. Also, I often work on REST API’s, and browser testing isn’t appropriate for those - in API tests I’m more interested in setting up the fixtures, making a single request, and verifying that it does what it’s meant to do, as quickly as possible.</p>
<p>As it turns out, integrating Behat and Laravel isn’t that hard. When using Behat, your <code>FeatureContext.php</code> file must implement the <code>Behat\Behat\Context\Context</code> interface, but as this interface does not implement any methods, you can extend any existing class and declare that it implements that interface. That means we can just extend the existing <code>Tests\TestCase</code> class in Laravel 5.4 and gain access to all the same testing utilities we have in our regular Laravel tests.</p>
<p>Then, in the constructor we can set environment variables using <code>putenv()</code> so that we can set it up to use an in-memory SQLite database for faster tests. We also use the <code>@BeforeScenario</code> hook to migrate the database before each scenario, and the <code>@AfterScenario</code> hook to roll it back afterwards.</p>
<p>Here’s the finished example:</p>
<pre><code class="lang-php">&lt;?php

use Behat\Behat\Context\Context;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;
use Tests\TestCase;
use Behat\Behat\Tester\Exception\PendingException;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use App\User;
use Behat\Behat\Hook\Scope\BeforeScenarioScope;
use Behat\Behat\Hook\Scope\AfterScenarioScope;
use Illuminate\Contracts\Console\Kernel;

/**
 * Defines application features from the specific context.
 */
class FeatureContext extends TestCase implements Context
{
    use DatabaseMigrations;

    protected $content;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context instance.
     * You can also pass arbitrary arguments to the
     * context constructor through behat.yml.
     */
    public function __construct()
    {
        putenv(&#39;DB_CONNECTION=sqlite&#39;);
        putenv(&#39;DB_DATABASE=:memory:&#39;);
        parent::setUp();
    }

    /** @BeforeScenario */
    public function before(BeforeScenarioScope $scope)
    {
        $this-&gt;artisan(&#39;migrate&#39;);

        $this-&gt;app[Kernel::class]-&gt;setArtisan(null);
    }

    /** @AfterScenario */
    public function after(AfterScenarioScope $scope)
    {
        $this-&gt;artisan(&#39;migrate:rollback&#39;);
    }

    /**
     * @Given I visit the path :path
     */
    public function iVisitThePath($path)
    {
        $response = $this-&gt;get(&#39;/&#39;);
        $this-&gt;assertEquals(200, $response-&gt;getStatusCode());
        $this-&gt;content = $response-&gt;getContent();
    }

    /**
     * @Then I should see the text :text
     */
    public function iShouldSeeTheText($text)
    {
        $this-&gt;assertContains($text, $this-&gt;content);
    }

    /**
     * @Given a user called :user exists
     */
    public function aUserCalledExists($user)
    {
        $user = factory(App\User::class)-&gt;create([
            &#39;name&#39; =&gt; $user,
        ]);
    }

    /**
     * @Given I am logged in as :user
     */
    public function iAmLoggedInAs($user)
    {
        $user = User::where(&#39;name&#39;, $user)-&gt;first();
        $this-&gt;be($user);
    }

}
</code></pre>
<p>Note that I’ve added a few basic example methods for our tests. As you can see, we can call the same methods we normally use in Laravel tests to make assertions and HTTP requests. If you’re using Dusk, you can also call that in the same way you usually would.</p>
<p>We might then write the following feature file to demonstrate our application at work:</p>
<pre><code class="lang-gherkin">Feature: Login

    Background:
        Given a user called &quot;Alan&quot; exists
        And a user called &quot;Bob&quot; exists
        And a user called &quot;Clare&quot; exists
        And a user called &quot;Derek&quot; exists
        And a user called &quot;Eric&quot; exists

    Scenario: Log in as Alan
        Given I am logged in as &quot;Alan&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Bob
        Given I am logged in as &quot;Bob&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Clare
        Given I am logged in as &quot;Clare&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Derek
        Given I am logged in as &quot;Derek&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;

    Scenario: Log in as Eric
        Given I am logged in as &quot;Eric&quot;
        And I visit the path &quot;/&quot;
        Then I should see the text &quot;Laravel&quot;
</code></pre>
<p>We can then run these tests with <code>vendor/bin/behat</code>:</p>
<pre><code class="lang-bash">$ vendor/bin/behat 
Feature: Login

  Background:                         # features/auth.feature:3
    Given a user called &quot;Alan&quot; exists # FeatureContext::aUserCalledExists()
    And a user called &quot;Bob&quot; exists    # FeatureContext::aUserCalledExists()
    And a user called &quot;Clare&quot; exists  # FeatureContext::aUserCalledExists()
    And a user called &quot;Derek&quot; exists  # FeatureContext::aUserCalledExists()
    And a user called &quot;Eric&quot; exists   # FeatureContext::aUserCalledExists()

  Scenario: Log in as Alan               # features/auth.feature:10
    Given I am logged in as &quot;Alan&quot;       # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Bob                # features/auth.feature:15
    Given I am logged in as &quot;Bob&quot;        # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Clare              # features/auth.feature:20
    Given I am logged in as &quot;Clare&quot;      # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Derek              # features/auth.feature:25
    Given I am logged in as &quot;Derek&quot;      # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

  Scenario: Log in as Eric               # features/auth.feature:30
    Given I am logged in as &quot;Eric&quot;       # FeatureContext::iAmLoggedInAs()
    And I visit the path &quot;/&quot;             # FeatureContext::iVisitThePath()
    Then I should see the text &quot;Laravel&quot; # FeatureContext::iShouldSeeTheText()

5 scenarios (5 passed)
40 steps (40 passed)
0m0.50s (19.87Mb)
</code></pre>
<p>Higher level tests can get very tedious if you’re not careful - you wind up setting up the same fixtures and making the same requests many times over. By using Behat in this way, not only are you writing your tests in a way that is easy to understand, but you’re also breaking it down into logical, repeatable steps, and by passing arguments in each step you limit the amount of repetition. It’s also fast if you aren’t running browser-based tests, making it particularly well-suited to API testing.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Testing Laravel Middleware]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/11/29/testing-laravel-middleware/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/11/29/testing-laravel-middleware/">
        </link>
        <updated>2016-11-29T23:00:38Z</updated>
        <summary type="html"><![CDATA[<p>It’s widely accepted that high-level integration tests alone do not make for a good test suite. Ideally each individual component of your application should have unit tests, which test that component in isolation. These unit tests are usually much quicker to run, making it easier to practice test-driven development. However, it can sometimes be hard to grasp how to test that one component on its own.</p>
<p>The other day I had an issue with several middleware classes for a Laravel application and I wanted to verify that they were working as expected. Sounds like a job for dedicated unit tests, but I hadn’t tested custom middleware in isolation before, and figuring out how to do so took a while.</p>
<p>Laravel middleware accepts an instance of <code>Illuminate\Http\Request</code>, itself based on the Symfony request object, as well as a closure for the action to take next. Depending on what the middleware does, it may return a redirect or simply amend the existing request or response. So in theory you can instantiate a request object, pass it to the middleware, and check the response. For middleware that does something simple, such as redirecting users based on certain conditions, this is fairly straightforward.</p>
<p>In this example we have a fairly useless piece of middleware that checks to see what the route is for a request and redirects it if it matches a certain pattern:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;

class RedirectFromAdminMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request-&gt;is(&#39;admin*&#39;)) {
            return redirect(&#39;/&#39;);
        }
        return $next($request);
    }
}
</code></pre>
<p>While this example is of limited use, it wouldn’t take much work to develop it to redirect conditionally based on an account type, and it’s simple enough to demonstrate the principles involved. In these tests, we create instances of <code>Illuminate\Http\Request</code> and pass them to the middleware’s <code>handle()</code> method, along with an empty closure representing the response. If the middleware does not amend the request, we get the empty response from the closure. If it does amend the request, we get a redirect response.</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

class RedirectFromAdminMiddlewareTest extends TestCase
{
    public function testRedirectMiddlewareCalledOnAdmin()
    {
        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\RedirectFromAdminMiddleware();
        $response = $middleware-&gt;handle($request, function () {});
        $this-&gt;assertEquals($response-&gt;getStatusCode(), 302);
    }

    public function testRedirectMiddlewareNotCalledOnNonAdmin()
    {
        // Create request
        $request = Request::create(&#39;http://example.com/pages&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\RedirectFromAdminMiddleware();
        $response = $middleware-&gt;handle($request, function () {});
        $this-&gt;assertEquals($response, null);
    }
}
</code></pre>
<p>For middleware that fetches the response and acts on it, things are a little more complex. For instance, this is the Etag middleware I use on many projects:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Middleware;

use Closure;

class ETagMiddleware {
    /**
     * Implement Etag support
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        // Get response
        $response = $next($request);
        // If this was a GET request...
        if ($request-&gt;isMethod(&#39;get&#39;)) {
            // Generate Etag
            $etag = md5($response-&gt;getContent());
            $requestEtag = str_replace(&#39;&quot;&#39;, &#39;&#39;, $request-&gt;getETags());
            // Check to see if Etag has changed
            if($requestEtag &amp;&amp; $requestEtag[0] == $etag) {
                $response-&gt;setNotModified();
            }
            // Set Etag
            $response-&gt;setEtag($etag);
        }
        // Send response
        return $response;
    }
}
</code></pre>
<p>This acts on the response object, so we need to pass that through as well. Fortunately, Mockery allows us to create a mock of our response object and set it up to handle only those methods we anticipate being called:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

class ETagMiddlewareTest extends TestCase
{
    /**
     * Test new request not cached
     *
     * @return void
     */
    public function testModified()
    {
        // Create mock response
        $response = Mockery::mock(&#39;Illuminate\Http\Response&#39;)-&gt;shouldReceive(&#39;getContent&#39;)-&gt;once()-&gt;andReturn(&#39;blah&#39;)-&gt;getMock();
        $response-&gt;shouldReceive(&#39;setEtag&#39;)-&gt;with(md5(&#39;blah&#39;));

        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\ETagMiddleware();
        $middlewareResponse = $middleware-&gt;handle($request, function () use ($response) { 
            return $response;
        });
    }

    /**
     * Test repeated request not modified
     *
     * @return void
     */
    public function testNotModified()
    {
        // Create mock response
        $response = Mockery::mock(&#39;Illuminate\Http\Response&#39;)-&gt;shouldReceive(&#39;getContent&#39;)-&gt;once()-&gt;andReturn(&#39;blah&#39;)-&gt;getMock();
        $response-&gt;shouldReceive(&#39;setEtag&#39;)-&gt;with(md5(&#39;blah&#39;));
        $response-&gt;shouldReceive(&#39;setNotModified&#39;);

        // Create request
        $request = Request::create(&#39;http://example.com/admin&#39;, &#39;GET&#39;, [], [], [], [
            &#39;ETag&#39; =&gt; md5(&#39;blah&#39;)
        ]);

        // Pass it to the middleware
        $middleware = new App\Http\Middleware\ETagMiddleware();
        $middlewareResponse = $middleware-&gt;handle($request, function () use ($response) { 
            return $response;
        });
    }

    public function teardown()
    {
        Mockery::close();
    }
}
</code></pre>
<p>In the first example we mock out the <code>getContent()</code> and <code>setEtag()</code> methods of our response to make sure they get called, and then pass the request to the middleware, along with a closure that returns the response. In the second example, we also mock out <code>setNotModified()</code> to ensure that the correct status code of 304 is set, and add an ETag to our request. In this way we can easily test our middleware in isolation, rather than having to resort to building up our entire application just to test one small method.</p>
<p>Middleware is a convenient place to put functionality that’s needed for many routes, but you shouldn’t neglect testing it, and ideally you shouldn’t have to resort to writing a slow integration test to test it works as expected. By mocking out your dependencies, it’s generally not too hard to test it in isolation, resulting in faster and more robust test suites.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Phonegap App with Laravel and Angular - Part 4]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/11/13/building-a-phonegap-app-with-laravel-and-angular-part-4/">
        </link>
        <updated>2016-11-13T16:15:00Z</updated>
        <summary type="html"><![CDATA[<p>In this instalment we’ll return to the back end. What we’ve done so far is typical of the kind of proof of concept we might do for a client early on, before going back and implementing the full set of features later on. Now we’ll go back and start to improve on that rather quick-and-dirty API by making sure we follow a few best practices.</p>
<p>For those of you who want to follow the Laravel Phonegap tutorials, I’ve created a dedicated category <a href="/blog/categories/laravel-phonegap-tutorial/">here</a> for those tutorials. This category include RSS and Atom feeds, so if you only want to read those posts, you can do so. I’ve also done the same for the <a href="/blog/categories/django-blog-tutorial/">Django tutorials</a>.</p>
<h2 id="the-repository-pattern">The Repository pattern</h2>
<p>One of the issues we currently have with our API is that we’re passing our Eloquent models into our controllers. This may not seem like a huge issue, but it means that our controllers are tightly coupled to the Eloquent ORM, so if we wanted to switch to another ORM, or to a completely different database such as MongoDB, we’d have to amend our controllers. That’s not good.</p>
<p>However, using the <a href="http://designpatternsphp.readthedocs.io/en/latest/More/Repository/README.html">Repository pattern</a> we can first of all define an interface for our repository, and then create a repository class that implements that interface. That way we can interact with the repository class in our controllers, rather than using Eloquent models directly. Then, if we want to switch databases, we merely amend the repository class to change the implementation of those methods, without having to touch our controllers. Also, it makes it much easier to test our controllers in isolation, because we can easily mock our repository class using Mockery and hard-code the response, so our tests won’t touch the database and will therefore run more quickly. We won’t touch on that this time, but it’s a very significant advantage.</p>
<p>If you haven’t used interfaces before in PHP, they aren’t that hard. They merely specify what methods an object implementing that method must have and what arguments they must accept, but do not specify the details of the implementation. This makes it easy to determine if a class implements an interface correctly, because it will throw an exception if it doesn’t.</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories\Interfaces;

interface PetRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>That’s all there is to it. We define it using the <code>interface</code> keyword and we specify the methods it must implement. Save this file at <code>app/Repositories/Interfaces/PetRepositoryInterface.php</code>.</p>
<p>Next, we implement the repository class:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories;

use AnimalFriend\Pet;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface;

class EloquentPetRepository implements PetRepositoryInterface {

    private $pet;

    public function __construct(Pet $pet)
    {
        $this-&gt;pet = $pet;
    }

    public function all()
    {
        return $this-&gt;pet-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;pet-&gt;findOrFail($id);
    }

    public function create($input)
    {
        return $this-&gt;pet-&gt;create($input);
    }
}
</code></pre>
<p>Save this to <code>app/Repositories/EloquentPetRepository.php</code>. Note how the methods closely mirror the underlying Eloquent methods, but they don’t need to - you could change the underlying implementation of each method, but the repository would still work in exactly the same way.</p>
<p>To make this work, we need to make a few changes elsewhere. In <code>composer.json</code>, we need to add the new <code>Repositories</code> folder to our classmap:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;classmap&quot;: [
            &quot;database&quot;,
            &quot;app/Repositories&quot;
        ],
        &quot;psr-4&quot;: {
            &quot;AnimalFriend\\&quot;: &quot;app/&quot;
        }
    },
</code></pre>
<p>And in <code>app/Providers/AppServiceProvider.php</code>, we need to bind our new files:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\PetRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentPetRepository&#39;
        );
    }
}
</code></pre>
<p>With that done, we can now update <code>app/Http/Controllers/PetController.php</code> to use the repository:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface as Pet;

class PetController extends Controller
{
    private $pet;

    public function __construct(Pet $pet) {
        $this-&gt;pet = $pet;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;all();

        // Send response
        return response()-&gt;json($pets, 200);
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($pet, 200);
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>Our repository is now injected automatically into the controller. To make this work we need to run the following command:</p>
<pre><code class="lang-bash">$ composer dump-autoload
</code></pre>
<p>Running our tests should confirm that everything is still working:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.
............                                                      12 / 12 (100%)

Time: 897 ms, Memory: 18.00MB

OK (12 tests, 46 assertions)
</code></pre>
<p>Let’s do the same for the User model. First we implement our interface in <code>app/Repositories/Interfaces/UserRepositoryInterface.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories\Interfaces;

interface UserRepositoryInterface {
    public function all();

    public function findOrFail($id);

    public function create($input);
}
</code></pre>
<p>Next we create our repository at <code>app/Repositories/EloquentUserRepository.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Repositories;

use AnimalFriend\User;
use AnimalFriend\Repositories\Interfaces\UserRepositoryInterface;
use JWTAuth;
use Hash;

class EloquentUserRepository implements UserRepositoryInterface {

    private $user;

    public function __construct(User $user)
    {
        $this-&gt;user = $user;
    }

    public function all()
    {
        return $this-&gt;user-&gt;all();
    }

    public function findOrFail($id)
    {
        return $this-&gt;user-&gt;findOrFail($id);
    }

    public function create($input)
    {
        $user = new $this-&gt;user;
        $user-&gt;email = $input[&#39;email&#39;];
        $user-&gt;name = $input[&#39;name&#39;];
        $user-&gt;password = Hash::make($input[&#39;password&#39;]);
        $user-&gt;save();

        // Create token
        return JWTAuth::fromUser($user);
    }
}
</code></pre>
<p>Note how we’ve moved much of the logic for creating a user into the <code>create()</code> method, and we return the token, not the user model. This makes sense as right now we only ever want to get a token back when we create a user. Later that may change, but there’s nothing stopping us adding a new method to implement that behaviour alongside this.</p>
<p>Then we update <code>app/Http/Controllers/UserController.php</code> to use our repository:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\UserRepositoryInterface as User;
use JWTAuth;
use Hash;

class UserController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39;,
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;password&#39; =&gt; &#39;required|confirmed&#39;
        ]);

        // Create token
        $token = $this-&gt;user-&gt;create($request-&gt;only(
            &#39;email&#39;,
            &#39;name&#39;,
            &#39;password&#39;
        ));

        // Send response
        return response()-&gt;json([&#39;token&#39; =&gt; $token], 201);
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>And add a new binding in <code>app/Providers/AppServiceProvider.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\PetRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentPetRepository&#39;
        );
        $this-&gt;app-&gt;bind(
            &#39;AnimalFriend\Repositories\Interfaces\UserRepositoryInterface&#39;,
            &#39;AnimalFriend\Repositories\EloquentUserRepository&#39;
        );
    }
}
</code></pre>
<p>Note that we bind the two sets separately - this allows Laravel to figure out which one maps to which.</p>
<p>Let’s run our tests to make sure nothing is broken:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 956 ms, Memory: 18.00MB

OK (12 tests, 46 assertions)
</code></pre>
<p>Now that we’ve got our repositories in place, we’re no longer tightly coupled to Eloquent, and have a more flexible implementation which is easier to test.</p>
<h2 id="separating-our-models-from-our-json-with-fractal">Separating our models from our JSON with Fractal</h2>
<p>Another problem with our API is that our representation of our data is tightly coupled to our underlying implementation of our models. We therefore can’t change our models without potentially changing the data returned by the API. We need to separate our representation of our data from our actual model so that we can more easily specify the exact data we want to return, regardless of the underlying database structure.</p>
<p>Enter <a href="http://fractal.thephpleague.com/">Fractal</a>. From the website:</p>
<blockquote>
<p>Fractal provides a presentation and transformation layer for complex data output, the like found in RESTful APIs, and works really well with JSON. Think of this as a view layer for your JSON/YAML/etc.</p>
</blockquote>
<p>In other words, Fractal lets you specify the format your data will take in one place so that it’s easier to return that data in a desired format. We’ll use Fractal to specify how we want our API responses to be formatted.</p>
<p>Install Fractal with the following command:</p>
<pre><code class="lang-php">$ composer require league/fractal
</code></pre>
<p>Then amend the classmap in <code>composer.json</code>:</p>
<pre><code class="lang-json">    &quot;autoload&quot;: {
        &quot;classmap&quot;: [
            &quot;database&quot;,
            &quot;app/Repositories&quot;,
            &quot;app/Transformers&quot;
        ],
        &quot;psr-4&quot;: {
            &quot;AnimalFriend\\&quot;: &quot;app/&quot;
        }
    },
</code></pre>
<p>Then create the folder <code>app/Transformers</code> and run <code>composer dump-autoload</code>. We’re now ready to write our first transformer. Save this as <code>app/Transformers/PetTransformer.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Transformers;

use AnimalFriend\Pet;
use League\Fractal;

class PetTransformer extends Fractal\TransformerAbstract
{
    public function transform(Pet $pet)
    {
        return [
            &#39;id&#39;            =&gt; (int) $pet-&gt;id,
            &#39;name&#39;          =&gt; (string) $pet-&gt;name,
            &#39;type&#39;          =&gt; (string) $pet-&gt;type,
            &#39;available&#39;     =&gt; (bool) $pet-&gt;available,
            &#39;picture&#39;       =&gt; (string) $pet-&gt;picture
        ];
    }
}
</code></pre>
<p>The <code>transform</code> method specifies how we want to represent our objects with our API. We can return only those attributes we want to expose, and amend the structure as we see fit. We could easily represemt relations in whatever manner we see fit, whereas before we needed to amend our queries to return the data in the right format, which would potentially be cumbersome.</p>
<p>Now let’s amend <code>PetController.php</code> to use this:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Repositories\Interfaces\PetRepositoryInterface as Pet;
use AnimalFriend\Transformers\PetTransformer;
use League\Fractal;
use League\Fractal\Manager;

class PetController extends Controller
{
    private $pet, $fractal;

    public function __construct(Pet $pet, Manager $fractal) {
        $this-&gt;pet = $pet;
        $this-&gt;fractal = $fractal;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;all();

        // Format it
        $resource = new Fractal\Resource\Collection($pets, new PetTransformer);
        $data = $this-&gt;fractal-&gt;createData($resource)-&gt;toArray();

        // Send response
        return response()-&gt;json($data, 200);
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Format it
        $resource = new Fractal\Resource\Item($pet, new PetTransformer);
        $data = $this-&gt;fractal-&gt;createData($resource)-&gt;toArray();

        // Send response
        return response()-&gt;json($data, 200);
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>Note that by default, Fractal places our data inside a dedicated <code>data</code> namespace. This is good because it leaves a place for us to put metadata such as pagination links, but it does mean our controller test has been broken. Let’s fix it:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class PetControllerTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test fetching pets when unauthorised
     *
     * @return void
     */
    public function testFetchingPetsWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets&#39;);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pets when authorised
     *
     * @return void
     */
    public function testFetchingPets()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets&#39;, [], $headers)
            -&gt;seeJsonStructure([
                &#39;data&#39; =&gt; [
                    &#39;*&#39; =&gt; [
                        &#39;id&#39;,
                        &#39;name&#39;,
                        &#39;type&#39;,
                        &#39;available&#39;,
                        &#39;picture&#39;
                    ]
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }

    /**
     * Test fetching pet when unauthorised
     *
     * @return void
     */
    public function testFetchingPetWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Send request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pet which does not exist
     *
     * @return void
     */
    public function testFetchingPetDoesNotExist()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/1&#39;, [], $headers);
        $this-&gt;assertResponseStatus(404);
    }

    /**
     * Test fetching pet when authorised
     *
     * @return void
     */
    public function testFetchingPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id, [], $headers)
            -&gt;seeJsonStructure([
                &#39;data&#39; =&gt; [
                    &#39;id&#39;,
                    &#39;name&#39;,
                    &#39;type&#39;,
                    &#39;available&#39;,
                    &#39;picture&#39;
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }
}
</code></pre>
<p>We’re also going to amend our test settings to use the array backend for the cache, as this does not require any external dependencies, but still allows us to tag our cache keys (I’ll cover that in a future instalment). Change the cache settings in <code>phpunit.xml</code> as follows:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;
</code></pre>
<p>Let’s run our tests to make sure everything’s fine:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 859 ms, Memory: 18.00MB

OK (12 tests, 44 assertions)
</code></pre>
<p>At present our <code>User</code> controller doesn’t actually return anything, and the auth only ever returns the token, so it’s not worth while adding a transformer now.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>That ends this lesson. We haven’t added any functionality, but we have improved the design of our API, and we’re now ready to develop it further. As usual, the backend repository has been tagged as <code>lesson-4</code>.</p>
<p>Next time we’ll start adding the additional functionality we need to our API.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Creating an Azure storage adapter for Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/">
        </link>
        <updated>2016-10-23T23:25:27Z</updated>
        <summary type="html"><![CDATA[<p>UPDATE: This post has now been superseded by <a href="/blog/2017/10/29/an-azure-filesystem-integration-for-laravel/">this one</a> as I’ve released this integration as a package.</p>
<p>About a year ago I was working on my first non-trivial Laravel application. The client had, for their own reasons, wanted to use Microsoft’s Azure platform, particularly for its blob storage functionality, which is somewhat comparable to Amazon S3. Now, Laravel has the excellent <code>Storage</code> facade  that allows consistent access to both local files and those stored on various file hosting services, which is built on top of <a href="https://flysystem.thephpleague.com/">Flysystem</a>. Flysystem has an Azure driver, but the Laravel storage doesn’t include support for it, so at the time I resigned myself to using Flysystem directly, which wasn’t actually that bad, but not ideal.</p>
<p>A few days ago I stumbled across <a href="https://laravel.com/docs/5.1/filesystem#custom-filesystems">this section of the Laravel documentation</a>, which had me kicking myself. It’s actually trivially easy to implement a custom filesystem for Laravel if it already has a Flysystem adapter, as demonstrated in their Dropbox implementation in the docs. Using this as a guide, I was able to produce the following service provider for using Azure as a storage backend very quickly:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Providers;

use Storage;
use League\Flysystem\Filesystem;
use Illuminate\Support\ServiceProvider;
use League\Flysystem\Azure\AzureAdapter;
use WindowsAzure\Common\ServicesBuilder;

class AzureStorageServiceProvider extends ServiceProvider
{
    /**
     * Perform post-registration booting of services.
     *
     * @return void
     */
    public function boot()
    {
        Storage::extend(&#39;azure&#39;, function($app, $config) {
            $endpoint = sprintf(
                &#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=%s&#39;,
                $config[&#39;name&#39;],
                $config[&#39;key&#39;]
            );

            $blobRestProxy = ServicesBuilder::getInstance()-&gt;createBlobService($endpoint);
            return new Filesystem(new AzureAdapter($blobRestProxy, $config[&#39;container&#39;]));
        });
    }

    /**
     * Register bindings in the container.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
</code></pre>
<p>This should be saved as <code>app/Providers/AzureStorageServiceProvider.php</code>. You also need to add this to the list of service providers in <code>config/app.php</code>:</p>
<pre><code class="lang-php">        App\Providers\AzureStorageServiceProvider::class,
</code></pre>
<p>And add this to <code>config/filesystems.php</code>:</p>
<pre><code class="lang-php">        &#39;azure&#39; =&gt; [
            &#39;driver&#39;    =&gt; &#39;azure&#39;,
            &#39;name&#39;      =&gt; env(&#39;STORAGE_NAME&#39;),
            &#39;key&#39;       =&gt; env(&#39;STORAGE_KEY&#39;),
            &#39;container&#39; =&gt; env(&#39;STORAGE_CONTAINER&#39;),
        ],
</code></pre>
<p>I like to also set my storage backend using environment variables in this file, as in this example:</p>
<pre><code class="lang-php">    &#39;default&#39; =&gt; env(&#39;STORAGE_BACKEND&#39;, &#39;local&#39;),
</code></pre>
<p>That way we can easily set a different backend for testing, development and production so we don’t upload files when running PHPUnit. You can also keep your other config settings in your <code>.env</code> file, which is always a better idea than keeping it under version control. You also need to install the <code>microsoft/windowsazure</code> and <code>league/flysystem-azure</code> packages via Composer for this to work.</p>
<p>As I’ve since changed jobs it’s unlikely I’ll ever actually use this Azure integration in production - it’s not a service I’d choose of my own accord to use. However, since it’s so straightforward to implement an adapter like this I imagine I may be doing something similar - I’m currently working on a web app that uses MongoDB for some of its data and currently stores files locally, so it might make sense to create a GridFS integration along similar lines. It may also be useful for someone else, so feel free to use it if you wish.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Phonegap app with Laravel and Angular - Part 3]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/10/16/building-a-phonegap-app-with-laravel-and-angular-part-3/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/10/16/building-a-phonegap-app-with-laravel-and-angular-part-3/">
        </link>
        <updated>2016-10-16T17:10:13Z</updated>
        <summary type="html"><![CDATA[<p>Apologies for how long it’s taken for this post to appear. I’ve got a lot on my plate at present as I recently started a new job, so I haven’t been able to devote as much time to this series as I’d like.</p>
<p>In this instalment we’ll begin extending our app beyond the basic authentication we’ve already implemented. We’ll start by adding the means to sign up, before adding the list of pets.</p>
<h2 id="adding-a-signup-method-to-our-backend">Adding a signup method to our backend</h2>
<p>We’ll create a controller for our users in the Laravel backend. First we’ll create our tests:</p>
<pre><code class="lang-bash">$ php artisan make:test UserControllerTest
</code></pre>
<p>We’ll create three tests. The first will check to see that an invalid request raises the correct status code (422). The second will check that a valid request returns the correct status code (201) and creates the user. The third will check that trying to create a duplicate user raises an error. Here they are - they should be saved in the new <code>tests/UserControllerTest.php</code> file:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class UserControllerTest extends TestCase
{
    /**
     * Test creating a user - invalid
     *
     * @return void
     */
    public function testPostingInvalidUser()
    {
        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(422);
    }

    /**
     * Test creating a user
     *
     * @return void
     */
    public function testPostingUser()
    {
        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
            &#39;password_confirmation&#39; =&gt; &#39;password&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(201);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Check user exists
        $saved = User::first();
        $this-&gt;assertEquals($saved-&gt;email, &#39;bob@example.com&#39;);
        $this-&gt;assertEquals($saved-&gt;name, &#39;Bob Smith&#39;);
    }

    /**
     * Test creating a duplicate user
     *
     * @return void
     */
    public function testPostingDuplicateUser()
    {
        // Create user
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create a request
        $data = array(
            &#39;name&#39; =&gt; &#39;Bob Smith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
            &#39;password_confirmation&#39; =&gt; &#39;password&#39;
        );
        $this-&gt;json(&#39;POST&#39;, &#39;/api/users&#39;, $data);
        $this-&gt;assertResponseStatus(422);
    }
}
</code></pre>
<p>Note the use of <code>$this-&gt;json()</code> to make the request. This method is ideal for testing a REST API.</p>
<p>Running our tests should confirm that they fail:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

........FFF.                                                      12 / 12 (100%)

Time: 827 ms, Memory: 18.00MB

There were 3 failures:

1) UserControllerTest::testPostingInvalidUser
Expected status code 422, got 404.
Failed asserting that 404 matches expected 422.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:21

2) UserControllerTest::testPostingUser
Expected status code 201, got 404.
Failed asserting that 404 matches expected 201.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:39

3) UserControllerTest::testPostingDuplicateUser
Expected status code 422, got 404.
Failed asserting that 404 matches expected 422.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/UserControllerTest.php:71

FAILURES!
Tests: 12, Assertions: 43, Failures: 3.
</code></pre>
<p>Next, we create our new controller:</p>
<pre><code class="lang-bash">$ php artisan make:controller UserController --resource
</code></pre>
<p>Let’s populate it:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\User;
use JWTAuth;
use Hash;

class UserController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;email&#39; =&gt; &#39;required|email|unique:users,email&#39;,
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;password&#39; =&gt; &#39;required|confirmed&#39;,
        ]);

        // Create user
        $user = new $this-&gt;user;
        $user-&gt;email = $request-&gt;input(&#39;email&#39;);
        $user-&gt;name = $request-&gt;input(&#39;name&#39;);
        $user-&gt;password = Hash::make($request-&gt;input(&#39;password&#39;));
        $user-&gt;save();

        // Create token
        $token = JWTAuth::fromUser($user);

        // Send response
        return response()-&gt;json([&#39;token&#39; =&gt; $token], 201);
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        //
    }
}
</code></pre>
<p>For now we’ll leave the other methods blank, but we’ll be using them later so we won’t get rid of them. At the top, note we load not only the <code>User</code> model, but also the <code>JWTAuth</code> and <code>Hash</code> facades. We use <code>JWTAuth::fromUser()</code> to return a JSON web token for the given user model.</p>
<p>In the <code>store()</code> method we first of all use <a href="https://laravel.com/docs/5.3/validation">Laravel’s validation support</a> to validate our input. We specify that the user must provide a unique email address, a username, and a password, which must be confirmed. Note that we don’t need to specify an action if the request is invalid, as Laravel will do that for us. Also, note that the <code>confirmed</code> rule means that the <code>password</code> field must be accompanied by a matching <code>password_confirmation</code> field.</p>
<p>Next, we create the user. Note that we hash the password before storing it, which is a best practice (storing passwords in plain text is a REALLY bad idea!). Then we create the token for the new user and return it. From then on, the user can use that token to authenticate their requests.</p>
<p>We also need to add this route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">Route::resource(&#39;users&#39;, &#39;UserController&#39;);
</code></pre>
<p>Let’s check the test passes:</p>
<pre><code class="lang-php">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

............                                                      12 / 12 (100%)

Time: 905 ms, Memory: 20.00MB

OK (12 tests, 46 assertions)
</code></pre>
<h2 id="building-the-registration-in-the-app">Building the registration in the app</h2>
<p>With registration in place on the server side, we can move back to the app. We need to create another route for the registration form. Add this to <code>test/routes.spec.js</code>:</p>
<pre><code class="lang-javascript">  it(&#39;should map register route to register controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/register&#39;].controller).toBe(&#39;RegisterCtrl&#39;);
      expect($route.routes[&#39;/register&#39;].templateUrl).toEqual(&#39;templates/register.html&#39;);
    });
  });
</code></pre>
<p>Running the tests should confirm that this fails. So next you should add this to the route provider section of <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">  .when(&#39;/register&#39;, {
    templateUrl: &#39;templates/register.html&#39;,
    controller: &#39;RegisterCtrl&#39;
  })
</code></pre>
<p>We also need to allow the register path to be accessed when not logged in:</p>
<pre><code class="lang-javascript">.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39; &amp;&amp; $location.path() !== &#39;/register&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])
</code></pre>
<p>Our next step is to create a service representing the <code>User</code> endpoint. Here’s the test for it:</p>
<pre><code class="lang-javascript">  describe(&#39;User service&#39;, function () {
    var mockBackend, User;

    beforeEach(inject(function (_User_, _$httpBackend_) {
      User = _User_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can create a new user&#39;, function () {
      mockBackend.expectPOST(&#39;http://localhost:8000/api/users&#39;, &#39;{&quot;email&quot;:&quot;bob@example.com&quot;,&quot;name&quot;:&quot;bobsmith&quot;,&quot;password&quot;:&quot;password&quot;,&quot;password_confirmation&quot;:&quot;password&quot;}&#39;).respond({token: &#39;mytoken&#39;});
      var user = new User({
        email: &#39;bob@example.com&#39;,
        name: &#39;bobsmith&#39;,
        password: &#39;password&#39;,
        password_confirmation: &#39;password&#39;
      });
      user.$save(function (response) {
        expect(response).toEqualData({token: &#39;mytoken&#39;});
      });
      mockBackend.flush();
    });
  });
</code></pre>
<p>We’re only interested in using this model to create new users at this point, so this is the full scope of this test for now. Make sure the test fails, then we’re ready to create the new service in <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">.factory(&#39;User&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/users/:id&#39;, null, {
    &#39;update&#39;: { method: &#39;PATCH&#39; }
  });
})
</code></pre>
<p>Note that <code>angular-resource</code> does not support the <code>PUT</code> or <code>PATCH</code> methods by default, but as shown here it’s easy to implement it ourselves. That should be sufficient to make our test pass.</p>
<p>Next, we need to create the controller for registration. Here’s the test for it:</p>
<pre><code class="lang-javascript">  describe(&#39;Register Controller&#39;, function () {
    var mockBackend, scope;

    beforeEach(inject(function ($rootScope, $controller, _$httpBackend_) {
      mockBackend = _$httpBackend_;
      scope = $rootScope.$new();
      $controller(&#39;RegisterCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test doRegister is defined
    it(&#39;should define the register method&#39;, function () {
      expect(scope.doRegister).toBeDefined();
    });

    // Test doRegister works
    it(&#39;should allow the user to register&#39;, function () {
      // Mock the backend
      mockBackend.expectPOST(&#39;http://localhost:8000/api/users&#39;, &#39;{&quot;email&quot;:&quot;user@example.com&quot;,&quot;name&quot;:&quot;bobsmith&quot;,&quot;password&quot;:&quot;password&quot;,&quot;password_confirmation&quot;:&quot;password&quot;}&#39;).respond({token: 123});

      // Define login data
      scope.credentials = {
        email: &#39;user@example.com&#39;,
        name: &quot;bobsmith&quot;,
        password: &#39;password&#39;,
        password_confirmation: &#39;password&#39;
      };

      //  Submit the request
      scope.doRegister();

      // Flush the backend
      mockBackend.flush();

      // Check login complete
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(&#39;Bearer 123&#39;);
    });
  });
</code></pre>
<p>Make sure the test fails before proceeding. Our <code>RegisterCtrl</code> is very similar to the login controller:</p>
<pre><code class="lang-javascript">.controller(&#39;RegisterCtrl&#39;, function ($scope, $location, User, Auth) {
  $scope.doRegister = function () {
    var user = new User($scope.credentials);
    user.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})
</code></pre>
<p>Check the tests pass,and we’re ready to move on to creating our HTML template. Save this as <code>www/templates/register.html</code>:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Username&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.name&quot; type=&quot;text&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Confirm Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password_confirmation&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doRegister()&quot;&gt;Submit&lt;/md-button&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; href=&quot;/login&quot;&gt;Log in&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>It’s very similar to our login template. Speaking of which, we need to add a link to this route there:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot; /&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot; /&gt;
        &lt;/md-input-container&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doLogin()&quot;&gt;Submit&lt;/md-button&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; href=&quot;register&quot;&gt;Register&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>With that done, you should now be able to run the Gulp server for the app with <code>gulp</code> and the Laravel backend with <code>php artisan serve</code> and create a new user account.</p>
<h2 id="adding-pets-to-the-home-page">Adding pets to the home page</h2>
<p>Our final task for this lesson is to display a list of pets on the home page. Later we’ll refine that functionality, but for now we’ll just get a list of all current pets and display them. First we need to write a test for our <code>Pet</code> service:</p>
<pre><code class="lang-javascript">  describe(&#39;Pet service&#39;, function () {
    var mockBackend, Pet;

    beforeEach(inject(function (_Pet_, _$httpBackend_) {
      Pet = _Pet_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can fetch pets&#39;, function () {
      mockBackend.expectGET(&#39;http://localhost:8000/api/pets&#39;).respond([{id:1,name:&quot;Freddie&quot;,type:&quot;Cat&quot;}]);
      expect(Pet).toBeDefined();
      var pets = Pet.query();
      mockBackend.flush();
      expect(pets).toEqualData([{id: 1,name:&quot;Freddie&quot;,type:&quot;Cat&quot;}]);
    });
  });
</code></pre>
<p>Once you know that fails, it’s time to implement the service:</p>
<pre><code class="lang-javascript">.factory(&#39;Pet&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/pets/:id&#39;, null, {
    &#39;update&#39;: { method: &#39;PATCH&#39; }
  });
})
</code></pre>
<p>Next, we want to add the pets to the scope of the home controller. Amend the test for it as follows:</p>
<pre><code class="lang-javascript">  describe(&#39;Home Controller&#39;, function () {
    var pets, scope;

    beforeEach(inject(function ($rootScope, $controller, Pet) {
      pets = Pet;
      scope = $rootScope.$new();
      $controller(&#39;HomeCtrl&#39;, {
        $scope: scope,
        pets: [{id:1},{id:2}]
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test pets
    it(&#39;should define the pets&#39;, function () {
      expect(scope.pets).toEqualData([{id: 1}, {id: 2}]);
    });
  });
</code></pre>
<p>We check to see if the scope contains the <code>pets</code> variable. Once you have a failing test, amend the home controller as follows:</p>
<pre><code class="lang-javascript">.controller(&#39;HomeCtrl&#39;, function ($scope, Pet, pets) {
  $scope.pets = pets;
});
</code></pre>
<p>We could fetch the via AJAX inside the controller, but there’s a better way. We’ll create a loader for the pet data and have it resolve that before the page is displayed. To do so, first we need to add the loader service to <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">.factory(&#39;PetsLoader&#39;, [&#39;Pet&#39;, &#39;$q&#39;, function (Pet, $q) {
  return function () {
    var delay = $q.defer();
    Pet.query(function (response) {
      delay.resolve(response);
    }, function () {
      delay.reject(&#39;Unable to fetch pets&#39;);
    });
    return delay.promise;
  };
}])
</code></pre>
<p>Then we set that route up to resolve it in <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;,
    resolve: {
      pets: [&#39;PetsLoader&#39;, function (PetsLoader) {
        return PetsLoader();
      }]
    }
  })
</code></pre>
<p>Now, when we load that route, it will first of all fetch those pets and populate <code>$scope.pets</code> with them.</p>
<p>Now, we need to have some pets in the database, so we’ll make a seeder for it. Head back to the backend and run this command:</p>
<pre><code class="lang-bash">$ php artisan make:seeder PetTableSeeder
</code></pre>
<p>Then amend the file at <code>database/seeds/PetTableSeeder.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class PetTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add Pets
        DB::table(&#39;pets&#39;)-&gt;insert([[
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
            &#39;available&#39; =&gt; 1,
            &#39;picture&#39;   =&gt; &#39;https://placekitten.com/300/300&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ], [
            &#39;name&#39; =&gt; &#39;Sophie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
            &#39;available&#39; =&gt; 1,
            &#39;picture&#39;   =&gt; &#39;https://placekitten.com/300/300&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ]]);
    }
}
</code></pre>
<p>And we need to update <code>database/seeds/DatabaseSeeder.php</code> to call our seeder:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(UserTableSeeder::class);
        $this-&gt;call(PetTableSeeder::class);
    }
}
</code></pre>
<p>For now we’ll use placeholder images, but at a later point our backend will be set up to use images uploaded from the admin. Then we need to refresh our migrations and apply the seeders:</p>
<pre><code class="lang-bash">$ php artisan migrate:refresh
$ php artisan db:seed
</code></pre>
<p>Now we just need to amend our home template to show the pets and we’re done for today:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;/logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;

&lt;div layout=&quot;column&quot; flex=&quot;grow&quot; layout-align=&quot;center stretch&quot;&gt;
    &lt;md-card md-theme=&quot;default&quot; ng-repeat=&quot;pet in pets&quot;&gt;
        &lt;md-card-title&gt;
            &lt;md-card-title-text&gt;
                &lt;span class=&quot;md-headline&quot;&gt;{{ pet.name }}&lt;/span&gt;
                &lt;span class=&quot;md-subhead&quot;&gt;{{ pet.type }}&lt;/span&gt;
            &lt;/md-card-title-text&gt;
        &lt;/md-card-title&gt;
        &lt;md-card-content&gt;
            &lt;img class=&quot;md-card-image md-media-lg&quot; ng-src=&quot;{{ pet.picture }}&quot;&gt;&lt;/img&gt;
        &lt;/md-card-content&gt;
    &lt;/md-card&gt;
&lt;/div&gt;
</code></pre>
<p>Now we can see our pets in the app.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>That’s enough for today - the fact that we can log in and out, register, and view the home page is sufficient as a proof of concept for a client. As usual, the results are on Github, tagged <code>lesson-3</code>. </p>
<p>Next time, we’ll concentrate exclusively on the back end. We’ll build upon what we already have using Laravel to create a full REST API for our app. In a later instalment, we’ll move on to build our admin interface for the staff, before switching back to finish off the app. I hope you’ll join me then.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Phonegap app with Laravel and Angular - Part 2]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/09/18/building-a-phonegap-app-with-laravel-and-angular-part-2/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/09/18/building-a-phonegap-app-with-laravel-and-angular-part-2/">
        </link>
        <updated>2016-09-18T22:18:06Z</updated>
        <summary type="html"><![CDATA[<p>In this lesson, the initial scope of the app will be extremely simple. We will implement functionality that:</p>
<ul>
<li>Allows users to log in and out</li>
<li>Displays the home page</li>
</ul>
<p>That’s fairly simple, and easily achievable within a fairly short timeframe. We’ll also write automated tests for our app. By the end of this lesson, we’ll have built a first pass for our app using Angular.js.</p>
<p>NOTE: As at time of writing, Angular 2 has just come out. I’m using Angular 1 here, and the two are not compatible, so make sure you’re using Angular 1.</p>
<h2 id="creating-our-app">Creating our app</h2>
<p>Start by creating a new folder, separate from the backend, for the app. Then, in there, run the following command:</p>
<pre><code class="lang-bash">$ npm init -y
</code></pre>
<p>Then let’s install our dependencies:</p>
<pre><code class="lang-bash">$ npm install --save-dev gulp karma karma-browserify karma-phantomjs-launcher browserify angular angular-route angular-mocks angular-animate angular-messages angular-sanitize angular-material angular-resource vinyl-buffer vinyl-source-stream gulp-sass karma-coverage karma-jasmine jasmine-core gulp-webserver
</code></pre>
<p>We’re going to use <a href="https://material.angularjs.org/latest/">Angular Material</a> for our user interface as it includes support out of the box for swiping left and right. You’ll notice it mentioned as one of the dependencies above.</p>
<p>We’ll also use Karma for running our tests. Save the following as <code>karma.conf.js</code>:</p>
<pre><code class="lang-javascript">module.exports = function(config) {
    config.set({
        basePath: &#39;&#39;,
        frameworks: [&#39;browserify&#39;, &#39;jasmine&#39;],
        files: [
            &#39;node_modules/angular/angular.min.js&#39;,
            &#39;node_modules/angular-mocks/angular-mocks.js&#39;,
            &#39;node_modules/angular-material/angular-material-mocks.js&#39;,
            &#39;js/*.js&#39;,
            &#39;test/*.js&#39;
        ],
        exclude: [
        ],
        preprocessors: {
            &#39;js/*.js&#39;: [&#39;browserify&#39;, &#39;coverage&#39;],
            &#39;tests/js&#39;: [&#39;browserify&#39;]
        },
        browserify: {
          debug: true
        },
        reporters: [&#39;progress&#39;, &#39;coverage&#39;],
        port: 9876,
        colors: true,
        logLevel: config.LOG_DEBUG,
        autoWatch: true,
        browsers: [&#39;PhantomJS&#39;],
        singleRun: true,
        coverageReporter: {
          dir : &#39;coverage/&#39;,
          reporters: [
            { type: &#39;html&#39;, subdir: &#39;report-html&#39; },
            { type: &#39;cobertura&#39;, subdir: &#39;report-cobertura&#39; }
          ]
        }
    });
};
</code></pre>
<p>This is our Karma configuration. Karma can run the same test in multiple browsers. Here we’re going to use PhantomJS, but it’s trivial to amend the <code>browsers</code> section to add more. You just need to make sure you install the appropriate launchers for those browsers.</p>
<p>We’ll use Gulp to build the app. Here’s the <code>gulpfile.js</code>:</p>
<pre><code class="lang-javascript">var gulp = require(&#39;gulp&#39;);
var source = require(&#39;vinyl-source-stream&#39;);
var buffer = require(&#39;vinyl-buffer&#39;);
var browserify = require(&#39;browserify&#39;);
var sass = require(&#39;gulp-sass&#39;);
var server = require(&#39;gulp-webserver&#39;);

var paths = {
  scripts: [&#39;js/*.js&#39;],
  styles: [&#39;sass/*.scss&#39;]
};

gulp.task(&#39;sass&#39;, function() {
  gulp.src(&#39;sass/style.scss&#39;)
   .pipe(sass().on(&#39;error&#39;, sass.logError))
   .pipe(gulp.dest(&#39;www/css&#39;));
});;

gulp.task(&#39;js&#39;, function () {
  return browserify({ entries: [&#39;js/main.js&#39;], debug: true })
    .bundle()
    .pipe(source(&#39;bundle.js&#39;))
    .pipe(buffer())
    .pipe(gulp.dest(&#39;www/js/&#39;));
});

gulp.task(&#39;server&#39;, function () {
  gulp.src(&#39;www/&#39;)
    .pipe(server({
      livereload: true,
      open: true,
      port: 5000
    }));
});


gulp.task(&#39;watch&#39;, function () {
  gulp.watch(paths.scripts, [&#39;js&#39;]);
  gulp.watch(paths.styles, [&#39;sass&#39;]);
});

gulp.task(&#39;default&#39;, [&#39;sass&#39;,&#39;js&#39;,&#39;server&#39;, &#39;watch&#39;]);
</code></pre>
<p>Note that we’re going to be using Browserify to handle our dependencies. If you haven’t used it before, it lets you use the <code>require()</code> syntax from Node.js to include other JavaScript files, including ones available via NPM such as jQuery or Angular, allowing you to compile them all into a single file.</p>
<p>We should be able to test and run the app using NPM, so add these scripts to <code>package.json</code>:</p>
<pre><code class="lang-javascript">  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;karma start&quot;,
    &quot;run&quot;: &quot;gulp&quot;
  },
</code></pre>
<p>We also need an HTML file. Save this as <code>www/index.html</code>:</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt;
        &lt;title&gt;My New Animal Friend&lt;/title&gt;
        &lt;link href=&quot;/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div&gt;
        &lt;div ng-app=&quot;mynewanimalfriend&quot; ng-cloak&gt;
            &lt;div ng-view&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;/body&gt;
    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;/js/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>Note the use of the Angular directives. <code>ng-app</code> denotes the name of the app namespace, <code>ng-cloak</code> hides the application until it’s fully loaded, and <code>ng-view</code> denotes the area containing our content.</p>
<p>You should also create the files <code>js/main.js</code>, <code>sass/style.scss</code>, and the <code>test</code> folder.</p>
<h2 id="creating-our-first-routes">Creating our first routes</h2>
<p>Our first task is to create the routes we need. Our default route will be <code>/</code>, representing the home page. However, users will need to be logged in to see this. Otherwise, they should be redirected to the login route, which will be <code>/login</code>, appropriately enough. We’ll also have a <code>/logout</code> route, which should be self-explanatory.</p>
<p>Before we implement these routes, we need to write a test for them. We’ll start with our login route, and we’ll test that for this route, the controller will be <code>LoginCtrl</code> and the template will be <code>templates/login.html</code>. The significance of these will become apparent later. Save this as <code>test/routes.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Routes&#39;, function () {

  beforeEach(angular.mock.module(&#39;mynewanimalfriend&#39;));
  it(&#39;should map login route to login controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/login&#39;].controller).toBe(&#39;LoginCtrl&#39;);
      expect($route.routes[&#39;/login&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });
});
</code></pre>
<p>Note the <code>beforeEach()</code> hook. This is used to set up the application.</p>
<p>We can run this test with <code>npm test</code> as that calls Karma directly. Note that we’re using Jasmine to write our tests.</p>
<pre><code class="lang-bash">$ npm test

&gt; mynewanimalfriend-app@1.0.0 test /home/matthew/Projects/mynewanimalfriend-app
&gt; karma start

12 09 2016 22:22:34.168:DEBUG [config]: autoWatch set to false, because of singleRun
12 09 2016 22:22:34.172:DEBUG [plugin]: Loading karma-* from /home/matthew/Projects/mynewanimalfriend-app/node_modules
12 09 2016 22:22:34.176:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-browserify.
12 09 2016 22:22:34.314:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-coverage.
12 09 2016 22:22:34.484:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine.
12 09 2016 22:22:34.485:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-phantomjs-launcher.
12 09 2016 22:22:34.535:DEBUG [framework.browserify]: created browserify bundle: /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:34.553:DEBUG [framework.browserify]: add bundle to config.files at position 3
12 09 2016 22:22:34.559:DEBUG [web-server]: Instantiating middleware
12 09 2016 22:22:34.569:DEBUG [reporter]: Trying to load reporter: coverage
12 09 2016 22:22:34.570:DEBUG [reporter]: Trying to load color-version of reporter: coverage (coverage_color)
12 09 2016 22:22:34.571:DEBUG [reporter]: Couldn&#39;t load color-version.
12 09 2016 22:22:34.596:DEBUG [framework.browserify]: updating js/main.js in bundle
12 09 2016 22:22:34.597:DEBUG [framework.browserify]: building bundle
12 09 2016 22:22:35.302:DEBUG [framework.browserify]: bundling
12 09 2016 22:22:35.328:DEBUG [preprocessor.coverage]: Processing &quot;/home/matthew/Projects/mynewanimalfriend-app/js/main.js&quot;.
12 09 2016 22:22:35.345:INFO [framework.browserify]: bundle built
12 09 2016 22:22:35.352:INFO [karma]: Karma v1.3.0 server started at http://localhost:9876/
12 09 2016 22:22:35.352:INFO [launcher]: Launching browser PhantomJS with unlimited concurrency
12 09 2016 22:22:35.361:INFO [launcher]: Starting browser PhantomJS
12 09 2016 22:22:35.361:DEBUG [temp-dir]: Creating temp dir at /tmp/karma-17657666
12 09 2016 22:22:35.364:DEBUG [launcher]: /home/matthew/Projects/mynewanimalfriend-app/node_modules/phantomjs-prebuilt/lib/phantom/bin/phantomjs /tmp/karma-17657666/capture.js
12 09 2016 22:22:35.466:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/client.html
12 09 2016 22:22:35.478:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/karma.js
12 09 2016 22:22:35.541:DEBUG [karma]: A browser has connected on socket /#dQYjOD4F_HJwPXiYAAAA
12 09 2016 22:22:35.564:DEBUG [web-server]: upgrade /socket.io/?EIO=3&amp;transport=websocket&amp;sid=dQYjOD4F_HJwPXiYAAAA
12 09 2016 22:22:35.629:INFO [PhantomJS 2.1.1 (Linux 0.0.0)]: Connected on socket /#dQYjOD4F_HJwPXiYAAAA with id 17657666
12 09 2016 22:22:35.630:DEBUG [launcher]: PhantomJS (id 17657666) captured in 0.277 secs
12 09 2016 22:22:35.642:DEBUG [phantomjs.launcher]: 

12 09 2016 22:22:35.643:DEBUG [middleware:karma]: custom files null null
12 09 2016 22:22:35.644:DEBUG [middleware:karma]: Serving static request /context.html
12 09 2016 22:22:35.646:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.html
12 09 2016 22:22:35.650:DEBUG [middleware:source-files]: Requesting /base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?b1682a1eb50e00abf147fc1fb28e31006d499aae /
12 09 2016 22:22:35.650:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:22:35.652:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-material/angular-material-mocks.js?9f31553e4bbbad4d6b52638351e3a274352311c2 /
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:22:35.654:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/boot.js?945a38bf4e45ad2770eb94868231905a04a0bd3e /
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/adapter.js?7975a273517f1eb29d7bd018790fd4c7b9a485d5 /
12 09 2016 22:22:35.655:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular/angular.min.js?78069f9f3a9ca9652cb04c13ccb0670d747666b8 /
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:22:35.656:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-mocks/angular-mocks.js?cc56136dc551d94abe8195cf8475eb27a3aa3c4b /
12 09 2016 22:22:35.657:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:22:35.657:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:22:35.658:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:22:35.658:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:22:35.659:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:22:35.659:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:22:35.660:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.js
12 09 2016 22:22:35.661:DEBUG [middleware:source-files]: Requesting /absolute/tmp/f8c46bd8d72c5b8578e64552192273be.browserify?8ffde4eef27d38e92cc62da4e8dd0ffa5a3a4a4c /
12 09 2016 22:22:35.661:DEBUG [middleware:source-files]: Fetching /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Requesting /base/js/main.js?41c850cecc07c24d7cd0421e914bd2420671e573 /
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Requesting /base/test/routes.spec.js?92b15bb7c24bc6ead636994fb1c737b91727d887 /
12 09 2016 22:22:35.662:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:22:35.663:DEBUG [web-server]: serving (cached): /tmp/f8c46bd8d72c5b8578e64552192273be.browserify
12 09 2016 22:22:35.664:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:22:35.664:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
PhantomJS 2.1.1 (Linux 0.0.0) Routes should map login route to login controller FAILED
        Error: [$injector:modulerr] http://errors.angularjs.org/1.5.8/$injector/modulerr?p0=mynewanimalfriend&amp;p1=%5B%24injector%3Anomod%5D%20http%3A%2F%2Ferrors.angularjs.org%2F1.5.8%2F%24injector%2Fnomod%3Fp0%3Dmynewanimalfriend%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A25%3A111%0Ab%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A24%3A143%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A24%3A489%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A39%3A473%0Aq%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A7%3A359%0Ag%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A39%3A320%0Acb%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular%2Fangular.min.js%3F78069f9f3a9ca9652cb04c13ccb0670d747666b8%3A43%3A337%0AworkFn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular-mocks%2Fangular-mocks.js%3Fcc56136dc551d94abe8195cf8475eb27a3aa3c4b%3A3074%3A60%0Ainject%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fangular-mocks%2Fangular-mocks.js%3Fcc56136dc551d94abe8195cf8475eb27a3aa3c4b%3A3054%3A46%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Ftest%2Froutes.spec.js%3F92b15bb7c24bc6ead636994fb1c737b91727d887%3A5%3A11%0AattemptSync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1942%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1930%3A20%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A367%3A28%0Afn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2568%3A44%0AattemptAsync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1972%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1927%3A21%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Afn%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2553%3A31%0AattemptAsync%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1972%3A28%0Arun%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1927%3A21%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A1915%3A13%0AqueueRunnerFactory%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A710%3A42%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A2415%3A25%0Aexecute%40http%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fjasmine-core%2Flib%2Fjasmine-core%2Fjasmine.js%3Fb1682a1eb50e00abf147fc1fb28e31006d499aae%3A772%3A24%0Ahttp%3A%2F%2Flocalhost%3A9876%2Fbase%2Fnode_modules%2Fkarma-jasmine%2Flib%2Fadapter.js%3F7975a273517f1eb29d7bd018790fd4c7b9a485d5%3A320%3A23%0Aloaded%40http%3A%2F%2Flocalhost%3A9876%2Fcontext.js%3A151%3A17%0Aglobal%20code%40http%3A%2F%2Flocalhost%3A9876%2Fcontext.html%3A50%3A28 in node_modules/angular/angular.min.js (line 40)
        node_modules/angular/angular.min.js:40:260
        q@node_modules/angular/angular.min.js:7:359
        g@node_modules/angular/angular.min.js:39:320
        cb@node_modules/angular/angular.min.js:43:337
        workFn@node_modules/angular-mocks/angular-mocks.js:3074:60
        inject@node_modules/angular-mocks/angular-mocks.js:3054:46
        test/routes.spec.js:5:11
        loaded@http://localhost:9876/context.js:151:17
PhantomJS 2.1.1 (Linux 0.0.0): Executed 1 of 1 (1 FAILED) ERROR (0.044 secs / 0.006 secs)
12 09 2016 22:22:35.778:DEBUG [karma]: Run complete, exiting.
12 09 2016 22:22:35.778:DEBUG [launcher]: Disconnecting all browsers
12 09 2016 22:22:35.778:DEBUG [framework.browserify]: cleaning up
12 09 2016 22:22:35.782:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-html
12 09 2016 22:22:35.876:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-cobertura
12 09 2016 22:22:35.880:DEBUG [launcher]: Process PhantomJS exited with code 0
12 09 2016 22:22:35.881:DEBUG [temp-dir]: Cleaning temp dir /tmp/karma-17657666
12 09 2016 22:22:35.884:DEBUG [launcher]: Finished all browsers
npm ERR! Test failed.  See above for more details.
</code></pre>
<p>Now that we have a failing test, we can set about making it pass. Save this at <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  });
});
</code></pre>
<p>As mentioned earlier, because we’re using Browserify, we can use the <code>require()</code> syntax to import our dependencies. Note we also give our module a name and specify the dependencies. Finally, note that we use <code>$routeProvider</code> to set up our first route, and we map the template URL and controller to match our test.</p>
<p>Let’s run the test again:</p>
<pre><code class="lang-bash">$ npm test

&gt; mynewanimalfriend-app@1.0.0 test /home/matthew/Projects/mynewanimalfriend-app
&gt; karma start

12 09 2016 22:35:51.231:DEBUG [config]: autoWatch set to false, because of singleRun
12 09 2016 22:35:51.235:DEBUG [plugin]: Loading karma-* from /home/matthew/Projects/mynewanimalfriend-app/node_modules
12 09 2016 22:35:51.237:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-browserify.
12 09 2016 22:35:51.354:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-coverage.
12 09 2016 22:35:51.496:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine.
12 09 2016 22:35:51.497:DEBUG [plugin]: Loading plugin /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-phantomjs-launcher.
12 09 2016 22:35:51.547:DEBUG [framework.browserify]: created browserify bundle: /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:51.559:DEBUG [framework.browserify]: add bundle to config.files at position 3
12 09 2016 22:35:51.564:DEBUG [web-server]: Instantiating middleware
12 09 2016 22:35:51.581:DEBUG [reporter]: Trying to load reporter: coverage
12 09 2016 22:35:51.582:DEBUG [reporter]: Trying to load color-version of reporter: coverage (coverage_color)
12 09 2016 22:35:51.582:DEBUG [reporter]: Couldn&#39;t load color-version.
12 09 2016 22:35:51.602:DEBUG [framework.browserify]: updating js/main.js in bundle
12 09 2016 22:35:51.603:DEBUG [framework.browserify]: building bundle
12 09 2016 22:35:52.306:DEBUG [framework.browserify]: bundling
12 09 2016 22:35:54.095:DEBUG [preprocessor.coverage]: Processing &quot;/home/matthew/Projects/mynewanimalfriend-app/js/main.js&quot;.
12 09 2016 22:35:54.170:INFO [framework.browserify]: bundle built
12 09 2016 22:35:54.189:INFO [karma]: Karma v1.3.0 server started at http://localhost:9876/
12 09 2016 22:35:54.189:INFO [launcher]: Launching browser PhantomJS with unlimited concurrency
12 09 2016 22:35:54.197:INFO [launcher]: Starting browser PhantomJS
12 09 2016 22:35:54.198:DEBUG [temp-dir]: Creating temp dir at /tmp/karma-91342786
12 09 2016 22:35:54.201:DEBUG [launcher]: /home/matthew/Projects/mynewanimalfriend-app/node_modules/phantomjs-prebuilt/lib/phantom/bin/phantomjs /tmp/karma-91342786/capture.js
12 09 2016 22:35:54.300:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/client.html
12 09 2016 22:35:54.308:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/karma.js
12 09 2016 22:35:54.366:DEBUG [karma]: A browser has connected on socket /#FpcuZAJUT-u6Dl4sAAAA
12 09 2016 22:35:54.386:DEBUG [web-server]: upgrade /socket.io/?EIO=3&amp;transport=websocket&amp;sid=FpcuZAJUT-u6Dl4sAAAA
12 09 2016 22:35:54.442:INFO [PhantomJS 2.1.1 (Linux 0.0.0)]: Connected on socket /#FpcuZAJUT-u6Dl4sAAAA with id 91342786
12 09 2016 22:35:54.442:DEBUG [launcher]: PhantomJS (id 91342786) captured in 0.253 secs
12 09 2016 22:35:54.447:DEBUG [phantomjs.launcher]: 

12 09 2016 22:35:54.448:DEBUG [middleware:karma]: custom files null null
12 09 2016 22:35:54.448:DEBUG [middleware:karma]: Serving static request /context.html
12 09 2016 22:35:54.449:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.html
12 09 2016 22:35:54.451:DEBUG [middleware:source-files]: Requesting /base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?b1682a1eb50e00abf147fc1fb28e31006d499aae /
12 09 2016 22:35:54.451:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:35:54.452:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-material/angular-material-mocks.js?9f31553e4bbbad4d6b52638351e3a274352311c2 /
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:35:54.453:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/boot.js?945a38bf4e45ad2770eb94868231905a04a0bd3e /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Requesting /base/node_modules/karma-jasmine/lib/adapter.js?7975a273517f1eb29d7bd018790fd4c7b9a485d5 /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular-mocks/angular-mocks.js?cc56136dc551d94abe8195cf8475eb27a3aa3c4b /
12 09 2016 22:35:54.454:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:35:54.455:DEBUG [middleware:source-files]: Requesting /base/node_modules/angular/angular.min.js?78069f9f3a9ca9652cb04c13ccb0670d747666b8 /
12 09 2016 22:35:54.455:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-material/angular-material-mocks.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/boot.js
12 09 2016 22:35:54.455:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma-jasmine/lib/adapter.js
12 09 2016 22:35:54.456:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular-mocks/angular-mocks.js
12 09 2016 22:35:54.457:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/node_modules/angular/angular.min.js
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Requesting /absolute/tmp/02002698e6d413a542186462d3a0a6ce.browserify?f4c82dc0618d979f84c89967ea1c412e646a5fe5 /
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Fetching /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:54.458:DEBUG [middleware:source-files]: Requesting /base/js/main.js?41c850cecc07c24d7cd0421e914bd2420671e573 /
12 09 2016 22:35:54.459:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:35:54.460:DEBUG [middleware:source-files]: Requesting /base/test/routes.spec.js?92b15bb7c24bc6ead636994fb1c737b91727d887 /
12 09 2016 22:35:54.461:DEBUG [middleware:source-files]: Fetching /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:35:54.461:DEBUG [web-server]: serving (cached): /tmp/02002698e6d413a542186462d3a0a6ce.browserify
12 09 2016 22:35:54.496:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/js/main.js
12 09 2016 22:35:54.497:DEBUG [web-server]: serving (cached): /home/matthew/Projects/mynewanimalfriend-app/test/routes.spec.js
12 09 2016 22:35:54.497:DEBUG [web-server]: serving: /home/matthew/Projects/mynewanimalfriend-app/node_modules/karma/static/context.js
12 09 2016 22:35:54.582:DEBUG [phantomjs.launcher]: WARNING: Tried to load angular more than once.

PhantomJS 2.1.1 (Linux 0.0.0) LOG: &#39;WARNING: Tried to load angular more than once.&#39;

PhantomJS 2.1.1 (Linux 0.0.0): Executed 1 of 1 SUCCESS (0.004 secs / 0.358 secs)
12 09 2016 22:35:55.003:DEBUG [karma]: Run complete, exiting.
12 09 2016 22:35:55.003:DEBUG [launcher]: Disconnecting all browsers
12 09 2016 22:35:55.003:DEBUG [framework.browserify]: cleaning up
12 09 2016 22:35:55.006:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-html
12 09 2016 22:35:55.078:DEBUG [coverage]: Writing coverage to /home/matthew/Projects/mynewanimalfriend-app/coverage/report-cobertura
12 09 2016 22:35:55.082:DEBUG [launcher]: Process PhantomJS exited with code 0
12 09 2016 22:35:55.082:DEBUG [temp-dir]: Cleaning temp dir /tmp/karma-91342786
12 09 2016 22:35:55.085:DEBUG [launcher]: Finished all browsers
</code></pre>
<p>Our first test has passed. Let’s add tests for the other routes:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Routes&#39;, function () {

  beforeEach(angular.mock.module(&#39;mynewanimalfriend&#39;));
  it(&#39;should map default route to home controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/&#39;].controller).toBe(&#39;HomeCtrl&#39;);
      expect($route.routes[&#39;/&#39;].templateUrl).toEqual(&#39;templates/home.html&#39;);
    });
  });

  it(&#39;should map login route to login controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/login&#39;].controller).toBe(&#39;LoginCtrl&#39;);
      expect($route.routes[&#39;/login&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });

  it(&#39;should map logout route to logout controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[&#39;/logout&#39;].controller).toBe(&#39;LogoutCtrl&#39;);
      expect($route.routes[&#39;/logout&#39;].templateUrl).toEqual(&#39;templates/login.html&#39;);
    });
  });
});
</code></pre>
<p>Note that the logout route uses the login template. This is because all it will do is redirect the user to the login form.</p>
<p>For the sake of brevity I won’t display the test output, but two of these tests should now fail. We can easily set up the new routes in <code>js/main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  });
});
</code></pre>
<p>That’s looking good so far. But what if someone navigates to a URL that doesn’t exist? Our router should handle that. Add this to the test:</p>
<pre><code class="lang-javascript">  it(&#39;should redirect other or empty routes to the home controller&#39;, function () {
    inject(function ($route) {
      expect($route.routes[null].redirectTo).toEqual(&#39;/&#39;)
    });
  });
</code></pre>
<p>Once again, the test should fail. Fixing it is fairly straightforward - we’ll use the <code>otherwise()</code> method to define a fallback route:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Now our routes are in place, we need to implement the three controllers we will need. However, as two of these controllers deal with authentication, we’ll first create some services to handle that, and they’ll need to be tested. Save this as <code>test/services.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Services&#39;, function () {

  beforeEach(function(){
    jasmine.addMatchers({
      toEqualData: function(util, customEqualityTesters) {
        return {
          compare: function(actual, expected) {
            return {
              pass: angular.equals(actual, expected)
            };
          }
        };
      }
    });
  });

  beforeEach(angular.mock.module(&#39;mynewanimalfriend.services&#39;));

  describe(&#39;Token service&#39;, function () {
    var mockBackend, Token;

    beforeEach(inject(function (_Token_, _$httpBackend_) {
      Token = _Token_;
      mockBackend = _$httpBackend_;
    }));

    it(&#39;can create a new token&#39;, function () {
      mockBackend.expectPOST(&#39;http://localhost:8000/api/authenticate&#39;, &#39;{&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;password&quot;}&#39;).respond({token: &#39;mytoken&#39;});
      var token = new Token({
        email: &#39;bob@example.com&#39;,
        password: &#39;password&#39;
      });
      token.$save(function (response) {
        expect(response).toEqualData({token: &#39;mytoken&#39;});
      });
      mockBackend.flush();
    });
  });
});
</code></pre>
<p>In this test we use the <code>$httpBackend</code> facility from <code>ngMock</code> to mock out our API endpoints. We already have a REST API capable of generating a token, and we set this test up to behave similarly. We specify that it should expect to receive a certain POST request, and should respond with the token <code>mytoken</code>. Run the test to make sure it fails, then save this as <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
});
</code></pre>
<p>A little explanation is called for. In Angular, the <code>$resource</code> dependency represents an HTTP resource. By default it supports making HTTP requests to the denoted endpoint via GET, POST and DELETE, and it’s trivial to add support for PUT or PATCH methods. Using <code>$resource</code>, you can easily interface with a RESTful web service, and it’s one of my favourite things about Angular.</p>
<p>We also need to load <code>services.js</code> in our <code>main.js</code> file:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.services&#39;
])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Now, running the tests should show that they pass.</p>
<p>With that in place, we will also create an authentication service that lets the app determine if the user is logged in. Add this to <code>test/services.spec.js</code>:</p>
<pre><code class="lang-javascript">  describe(&#39;Auth service&#39;, function () {
    var Auth;

    beforeEach(inject(function (_Auth_) {
      Auth = _Auth_;
    }));

    it(&#39;can set user&#39;, function () {
      Auth.setUser(&#39;mytoken&#39;);
      var token = localStorage.getItem(&#39;authHeader&#39;);
      expect(token).toEqual(&#39;Bearer mytoken&#39;);
    });

    it(&#39;can return login status&#39;, function () {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer mytoken&#39;);
      expect(Auth.isLoggedIn()).toBeTruthy();
    });

    it(&#39;can log the user out&#39;, function () {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer mytoken&#39;);
      Auth.logUserOut();
      expect(Auth.isLoggedIn()).toBeFalsy();
      expect(localStorage.getItem(&#39;authHeader&#39;)).toBeFalsy();
    });
  });
</code></pre>
<p>This service is expected to do three things:</p>
<ul>
<li>Set the current user’s details in local storage</li>
<li>Return whether the user is logged in</li>
<li>Log the user out</li>
</ul>
<p>Make sure the test fails, then amend <code>js/services.js</code> as follows:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Auth&#39;, function(){
  return{
    setUser : function (aUser) {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer &#39; + aUser);
    },
    isLoggedIn: function () {
      var user = localStorage.getItem(&#39;authHeader&#39;);
      return(user)? user : false;
    },
    logUserOut: function () {
      localStorage.removeItem(&#39;authHeader&#39;);
    }
  }
})

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
});
</code></pre>
<p>When the user is set, we store the authentication details we need in local storage. We can then use that to determine if they are logged in. When they log out, we simply clear local storage,</p>
<p>That should be enough to make these tests pass. Now we can move on to our controllers. We’ll do the login controller first. Save this as <code>test/controllers.spec.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

describe(&#39;Controllers&#39;, function () {

  beforeEach(function(){
    jasmine.addMatchers({
      toEqualData: function(util, customEqualityTesters) {
        return {
          compare: function(actual, expected) {
            return {
              pass: angular.equals(actual, expected)
            };
          }
        };
      }
    });
  });

  beforeEach(angular.mock.module(&#39;mynewanimalfriend.controllers&#39;));

  describe(&#39;Login Controller&#39;, function () {
    var mockBackend, scope;

    beforeEach(inject(function ($rootScope, $controller, _$httpBackend_) {
      mockBackend = _$httpBackend_;
      scope = $rootScope.$new();
      $controller(&#39;LoginCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test doLogin is defined
    it(&#39;should define the login method&#39;, function () {
      expect(scope.doLogin).toBeDefined();
    });

    // Test doLogin works
    it(&#39;should allow the user to log in&#39;, function () {
      // Mock the backend
      mockBackend.expectPOST(&#39;http://localhost:8000/api/authenticate&#39;, &#39;{&quot;email&quot;:&quot;user@example.com&quot;,&quot;password&quot;:&quot;password&quot;}&#39;).respond({token: 123});

      // Define login data
      scope.credentials = {
        email: &#39;user@example.com&#39;,
        password: &#39;password&#39;
      };

      //  Submit the request
      scope.doLogin();

      // Flush the backend
      mockBackend.flush();

      // Check login complete
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(&#39;Bearer 123&#39;);
    });
  });
});
</code></pre>
<p>We check that the scope and the <code>doLogin()</code> method are defined. We then mock the backend’s <code>/api/authenticate</code> route to respond with a dummy token when our credentials are provided. Then, we set the credentials in the variable <code>$scope.credentials</code>, call <code>doLogin()</code>, flush the backend, and check the authentication header has been set.</p>
<p>Once you’ve verified these tests fail, we can start making them pass. Save this as <code>js/controllers.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
});
</code></pre>
<p>The <code>LoginCtrl</code> controller accepts the scope, location, and our two services. When <code>doLogin()</code> is alled, it picks up the values in <code>$scope.credentials</code>, which we will set in our template later. It then makes a POST request to our endpoint including those credentials. Our API backend should return the new token in the response, and the token is stored using the <code>Auth</code> service. Otherwise, it raises an error.</p>
<p>Check the test now passes before moving onto the logout functionality. Add this to <code>test/controllers.spec.js</code>:</p>
<pre><code class="lang-javascript">  describe(&#39;Logout Controller&#39;, function () {
    var scope;

    beforeEach(inject(function ($rootScope, $controller, Auth) {
      Auth.setUser(&#39;Blah&#39;);
      scope = $rootScope.$new();
      $controller(&#39;LogoutCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });

    // Test session cleared
    it(&#39;should clear the session&#39;, function () {
      expect(localStorage.getItem(&#39;authHeader&#39;)).toEqual(null);
    });
  });
</code></pre>
<p>We want to ensure that when the user navigates to the route managed by the <code>LogoutCtrl</code> controller, the session is cleared, so we set up an existing session, call the controller, check it’s defined, and then check that local storage is empty.</p>
<p>Once you’ve verified that the test fails, amend the controllers as follows:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})

.controller(&#39;LogoutCtrl&#39;, function ($scope, $location, Auth) {
  // Log user out
  Auth.logUserOut();

  // Redirect to login page
  $location.path(&#39;/login&#39;);
});
</code></pre>
<p>Our <code>LogoutCtrl</code> controller is very simple - it just logs the user out and redirects them back to the login form. Our final controller is for the home page:</p>
<pre><code class="lang-javascript">  describe(&#39;Home Controller&#39;, function () {
    var scope;

    beforeEach(inject(function ($rootScope, $controller) {
      scope = $rootScope.$new();
      $controller(&#39;HomeCtrl&#39;, {
        $scope: scope
      });
    }));

    // Test controller scope is defined
    it(&#39;should define the scope&#39;, function () {
      expect(scope).toBeDefined();
    });
  });
</code></pre>
<p>For now our home controller does nothing except define the scope, so it’s easy to implement:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;./services&#39;);

angular.module(&#39;mynewanimalfriend.controllers&#39;, [
  &#39;mynewanimalfriend.services&#39;,
  &quot;ngMaterial&quot;
])

.controller(&#39;LoginCtrl&#39;, function ($scope, $location, Token, Auth) {
  $scope.doLogin = function () {
    var token = new Token($scope.credentials);
    token.$save(function (response) {
      if (response.token) {
        // Set up auth service
        Auth.setUser(response.token);

        // Redirect
        $location.path(&#39;/&#39;);
      }
    }, function (err) {
        alert(&#39;Unable to log in - please check your details are correct&#39;);
    });
  };
})

.controller(&#39;LogoutCtrl&#39;, function ($scope, $location, Auth) {
  // Log user out
  Auth.logUserOut();

  // Redirect to login page
  $location.path(&#39;/login&#39;);
})

.controller(&#39;HomeCtrl&#39;, function ($scope) {
});
</code></pre>
<p>Verify that the tests pass, and our controllers are done for now. However, we still have some work to do to hook the various elements up. First, of all, our <code>main.js</code> unnecessarily loads our services - since we only use those services in our controllers, we don’t need them there. We also need to be able to keep users out of routes other than <code>login</code> when not logged in. Here’s what you <code>main.js</code> should look like:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./controllers&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.controllers&#39;
])

.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])

.config([&#39;$httpProvider&#39;, function($httpProvider) {
  $httpProvider.interceptors.push(&#39;sessionInjector&#39;);
  $httpProvider.interceptors.push(&#39;authInterceptor&#39;);
}])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>Note that we set it up to intercept the HTTP request with the session injector and the auth interceptor. Next we need to create these in <code>js/services.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&quot;angular-resource&quot;);

angular.module(&#39;mynewanimalfriend.services&#39;, [&#39;ngResource&#39;])

.factory(&#39;Auth&#39;, function(){
  return{
    setUser : function (aUser) {
      localStorage.setItem(&#39;authHeader&#39;, &#39;Bearer &#39; + aUser);
    },
    isLoggedIn: function () {
      var user = localStorage.getItem(&#39;authHeader&#39;);
      return(user)? user : false;
    },
    logUserOut: function () {
      localStorage.removeItem(&#39;authHeader&#39;);
    }
  }
})

.factory(&#39;Token&#39;, function ($resource) {
  return $resource(&#39;http://localhost:8000/api/authenticate/&#39;);
})

.factory(&#39;sessionInjector&#39;, function (Auth) {
  var sessionInjector = {
    request: function (config) {
      if (Auth.isLoggedIn()) {
        config.headers.Authorization = Auth.isLoggedIn();
      }
      return config;
    }
  };
  return sessionInjector;
})

.service(&#39;authInterceptor&#39;, function ($q, Auth, $location) {
  var service = this;

  service.responseError = function (response) {
    if (response.status == 400) {
      Auth.logUserOut();
      $location.path(&#39;/login&#39;);
    }
    return $q.reject(response);
  };
});
</code></pre>
<p>I’ll walk you through these. <code>sessionInjector</code> adds the authorization HTTP header to every request to the server if the user is logged in, so that it returns the right user’s details. <code>authInterceptor</code> catches any 400 errors, denoting that the user is not authenticated with a current JSON web token, and logs the user out. In this way we can handle the expiry of a user’s token.</p>
<p>Now the logic of our app is in place, but that’s no use without some content…</p>
<h2 id="angular-templating">Angular templating</h2>
<p>We have one very basic HTML template, but that’s just a boilerplate for inserting the rest of our content. For the rest of the HTML we’ll need to load templates dynamically, and we’ll use Angular Material to help us build a nice UI quickly. Run the following commands to create the files:</p>
<pre><code class="lang-bash">$ mkdir www/templates
$ touch www/templates/login.html
$ touch www/templates/home.html
</code></pre>
<p>We need to import the CSS for Angular Material. Add this to <code>sass/style.scss</code>:</p>
<pre><code class="lang-scss">// Angular Material
@import &quot;node_modules/angular-material/angular-material.scss&quot;;
</code></pre>
<p>With that done, we need to configure theming in <code>main.js</code>:</p>
<pre><code class="lang-javascript">&#39;use strict&#39;;

require(&#39;angular&#39;);
require(&#39;angular-route&#39;);
require(&#39;angular-animate&#39;);
require(&#39;angular-material&#39;);
require(&#39;./controllers&#39;);

angular.module(&#39;mynewanimalfriend&#39;, [
  &#39;ngRoute&#39;,
  &#39;ngAnimate&#39;,
  &#39;ngMaterial&#39;,
  &#39;mynewanimalfriend.controllers&#39;
])

.config(function ($mdThemingProvider) {
    $mdThemingProvider.theme(&#39;default&#39;)
      .primaryPalette(&#39;purple&#39;)
      .accentPalette(&#39;cyan&#39;);
})

.run([&#39;$rootScope&#39;, &#39;$location&#39;, &#39;Auth&#39;, function ($rootScope, $location, Auth) {
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event) {

    if (!Auth.isLoggedIn()) {
      if ($location.path() !== &#39;/login&#39;) {
        $location.path(&#39;/login&#39;);
      }
    }
  });
}])

.config([&#39;$httpProvider&#39;, function($httpProvider) {
  $httpProvider.interceptors.push(&#39;sessionInjector&#39;);
  $httpProvider.interceptors.push(&#39;authInterceptor&#39;);
}])

.config(function ($routeProvider) {
  $routeProvider
  .when(&#39;/login&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LoginCtrl&#39;
  })
  .when(&#39;/&#39;, {
    templateUrl: &#39;templates/home.html&#39;,
    controller: &#39;HomeCtrl&#39;
  })
  .when(&#39;/logout&#39;, {
    templateUrl: &#39;templates/login.html&#39;,
    controller: &#39;LogoutCtrl&#39;
  })
  .otherwise({
    redirectTo: &#39;/&#39;
  });
});
</code></pre>
<p>You may want to look at the <a href="https://material.angularjs.org/latest/Theming/01_introduction">documentation</a> for Angular Material to choose your own theme options. Next, let’s create our login template at <code>www/templates/login.html</code>:</p>
<pre><code class="lang-html">&lt;md-content md-theme=&quot;default&quot; layout-gt-sm=&quot;row&quot; layout-padding&gt;
    &lt;div&gt;
        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.email&quot; type=&quot;email&quot;&gt;
        &lt;/md-input-container&gt;

        &lt;md-input-container class=&quot;md-block&quot;&gt;
            &lt;label&gt;Password&lt;/label&gt;
            &lt;input ng-model=&quot;credentials.password&quot; type=&quot;password&quot;&gt;
        &lt;/md-input-container&gt;
        &lt;md-button class=&quot;md-raised md-primary&quot; ng-click=&quot;doLogin()&quot;&gt;Submit&lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-content&gt;
</code></pre>
<p>We’re using Angular Material’s input and button directives to make our inputs look a bit nicer. Note that the <code>ng-click</code> handler calls the <code>doLogin()</code> method of our controller, and that the <code>ng-model</code> attributes contain the <code>credentials</code> object that gets passed to the API. If you haven’t used Angular before, <code>ng-model</code> essentially lets you bind a variable to an element’s value so, for instance, when an input is changed, it can be easily accessed via the variable.</p>
<p>Next, we’ll implement a placeholder for our home page with a log out button. Save this as <code>www/templates/home.html</code>:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;#logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;
</code></pre>
<p>That should be all we need to demonstrate logging in and out of our app. Let’s try it out. First run the Gulp task to show the app in the browser:</p>
<pre><code class="lang-bash">$ gulp
</code></pre>
<p>Then, in another shell session, switch to the directory with the backend and run the server for that:</p>
<pre><code class="lang-bash">$ php artisan serve
</code></pre>
<p>You should already have a user account set up and ready to use thanks to the seeder we wrote. The browser should show the login page by default, and if you fill in the login form and click the button you should see the home page. You should then be able to log out again.</p>
<p>Congratulations! We’ve got authentication working.</p>
<h2 id="switching-to-html5-routing">Switching to HTML5 routing</h2>
<p>You may note that the URLs use hashes - they are in the format <code>http://localhost:5000/#/login</code>. Wouldn’t it be better if we didn’t use the hash? Fortunately modern browsers support this via the HTML5 pushState API, and Angular has built-in support for this.</p>
<p>To enable it, we first need to declare a base URL in <code>www/index.html</code>. Amend it as follows:</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt;
        &lt;title&gt;My New Animal Friend&lt;/title&gt;
        &lt;link href=&quot;/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
        &lt;base href=&quot;/&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div&gt;
        &lt;div ng-app=&quot;mynewanimalfriend&quot; ng-cloak&gt;
            &lt;div ng-view&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;/body&gt;
    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;/js/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>Here we’ve added the <code>&lt;base href=&quot;/&quot;&gt;</code> tag to denote our base URL. Next we configure Angular to use HTML5 routing in <code>main.js</code>:</p>
<pre><code class="lang-javascript">.config(function($locationProvider) {
  $locationProvider.html5Mode(true);
})
</code></pre>
<p>And amend the URL in the home template:</p>
<pre><code class="lang-html">&lt;md-toolbar&gt;
    &lt;div class=&quot;md-toolbar-tools&quot;&gt;
        &lt;md-button aria-label=&quot;Log out&quot; href=&quot;/logout&quot;&gt;
            Log out
        &lt;/md-button&gt;
    &lt;/div&gt;
&lt;/md-toolbar&gt;
</code></pre>
<p>Now, we should be using HTML5 routing throughout.</p>
<p>With that done, we can finish for today. We’ve got our basic app skeleton and authentication system up and running, and we’ll be in a good place to continue developing the rest of the app next time. I’ve put the source code on <a href="https://github.com/matthewbdaly/mynewanimalfriend-app">Github</a>, and you can find this lesson’s work under the <code>lesson-2</code> tag.</p>
<p>Next time we’ll develop the app further, including implementing the pet search functionality.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Phonegap app with Laravel and Angular - Part 1]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/09/11/building-a-phonegap-app-with-laravel-and-angular-part-1/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/09/11/building-a-phonegap-app-with-laravel-and-angular-part-1/">
        </link>
        <updated>2016-09-11T18:33:41Z</updated>
        <summary type="html"><![CDATA[<p>A lot of my work over the last few years has been on Phonegap apps. Phonegap isn’t terribly hard to use, but the difference in context between that and a more conventional web app means that you have to move a lot of functionality to the client side, and unless you’ve used client-side Javascript frameworks before it can be a struggle.</p>
<p>In this series of tutorials I’ll show you how I might build a Phonegap app. The work involved will include:</p>
<ul>
<li>Building a REST API using Laravel to expose the data</li>
<li>Building an admin interface to manage the data</li>
<li>Building a Phonegap app using Angular.js</li>
<li>Testing and deploying it</li>
</ul>
<p>In the process we’ll cover issues like authentication, authorization, real-time notifications and working with REST APIs. Note that we won’t cover the app submission process - you can find plenty of resources on that. We will, however, be using Phonegap Build to build the app.</p>
<h2 id="the-brief">The brief</h2>
<p>Let’s say our new client is an animal shelter. The brief for the app is as follows:</p>
<blockquote>
<p>My New Animal Friend will be an app for finding a new pet. Once a user signs in, they’ll be able to choose what type of pet they’re looking for, then look through a list of pets available to adopt. They can reject them by swiping left or save them by swiping right. They can see more about the ones they swipe right on, and arrange to meet them, from within the app. Users can also message the staff to ask questions about a pet.</p>
</blockquote>
<p>Nice idea, but there’s a lot of work involved! Our very first task is to build the REST API, since everything else relies on that. Before starting, make sure you have the following installed:</p>
<ul>
<li>PHP (I’m using PHP 7, but 5.6 should be fine)</li>
<li>Composer</li>
<li>Git</li>
<li>A compatible relational database (I use PostgreSQL)</li>
<li>Redis</li>
<li>Your usual text editor</li>
<li>Node.js</li>
</ul>
<p>As long as you have this, you should be ready to go. Using <a href="https://laravel.com/docs/5.3/homestead">Homestead</a> is the simplest way to get started if you don’t have all this stuff already.</p>
<h2 id="starting-the-api">Starting the API</h2>
<p>To start building our REST API, run the following command from the shell:</p>
<pre><code class="lang-bash">$ composer create-project --prefer-dist laravel/laravel mynewanimalfriend-backend
</code></pre>
<p>We also have some other dependencies we need to install, so switch into the new directory and run the following command:</p>
<pre><code class="lang-bash">$ composer require barryvdh/laravel-cors tymon/jwt-auth predis/predis
</code></pre>
<p>Next, we need to add the new packages to the Laravel config. Open up <code>config/app.php</code> and add the following to the <code>providers</code> array:</p>
<pre><code class="lang-php">   Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class,                                                                                                                                              
   Barryvdh\Cors\ServiceProvider::class,   
</code></pre>
<p>And the following to the <code>aliases</code> array:</p>
<pre><code class="lang-php">   &#39;JWTAuth&#39; =&gt; Tymon\JWTAuth\Facades\JWTAuth::class,
</code></pre>
<p>We also need to ensure that the CORS middleware is applied to all API routes. Open up <code>app/Http/Kernel.php</code> and under the <code>api</code> array in <code>protected $middlewareGroups</code> paste the following:</p>
<pre><code class="lang-php">   \Barryvdh\Cors\HandleCors::class,
</code></pre>
<p>Now that the packages are included, we can publish the files for them:</p>
<pre><code class="lang-bash">$ php artisan vendor:publish
</code></pre>
<p>Next, we need to set a key for our API authentication:</p>
<pre><code class="lang-bash">$ php artisan jwt:generate
</code></pre>
<p>And set a custom namespace:</p>
<pre><code class="lang-bash">$ php artisan app:name AnimalFriend
</code></pre>
<p>You’ll also want to set up the <code>.env</code> file with the configuration settings for your application. There’s one at <code>.env.example</code> by default that you can copy and customise. Then run the following command to generate the application key:</p>
<pre><code class="lang-bash">$ php artisan key:generate
</code></pre>
<p>I had to change the namespace for the user model in <code>config/jwt.php</code> as well:</p>
<pre><code class="lang-php">    &#39;user&#39; =&gt; &#39;AnimalFriend\User&#39;,
</code></pre>
<p>I also tend to amend the settings in <code>phpunit.xml</code> as follows so that it uses an in-memory SQLite database for tests:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt;
        &lt;env name=&quot;SESSION_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;QUEUE_DRIVER&quot; value=&quot;sync&quot;/&gt;
        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;redis&quot;/&gt;
        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<p>Also, delete <code>tests/ExampleTest.php</code> and amend <code>tests/TestCase.php</code> as follows in order to use database migrations in tests:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

abstract class TestCase extends Illuminate\Foundation\Testing\TestCase
{
    use DatabaseMigrations;

    /**
     * The base URL to use while testing the application.
     *
     * @var string
     */
    protected $baseUrl = &#39;http://localhost&#39;;

    /**
     * Creates the application.
     *
     * @return \Illuminate\Foundation\Application
     */
    public function createApplication()
    {
        $app = require __DIR__.&#39;/../bootstrap/app.php&#39;;

        $app-&gt;make(Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();

        return $app;
    }
}
</code></pre>
<p>With that in place, we can start work on our API proper.</p>
<h2 id="authenticating-our-api">Authenticating our API</h2>
<p>We’re going to start out with a very limited subset of our API. First, we’ll implement the authentication for our app, then we’ll add the facility to view a list of pets or an individual pet. Other functionality will come later. This will be sufficient to get the app working.</p>
<p>First, we need to create our user model. As we’ll be practicing TDD throughout, we write a test for the user model first. Save the following as <code>tests/UserModelTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use AnimalFriend\User;

class UserModelTest extends TestCase
{
    /**
     * Test creating a user
     *
     * @return void
     */
    public function testCreatingAUser()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Verify it works
        $saved = User::where(&#39;email&#39;, &#39;bob@example.com&#39;)-&gt;first();
        $this-&gt;assertEquals($saved-&gt;id, 1);
        $this-&gt;assertEquals($saved-&gt;name, &#39;bobsmith&#39;);
    }
}
</code></pre>
<p>If we run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 169 ms, Memory: 12.00MB

OK (1 test, 3 assertions)
</code></pre>
<p>We already have a perfectly good <code>User</code> model and the appropriate migrations, so our test already passes.</p>
<p>Next, we need to implement the authentication system. Save this as <code>tests/AuthTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class AuthTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test the auth
     *
     * @return void
     */
    public function testAuth()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;password&#39; =&gt; bcrypt(&#39;password&#39;)
        ]);

        // Create request
        $data = array(
            &#39;email&#39; =&gt; $user-&gt;email,
            &#39;password&#39; =&gt; &#39;password&#39;,
        );
        $response = $this-&gt;call(&#39;POST&#39;, &#39;api/authenticate&#39;, $data);
        $this-&gt;assertResponseStatus(200);
        $content = json_decode($response-&gt;getContent());
        $this-&gt;assertTrue(array_key_exists(&#39;token&#39;, $content));
    }

    /**
     * Test the auth when user does not exist
     *
     * @return void
     */
    public function testAuthFailure()
    {
        // Create data for request
        $data = array(
            &#39;email&#39; =&gt; &#39;user@example.com&#39;,
            &#39;password&#39; =&gt; &#39;password&#39;,
        );
        $response = $this-&gt;call(&#39;POST&#39;, &#39;api/authenticate&#39;, $data);

        // Check the status code
        $this-&gt;assertResponseStatus(401);
    }
}
</code></pre>
<p>The first test creates a user and sends an authentication request, then confirms that it returns the JSON Web Token. The second checks that a user that doesn’t exist cannot log in.</p>
<p>Let’s run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

FF.                                                                 3 / 3 (100%)

Time: 328 ms, Memory: 14.00MB

There were 2 failures:

1) AuthTest::testAuth
Expected status code 200, got 404.
Failed asserting that 404 matches expected 200.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/AuthTest.php:29

2) AuthTest::testAuthFailure
Expected status code 401, got 404.
Failed asserting that 404 matches expected 401.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/AuthTest.php:49

FAILURES!
Tests: 3, Assertions: 5, Failures: 2.
</code></pre>
<p>With a failing test in place, we can implement login. First let’s create our controller at <code>app/Http/Controllers/AuthenticateController.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Http\Controllers\Controller;
use JWTAuth;
use Tymon\JWTAuth\Exceptions\JWTException;
use AnimalFriend\User;
use Hash;

class AuthenticateController extends Controller
{
    private $user;

    public function __construct(User $user) {
        $this-&gt;user = $user;
    }

    public function authenticate(Request $request)
    {
        // Get credentials
        $credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);

        // Get user
        $user = $this-&gt;user-&gt;where(&#39;email&#39;, $credentials[&#39;email&#39;])-&gt;first();

        try {
            // attempt to verify the credentials and create a token for the user
            if (! $token = JWTAuth::attempt($credentials)) {
                return response()-&gt;json([&#39;error&#39; =&gt; &#39;invalid_credentials&#39;], 401);
            }
        } catch (JWTException $e) {
            // something went wrong whilst attempting to encode the token
            return response()-&gt;json([&#39;error&#39; =&gt; &#39;could_not_create_token&#39;], 500);
        }

        // all good so return the token
        return response()-&gt;json(compact(&#39;token&#39;));
    }
}
</code></pre>
<p>And we need to set up the route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Http\Request;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| is assigned the &quot;api&quot; middleware group. Enjoy building your API!
|
*/

Route::post(&#39;authenticate&#39;, &#39;AuthenticateController@authenticate&#39;);
</code></pre>
<p>Note that because it’s an API route, it’s automatically prefixed with <code>api/</code> without us having to do anything.</p>
<p>Now if we run our tests, they should pass:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

...                                                                 3 / 3 (100%)

Time: 402 ms, Memory: 14.00MB

OK (3 tests, 6 assertions)
</code></pre>
<p>Now we can obtain a JSON Web Token to authenticate users with. To start with we’ll only support existing users, but later we’ll add a method to sign up. However, we need at least one user to test with, so we’ll create a seeder for that at <code>database/seeds/UserTableSeeder.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class UserTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add user
        DB::table(&#39;users&#39;)-&gt;insert([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
            &#39;password&#39; =&gt; Hash::make(&quot;password&quot;)
        ]);
    }
}
</code></pre>
<p>You can run <code>php artisan make:seeder UserTableSeeder</code> to generate the file, or just paste it in. You also need to amend <code>database/seeds/DatabaseSeeder.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(UserTableSeeder::class);
    }
}
</code></pre>
<p>This ensures the seeder will actually be called. Then, run the following commands:</p>
<pre><code class="lang-bash">$ php artisan migrate
$ php artisan db:seed
</code></pre>
<p>That sets up our user in the database.</p>
<h2 id="adding-the-pets-endpoint">Adding the Pets endpoint</h2>
<p>Our next step is to add the pets model and endpoint. Our <code>Pet</code> model should have the following fields:</p>
<ul>
<li>ID</li>
<li>Timestamps (<code>created_at</code> and <code>updated_at</code>)</li>
<li>Name</li>
<li>Path to photo</li>
<li>Availability</li>
<li>Type (eg cat, dog)</li>
</ul>
<p>Let’s create a test for that model:</p>
<pre><code class="lang-php">&lt;?php

use AnimalFriend\Pet;

class PetModelTest extends TestCase
{
    /**
     * Test creating a pet
     *
     * @return void
     */
    public function testCreatingAPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Verify it works
        $saved = Pet::where(&#39;name&#39;, &#39;Freddie&#39;)-&gt;first();
        $this-&gt;assertEquals($saved-&gt;id, 1);
        $this-&gt;assertEquals($saved-&gt;name, &#39;Freddie&#39;);
        $this-&gt;assertEquals($saved-&gt;type, &#39;Cat&#39;);
        $this-&gt;assertEquals($saved-&gt;available, 1);
        $this-&gt;assertEquals($saved-&gt;picture, &#39;1.jpg&#39;);
    }
}
</code></pre>
<p>Save this as <code>tests/PetModelTest.php</code>. Then run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..E.                                                                4 / 4 (100%)

Time: 414 ms, Memory: 16.00MB

There was 1 error:

1) PetModelTest::testCreatingAUser
InvalidArgumentException: Unable to locate factory with name [default] [AnimalFriend\Pet].

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:126
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:2280
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:139
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:106
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Database/Eloquent/FactoryBuilder.php:84
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetModelTest.php:16

ERRORS!
Tests: 4, Assertions: 6, Errors: 1.
</code></pre>
<p>First we need to create a factory for creating a pet in <code>database/factories/ModelFactory.php</code>:</p>
<pre><code class="lang-php">$factory-&gt;define(AnimalFriend\Pet::class, function (Faker\Generator $faker) {
    return [
        &#39;name&#39; =&gt; $faker-&gt;firstNameMale,
        &#39;type&#39; =&gt; &#39;Cat&#39;,
        &#39;available&#39; =&gt; 1,
        &#39;picture&#39; =&gt; &#39;1.jpg&#39;
    ];
});
</code></pre>
<p>Then, we create the model:</p>
<pre><code class="lang-bash">$ php artisan make:model Pet
</code></pre>
<p>Next, we create a migration for the <code>Pet</code> model:</p>
<pre><code class="lang-bash">$ php artisan make:migration create_pets_table
Created Migration: 2016_09_11_145010_create_pets_table
</code></pre>
<p>And paste in the following code:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreatePetsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create(&#39;pets&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;name&#39;);
            $table-&gt;string(&#39;type&#39;);
            $table-&gt;string(&#39;available&#39;);
            $table-&gt;string(&#39;picture&#39;)-&gt;nullable();
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::drop(&#39;pets&#39;);
    }
}
</code></pre>
<p>Time to run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

....                                                                4 / 4 (100%)

Time: 412 ms, Memory: 16.00MB

OK (4 tests, 12 assertions)
</code></pre>
<p>With that done, we can start work on implementing the endpoint. We need to check that unauthorised users cannot retrieve the data, and that authorised users can. First, let’s create <code>tests/PetControllerTest.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Foundation\Testing\DatabaseMigrations;

class PetControllerTest extends TestCase
{
    use DatabaseMigrations;

    /**
     * Test fetching pets when unauthorised
     *
     * @return void
     */
    public function testFetchingPetsWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets&#39;);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pets when authorised
     *
     * @return void
     */
    public function testFetchingPets()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets&#39;, [], $headers)
            -&gt;seeJsonStructure([
                &#39;*&#39; =&gt; [
                    &#39;id&#39;,
                    &#39;name&#39;,
                    &#39;type&#39;,
                    &#39;available&#39;,
                    &#39;picture&#39;,
                    &#39;created_at&#39;,
                    &#39;updated_at&#39;
                ]
            ]);
        $this-&gt;assertResponseStatus(200);
    }
}
</code></pre>
<p>First, we create a pet, make an HTTP request to <code>/api/pets</code>, and check we are not authorised. Next, we do the same, but also create a user and a JSON Web Token, and pass the token through in the request. Then we verify the response data and that it was successful.</p>
<p>Let’s run the tests:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..FF..                                                              6 / 6 (100%)

Time: 509 ms, Memory: 16.00MB

There were 2 failures:

1) PetControllerTest::testFetchingPetsWhenUnauthorised
Expected status code 400, got 404.
Failed asserting that 404 matches expected 400.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:25

2) PetControllerTest::testFetchingPets
Failed asserting that null is of type &quot;array&quot;.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:295
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:67

FAILURES!
Tests: 6, Assertions: 17, Failures: 2.
</code></pre>
<p>That looks correct, so we can start building our endpoint. We can generate a boilerplate for it as follows:</p>
<pre><code class="lang-bash">$ $ php artisan make:controller PetController --resource
</code></pre>
<p>Note the <code>--resource</code> flag - this tells Laravel to set it up to be a RESTful controller with certain predefined functions. Next, let’s amend the new file at <code>app\Http\Controllers/PetController.php</code> as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace AnimalFriend\Http\Controllers;

use Illuminate\Http\Request;

use AnimalFriend\Http\Requests;
use AnimalFriend\Pet;

class PetController extends Controller
{
    private $pet;

    public function __construct(Pet $pet) {
        $this-&gt;pet = $pet;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        // Get all pets
        $pets = $this-&gt;pet-&gt;get();

        // Send response
        return response()-&gt;json($pets, 200);
    }
}
</code></pre>
<p>This implements an index route that shows all pets. Next, we hook up the route in <code>routes/api.php</code>:</p>
<pre><code class="lang-php">// Auth routes
Route::group([&#39;middleware&#39; =&gt; [&#39;jwt.auth&#39;]], function () {
    Route::resource(&#39;pets&#39;, &#39;PetController&#39;);
});
</code></pre>
<p>Note that we wrap this resource in the <code>jwt.auth</code> middleware to prevent access by unauthorised users. Implementing this as middleware makes it very easy to reuse. Also note that we can specify it as a resource, meaning we don’t have to explicitly hook up each route to a controller method.</p>
<p>Let’s run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

..EE..                                                              6 / 6 (100%)

Time: 511 ms, Memory: 16.00MB

There were 2 errors:

1) PetControllerTest::testFetchingPetsWhenUnauthorised
ReflectionException: Class jwt.auth does not exist

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:734
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:629
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Application.php:709
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:173
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:517
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:24

2) PetControllerTest::testFetchingPets
ReflectionException: Class jwt.auth does not exist

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:734
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Container/Container.php:629
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Application.php:709
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:173
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:517
/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:72
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:56

ERRORS!
Tests: 6, Assertions: 15, Errors: 2.
</code></pre>
<p>Looks like JWT isn’t configured correctly. We can fix that in <code>app/Http/Kernel.php</code> by adding it to <code>$routeMiddleware</code>:</p>
<pre><code class="lang-php">        &#39;jwt.auth&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\GetUserFromToken&#39;,
        &#39;jwt.refresh&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\RefreshToken&#39;,
</code></pre>
<p>And run the tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

......                                                              6 / 6 (100%)

Time: 514 ms, Memory: 16.00MB

OK (6 tests, 25 assertions)
</code></pre>
<p>Our final task for today on the API is building a route for fetching a single pet. Our tests need to handle three situations:</p>
<ul>
<li>An unauthorised request</li>
<li>A request for a pet that does not exist</li>
<li>A request for a pet that does exist</li>
</ul>
<p>Add these methods to <code>tests/PetControllerTest.php</code>:</p>
<pre><code class="lang-php">    /**
     * Test fetching pet when unauthorised
     *
     * @return void
     */
    public function testFetchingPetWhenUnauthorised()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Send request
        $response = $this-&gt;call(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id);
        $this-&gt;assertResponseStatus(400);
    }

    /**
     * Test fetching pet which does not exist
     *
     * @return void
     */
    public function testFetchingPetDoesNotExist()
    {
        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/1&#39;, [], $headers);
        $this-&gt;assertResponseStatus(404);
    }

    /**
     * Test fetching pet when authorised
     *
     * @return void
     */
    public function testFetchingPet()
    {
        // Create a Pet
        $pet = factory(AnimalFriend\Pet::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;Freddie&#39;,
            &#39;type&#39; =&gt; &#39;Cat&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;pets&#39;, [&#39;type&#39; =&gt; &#39;Cat&#39;]);

        // Create a User
        $user = factory(AnimalFriend\User::class)-&gt;create([
            &#39;name&#39; =&gt; &#39;bobsmith&#39;,
            &#39;email&#39; =&gt; &#39;bob@example.com&#39;,
        ]);
        $this-&gt;seeInDatabase(&#39;users&#39;, [&#39;email&#39; =&gt; &#39;bob@example.com&#39;]);

        // Create request
        $token = JWTAuth::fromUser($user);
        $headers = array(
            &#39;Authorization&#39; =&gt; &#39;Bearer &#39;.$token
        );

        // Send it
        $this-&gt;json(&#39;GET&#39;, &#39;/api/pets/&#39;.$pet-&gt;id, [], $headers)
            -&gt;seeJsonStructure([
                &#39;id&#39;,
                &#39;name&#39;,
                &#39;type&#39;,
                &#39;available&#39;,
                &#39;picture&#39;,
                &#39;created_at&#39;,
                &#39;updated_at&#39;
            ]);
        $this-&gt;assertResponseStatus(200);
    }
</code></pre>
<p>Let’s check our tests fail:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.....FE..                                                           9 / 9 (100%)

Time: 974 ms, Memory: 16.00MB

There was 1 error:

1) PetControllerTest::testFetchingPet
PHPUnit_Framework_Exception: Argument #2 (No Value) of PHPUnit_Framework_Assert::assertArrayHasKey() must be a array or ArrayAccess

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:304
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:145

--

There was 1 failure:

1) PetControllerTest::testFetchingPetDoesNotExist
Expected status code 404, got 400.
Failed asserting that 400 matches expected 404.

/home/matthew/Projects/mynewanimalfriend-backend/vendor/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php:648
/home/matthew/Projects/mynewanimalfriend-backend/tests/PetControllerTest.php:112

ERRORS!
Tests: 9, Assertions: 31, Errors: 1, Failures: 1.
</code></pre>
<p>Now, we already have the <code>show()</code> method hooked up by default, so we just have to implement it in <code>app/Http/Controllers/PetController.php</code>:</p>
<pre><code class="lang-php">    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id)
    {
        // Get pet
        $pet = $this-&gt;pet-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($pet, 200);
    }
</code></pre>
<p>And let’s run our tests again:</p>
<pre><code class="lang-bash">$ vendor/bin/phpunit 
PHPUnit 5.5.4 by Sebastian Bergmann and contributors.

.........                                                           9 / 9 (100%)

Time: 693 ms, Memory: 16.00MB

OK (9 tests, 39 assertions)
</code></pre>
<p>Now we have all the endpoints we need to get started with the app. You can find the source code for this backend on <a href="https://github.com/matthewbdaly/mynewanimalfriend-backend">Github</a> - check out the <code>lesson-1</code> tag.</p>
<p>That seems like a good place to stop for now. We have our first pass at the back end. It’s not complete by any means, but it’s a good start, and is sufficient for us to get some basic functionality up and running in the app. In the next instalment we’ll start working with Phonegap to build the first pass at the app itself. Later instalments will see us working with both the app and backend to build it into a more useful whole.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deploying new versions of a Laravel app with Fabric]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/09/05/deploying-new-versions-of-a-laravel-app-with-fabric/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/09/05/deploying-new-versions-of-a-laravel-app-with-fabric/">
        </link>
        <updated>2016-09-05T21:22:16Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://laravel.com/docs/5.3/envoy">Envoy</a> is the official way to run tasks on a remote server for Laravel apps. A typical Envoy task for deploying a new version might look like this:</p>
<pre><code class="lang-blade">@servers([&#39;web&#39; =&gt; &#39;matthew@server1.example.com&#39;])

@task(&#39;deploy&#39;, [&#39;on&#39; =&gt; &#39;web&#39;])
    cd /var/www
    sudo chown -R matthew:matthew .
    git pull origin master
    php artisan migrate
    php artisan view:clear
    composer dump-autoload
    sudo chown -R www-data:www-data .
    sudo supervisorctl restart mail-queue
@endtask
</code></pre>
<p>This would be defined in <code>Envoy.blade.php</code>. With this in place, and Envoy set up globally, you can then run <code>envoy run deploy</code> to run the <code>deploy</code> command.</p>
<p>However, Envoy requires the PHP SSH library, which I haven’t been able to get working with PHP 7. Fortunately I was already familiar with <a href="http://www.fabfile.org/">Fabric</a>, which makes an excellent alternative as long as you don’t mind writing the task in Python.</p>
<p>The same kind of task might look like this in a Fabric script, saved as <code>fabfile.py</code>:</p>
<pre><code class="lang-python">#!/usr/bin/env python
from fabric.api import local, env, run, sudo
from fabric.context_managers import cd, prefix

env.hosts = [&#39;server1.example.com&#39;]
env.path = &quot;/var/www&quot;
env.user = &quot;matthew&quot;
env.password = &quot;password&quot;
# Or...
env.key_filename = &#39;/path/to/ssh/key&#39;

def deploy():
    &quot;&quot;&quot;
    Deploy the latest version
    &quot;&quot;&quot;
    # Push changes to Bitbucket
    local(&quot;git push origin master&quot;)

    # Switch to project directory
    with cd(env.path):
        # Change owner
        sudo(&#39;chown -R matthew:matthew .&#39;)

        # Pull changes to server
        run(&#39;git pull origin master&#39;)

        # Run migrations
        run(&#39;php artisan migrate&#39;)

        # Clear cached files
        run(&#39;php artisan view:clear&#39;)
        run(&#39;composer dump-autoload&#39;)

        # Change owner back
        sudo(&#39;chown -R www-data:www-data .&#39;)

        # restart mail queue
        sudo(&#39;supervisorctl restart mail-queue&#39;)
</code></pre>
<p>Then, assuming Fabric is already installed locally, you can run <code>fab deploy</code> to push up the latest revision.</p>
<p>Either of these solutions will do a fine job of deploying your app. If you do need to store user-specific data in your Fabric script, it’s probably prudent to keep it out of version control.</p>
<p>Whichever way you choose, it’s a really good idea to do what you can to automate deployment. It can be a boring, repetitive job, and both of these solutions make it much easier.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Testing your API documentation with Dredd]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/08/08/testing-your-api-documentation-with-dredd/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/08/08/testing-your-api-documentation-with-dredd/">
        </link>
        <updated>2016-08-08T16:05:00Z</updated>
        <summary type="html"><![CDATA[<p>Documenting your API is something most developers agree is generally a Good Thing, but it’s a pain in the backside, and somewhat boring to do. What you really need is a tool that allows you to specify the details of your API before you start work, generate documentation from that specification, and test your implementation against that specification.</p>
<p>Fortunately, such a tool exists. The <a href="https://apiblueprint.org/">Blueprint</a> specification allows you to document your API using a Markdown-like syntax. You can then create HTML documentation using a tool like <a href="https://github.com/danielgtaylor/aglio">Aglio</a> or <a href="https://apiary.io/">Apiary</a>, and test it against your implementation using <a href="https://github.com/apiaryio/dredd">Dredd</a>.</p>
<p>In this tutorial we’ll implement a very basic REST API using the Lumen framework. We’ll first specify our API, then we’ll implement routes to match the implementation. In the process, we’ll demonstrate the Blueprint specification in action.</p>
<h2 id="getting-started">Getting started</h2>
<p>Assuming you already have PHP 5.6 or better and Composer installed, run the following command to create our Lumen app skeleton:</p>
<pre><code class="lang-bash">$ composer create-project --prefer-dist laravel/lumen demoapi
</code></pre>
<p>Once it has finished installing, we’ll also need to add the Dredd hooks:</p>
<pre><code class="lang-bash">$ cd demoapi
$ composer require ddelnano/dredd-hooks-php
</code></pre>
<p>We need to install Dredd. It’s a Node.js tool, so you’ll need to have that installed. We’ll also install Aglio to generate HTML versions of our documentation:</p>
<pre><code class="lang-bash">$ npm install -g aglio dredd
</code></pre>
<p>We also need to create a configuration file for Dredd, which you can do by running <code>dredd init</code>. Or you can just copy the one below:</p>
<pre><code class="lang-yml">dry-run: null
hookfiles: null
language: php
sandbox: false
server: &#39;php -S localhost:3000 -t public/&#39;
server-wait: 3
init: false
custom:
  apiaryApiKey: &#39;&#39;
names: false
only: []
reporter: apiary
output: []
header: []
sorted: false
user: null
inline-errors: false
details: false
method: []
color: true
level: info
timestamp: false
silent: false
path: []
hooks-worker-timeout: 5000
hooks-worker-connect-timeout: 1500
hooks-worker-connect-retry: 500
hooks-worker-after-connect-wait: 100
hooks-worker-term-timeout: 5000
hooks-worker-term-retry: 500
hooks-worker-handler-host: localhost
hooks-worker-handler-port: 61321
config: ./dredd.yml
blueprint: apiary.apib
endpoint: &#39;http://localhost:3000&#39;
</code></pre>
<p>If you choose to run <code>dredd init</code>, you’ll see prompts for a number of things, including:</p>
<ul>
<li>The server command</li>
<li>The blueprint file name</li>
<li>The endpoint</li>
<li>Any Apiary API key</li>
<li>The language you want to use</li>
</ul>
<p>There are Dredd hooks for many languages, so if you’re planning on building a REST API in a language other than PHP, don’t worry - you can still test it with Dredd, you’ll just get prompted to install different hooks.</p>
<p>Note the <code>hookfiles</code> section, which specifies a hookfile to run during the test in order to set up the API. We’ll touch on that in a moment. Also, note the <code>server</code> setting - this specifies the command we should call to run the server. In this case we’re using the PHP development server.</p>
<p>If you’re using Apiary with your API (which I highly recommend), you can also set the following parameter to ensure that every time you run Dredd, it submits the results to Apiary:</p>
<pre><code class="lang-yml">custom:
  apiaryApiKey: &lt;API KEY HERE&gt;
  apiaryApiName: &lt;API NAME HERE&gt;
</code></pre>
<h2 id="hookfiles">Hookfiles</h2>
<p>As mentioned, the hooks allow you to set up your API. In our case, we’ll need to set up some fixtures for our tests.  Save this file at <code>tests/dredd/hooks/hookfile.php</code>:</p>
<pre><code class="lang-php">&lt;?php

use Dredd\Hooks;
use Illuminate\Support\Facades\Artisan;

require __DIR__ . &#39;/../../../vendor/autoload.php&#39;;

$app = require __DIR__ . &#39;/../../../bootstrap/app.php&#39;;

$app-&gt;make(\Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();

Hooks::beforeAll(function (&amp;$transaction) use ($app) {
   putenv(&#39;DB_CONNECTION=sqlite&#39;);
   putenv(&#39;DB_DATABASE=:memory:&#39;);
   Artisan::call(&#39;migrate:refresh&#39;);
   Artisan::call(&#39;db:seed&#39;);
});
Hooks::beforeEach(function (&amp;$transaction) use ($app) {
   Artisan::call(&#39;migrate:refresh&#39;);
   Artisan::call(&#39;db:seed&#39;);
});
</code></pre>
<p>Before the tests run, we set the environment up to use an in-memory SQLite database. We also migrate and seed the database, so we’re working with a clean database. As part of this tutorial, we’ll create seed files for the fixtures we need in the database.</p>
<p>This hookfile assumes that the user does not need to be authenticated to communicate with the API. If that’s not the case for your API, you may want to include something like this in your hookfile’s <code>beforeEach</code> callback:</p>
<pre><code class="lang-php">   $user = App\User::first();
   $token = JWTAuth::fromUser($user);
   $transaction-&gt;request-&gt;headers-&gt;Authorization = &#39;Bearer &#39; . $token;
</code></pre>
<p>Here we’re using the <a href="https://github.com/tymondesigns/jwt-auth">JWT Auth</a> package for Laravel to authenticate users of our API, and we need to set the <code>Authorization</code> header to contain a valid JSON web token for the given user. If you’re using a different method, such as HTTP Basic authentication, you’ll need to amend this code to reflect that.</p>
<p>With that done, we need to create the Blueprint file for our API. Recall the following line in <code>dredd.yml</code>:</p>
<pre><code class="lang-yml">blueprint: apiary.apib
</code></pre>
<p>This specifies the path to our documentation. Let’s create that file:</p>
<pre><code class="lang-bash">$ touch apiary.apib
</code></pre>
<p>Once this is done, you should be able to run Dredd:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
warn: Parser warning in file &#39;apiary.apib&#39;: (warning code undefined) Could not recognize API description format. Falling back to API Blueprint by default.
info: Beginning Dredd testing...
complete: Tests took 619ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/4aab4155-cfc4-4fda-983a-fea280933ad4
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>With that done, we’re ready to start work on our API.</p>
<h2 id="our-first-route">Our first route</h2>
<p>Dredd is not a testing tool in the usual sense. Under no circumstances should you use it as a substitute for something like PHPUnit - that’s not what it’s for. It’s for ensuring that your documentation and your implementation remain in sync. However, it’s not entirely impractical to use it as a Behaviour-driven development tool in the same vein as Cucumber or Behat - you can use it to plan out the endpoints your API will have, the requests they accept, and the responses they return, and then verify your implementation against the documentation.</p>
<p>We will only have a single endpoint, in order to keep this tutorial as simple and concise as possible. Our endpoint will expose products for a shop, and will allow users to fetch, create, edit and delete products. Note that we won’t be implementing any kind of authentication, which in production is almost certainly not what you want - we’re just going for the simplest possible implementation.</p>
<p>First, we’ll implement getting a list of products:</p>
<pre><code class="lang-markdown">FORMAT: 1A

# Demo API

# Products [/api/products]
Product object representation

## Get products [GET /api/products]
Get a list of products

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
                &quot;id&quot;: 1,
                &quot;name&quot;: &quot;Purple widget&quot;,
                &quot;description&quot;: &quot;A purple widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: {
                    &quot;colour&quot;: &quot;Purple&quot;,
                    &quot;size&quot;: &quot;Small&quot;
                }
            }
</code></pre>
<p>A little explanation is called for. First the <code>FORMAT</code> section denotes the version of the API. Then, the <code># Demo API</code> section denotes the name of the API.</p>
<p>Next, we define the <code>Products</code> endpoint, followed by our first method. Then we define what should be contained in the request, and what the response should look like. Blueprint is a little more complex than that, but that’s sufficient to get us started.</p>
<p>Then we run <code>dredd</code> again:</p>
<pre><code class="lang-bash">$ dredd.yml
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
fail: GET /api/products duration: 61ms
info: Displaying failed tests...
fail: GET /api/products duration: 61ms
fail: headers: Header &#39;content-type&#39; has value &#39;text/html; charset=UTF-8&#39; instead of &#39;application/json&#39;
body: Can&#39;t validate real media type &#39;text/plain&#39; against expected media type &#39;application/json&#39;.
statusCode: Status code is not &#39;200&#39;

request: 
method: GET
uri: /api/products
headers: 
    Content-Type: application/json
    User-Agent: Dredd/1.5.0 (Linux 4.4.0-31-generic; x64)

body: 



expected: 
headers: 
    Content-Type: application/json

body: 
{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Purple widget&quot;,
  &quot;description&quot;: &quot;A purple widget&quot;,
  &quot;price&quot;: 5.99,
  &quot;attributes&quot;: {
    &quot;colour&quot;: &quot;Purple&quot;,
    &quot;size&quot;: &quot;Small&quot;
  }
}
statusCode: 200


actual: 
statusCode: 404
headers: 
    host: localhost:3000
    connection: close
    x-powered-by: PHP/7.0.8-0ubuntu0.16.04.2
    cache-control: no-cache
    date: Mon, 08 Aug 2016 10:30:33 GMT
    content-type: text/html; charset=UTF-8

body: 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt;
        &lt;style&gt;
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:&#39;&#39;;}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}
            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
                        .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; cursor: default; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, &quot;Times New Roman&quot;, Times, serif }
            .sf-reset .exception_counter { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; float: left; display: block; }
            .sf-reset .exception_title { margin-left: 3em; margin-bottom: 0.7em; display: block; }
            .sf-reset .exception_message { margin-left: 3em; display: block; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset a { background:none; color:#868686; text-decoration:none; }
            .sf-reset a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
                    &lt;div id=&quot;sf-resetcontent&quot; class=&quot;sf-reset&quot;&gt;
                &lt;h1&gt;Sorry, the page you are looking for could not be found.&lt;/h1&gt;
                                        &lt;h2 class=&quot;block_exception clear_fix&quot;&gt;
                            &lt;span class=&quot;exception_counter&quot;&gt;1/1&lt;/span&gt;
                            &lt;span class=&quot;exception_title&quot;&gt;&lt;abbr title=&quot;Symfony\Component\HttpKernel\Exception\NotFoundHttpException&quot;&gt;NotFoundHttpException&lt;/abbr&gt; in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 450&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 450&lt;/a&gt;:&lt;/span&gt;
                            &lt;span class=&quot;exception_message&quot;&gt;&lt;/span&gt;
                        &lt;/h2&gt;
                        &lt;div class=&quot;block&quot;&gt;
                            &lt;ol class=&quot;traces list_exception&quot;&gt;
       &lt;li&gt; in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 450&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 450&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;handleDispatcherResponse(&lt;em&gt;array&lt;/em&gt;(&#39;0&#39;)) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 387&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 387&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;Laravel\Lumen\Concerns\{closure}() in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 636&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 636&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;sendThroughPipeline(&lt;em&gt;array&lt;/em&gt;(), &lt;em&gt;object&lt;/em&gt;(&lt;abbr title=&quot;Closure&quot;&gt;Closure&lt;/abbr&gt;)) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 389&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 389&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;dispatch(&lt;em&gt;null&lt;/em&gt;) in &lt;a title=&quot;/home/matthew/Projects/demoapi/vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php line 334&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;RoutesRequests.php line 334&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;at &lt;abbr title=&quot;Laravel\Lumen\Application&quot;&gt;Application&lt;/abbr&gt;-&gt;run() in &lt;a title=&quot;/home/matthew/Projects/demoapi/public/index.php line 28&quot; ondblclick=&quot;var f=this.innerHTML;this.innerHTML=this.title;this.title=f;&quot;&gt;index.php line 28&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;

            &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;



complete: 0 passing, 1 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 533ms
[Mon Aug  8 11:30:33 2016] 127.0.0.1:44472 [404]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/0153d5bf-6efa-4fdb-b02a-246ddd75cb14
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Our route is returning HTML, not JSON, and is also raising a 404 error. So let’s fix that. First, let’s create our <code>Product</code> model at <code>app/Product.php</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    //
}
</code></pre>
<p>Next, we need to create a migration for the database tables for the <code>Product</code> model:</p>
<pre><code class="lang-bash">$ php artisan make:migration create_product_table
Created Migration: 2016_08_08_105737_create_product_table
</code></pre>
<p>This will create a new file under <code>database/migrations</code>. Open this file and paste in the following:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateProductTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // Create products table
        Schema::create(&#39;products&#39;, function (Blueprint $table) {
            $table-&gt;increments(&#39;id&#39;);
            $table-&gt;string(&#39;name&#39;);
            $table-&gt;text(&#39;description&#39;);
            $table-&gt;float(&#39;price&#39;);
            $table-&gt;json(&#39;attributes&#39;);
            $table-&gt;timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Drop products table
        Schema::drop(&#39;products&#39;);
    }
}
</code></pre>
<p>Note that we create fields that map to the attributes our API exposes. Also, note the use of the JSON field. In databases that support it, like PostgreSQL, it uses the native JSON support, otherwise it works like a text field. Next, we run the migration to create the table:</p>
<pre><code class="lang-bash">$ php artisan migrate
Migrated: 2016_08_08_105737_create_product_table
</code></pre>
<p>With our model done, we now need to ensure that when Dredd runs, there is some data in the database, so we’ll create a seeder file at <code>database/seeds/ProductSeeder</code>:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;
use Carbon\Carbon;

class ProductSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // Add product
        DB::table(&#39;products&#39;)-&gt;insert([
            &#39;name&#39; =&gt; &#39;Purple widget&#39;,
            &#39;description&#39; =&gt; &#39;A purple widget&#39;,
            &#39;price&#39; =&gt; 5.99,
            &#39;attributes&#39; =&gt; json_encode([
                &#39;colour&#39; =&gt; &#39;purple&#39;,
                &#39;size&#39; =&gt; &#39;Small&#39;
            ]),
            &#39;created_at&#39; =&gt; Carbon::now(),
            &#39;updated_at&#39; =&gt; Carbon::now(),
        ]);
    }
}
</code></pre>
<p>You also need to amend <code>database/seeds/DatabaseSeeder</code> to call it:</p>
<pre><code class="lang-php">&lt;?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $this-&gt;call(&#39;ProductSeeder&#39;);
    }
}
</code></pre>
<p>I found I also had to run the following command to find the new seeder:</p>
<pre><code class="lang-bash">$ composer dump-autoload
</code></pre>
<p>Then, call the seeder:</p>
<pre><code class="lang-bash">$ php artisan db:seed
Seeded: ProductSeeder
</code></pre>
<p>We also need to enable Eloquent, as Lumen disables it by default. Uncomment the following line in <code>bootstrap/app.php</code>:</p>
<pre><code class="lang-php">$app-&gt;withEloquent();
</code></pre>
<p>With that done, we can move onto the controller.</p>
<h2 id="creating-the-controller">Creating the controller</h2>
<p>Create the following file at <code>app/Http/Controllers/ProductController</code>:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Product;

class ProductController extends Controller
{
    private $product;

    public function __construct(Product $product) {
        $this-&gt;product = $product;
    }

    public function index()
    {
        // Get all products
        $products = $this-&gt;product-&gt;all();

        // Send response
        return response()-&gt;json($products, 200);
    }
}
</code></pre>
<p>This implements the <code>index</code> route. Note that we inject the <code>Product</code> instance into the controller. Next, we need to hook it up in <code>app/Http/routes.php</code>:</p>
<pre><code class="lang-php">&lt;?php

/*
|--------------------------------------------------------------------------
| Application Routes
|--------------------------------------------------------------------------
|
| Here is where you can register all of the routes for an application.
| It is a breeze. Simply tell Lumen the URIs it should respond to
| and give it the Closure to call when that URI is requested.
|
*/

$app-&gt;get(&#39;/api/products&#39;, &#39;ProductController@index&#39;);
</code></pre>
<p>Then we run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
[Mon Aug  8 12:36:28 2016] 127.0.0.1:45466 [200]: /api/products
fail: GET /api/products duration: 131ms
info: Displaying failed tests...
fail: GET /api/products duration: 131ms
fail: body: At &#39;&#39; Invalid type: array (expected object)

request: 
method: GET
uri: /api/products
headers: 
    Content-Type: application/json
    User-Agent: Dredd/1.5.0 (Linux 4.4.0-31-generic; x64)

body: 



expected: 
headers: 
    Content-Type: application/json

body: 
{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Purple widget&quot;,
  &quot;description&quot;: &quot;A purple widget&quot;,
  &quot;price&quot;: 5.99,
  &quot;attributes&quot;: {
    &quot;colour&quot;: &quot;Purple&quot;,
    &quot;size&quot;: &quot;Small&quot;
  }
}
statusCode: 200


actual:
statusCode: 200
headers:
    host: localhost:3000
    connection: close
    x-powered-by: PHP/7.0.8-0ubuntu0.16.04.2
    cache-control: no-cache
    content-type: application/json
    date: Mon, 08 Aug 2016 11:36:28 GMT

body:
[ 
  { 
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Purple widget&quot;,
    &quot;description&quot;: &quot;A purple widget&quot;,
    &quot;price&quot;: &quot;5.99&quot;,
    &quot;attributes&quot;: &quot;{\&quot;colour\&quot;:\&quot;purple\&quot;,\&quot;size\&quot;:\&quot;Small\&quot;}&quot;,
    &quot;created_at&quot;: &quot;2016-08-08 11:32:24&quot;,
    &quot;updated_at&quot;: &quot;2016-08-08 11:32:24&quot;
  }
]



complete: 0 passing, 1 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 582ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/83da2d67-c846-4356-a3b8-4d7c32daa7ef
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Whoops, looks like we made a mistake here. The index route returns an array of objects, but we’re looking for a single object in the blueprint. We also need to wrap our attributes in quotes, and add the <code>created_at</code> and <code>updated_at</code> attributes. Let’s fix the blueprint:</p>
<pre><code class="lang-markdown">FORMAT: 1A

# Demo API

# Products [/api/products]
Product object representation

## Get products [GET /api/products]
Get a list of products

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            [
                {
                    &quot;id&quot;: 1,
                    &quot;name&quot;: &quot;Purple widget&quot;,
                    &quot;description&quot;: &quot;A purple widget&quot;,
                    &quot;price&quot;: 5.99,
                    &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;Purple\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
                    &quot;created_at&quot;: &quot;*&quot;,
                    &quot;updated_at&quot;: &quot;*&quot;
                }
            ]
</code></pre>
<p>Let’s run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 65ms
complete: 1 passing, 0 failing, 0 errors, 0 skipped, 1 total
complete: Tests took 501ms
[Mon Aug  8 13:05:54 2016] 127.0.0.1:45618 [200]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/7c23d4ae-aff2-4daf-bbdf-9fd76fc58b97
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>And now we can see that our test passes.</p>
<p>Next, we’ll implement a test for fetching a single product:</p>
<pre><code class="lang-markdown">## Get a product [GET /api/products/1]
Get a single product

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
              &quot;id&quot;: 1,
              &quot;name&quot;: &quot;Purple widget&quot;,
              &quot;description&quot;: &quot;A purple widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;Purple\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>Note the same basic format - we define the URL that should be fetched, the content of the request, and the response, including the status code.</p>
<p>Let’s hook up our route in <code>app/Http/routes.php</code>:</p>
<pre><code class="lang-php">$app-&gt;get(&#39;/api/products/{id}&#39;, &#39;ProductController@show&#39;);
</code></pre>
<p>And add the <code>show()</code> method to the controller:</p>
<pre><code class="lang-php">    public function show($id)
    {
        // Get individual product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Send response
        return response()-&gt;json($product, 200);
    }
</code></pre>
<p>Running Dredd again should show this method has been implemented:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 66ms
[Mon Aug  8 13:21:31 2016] 127.0.0.1:45750 [200]: /api/products
pass: GET /api/products/1 duration: 17ms
complete: 2 passing, 0 failing, 0 errors, 0 skipped, 2 total
complete: Tests took 521ms
[Mon Aug  8 13:21:31 2016] 127.0.0.1:45752 [200]: /api/products/1
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/bb6d03c3-8fad-477c-b140-af6e0cc8b96c
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>That’s our read support done. We just need to add support for <code>POST</code>, <code>PATCH</code> and <code>DELETE</code> methods.</p>
<h2 id="our-remaining-methods">Our remaining methods</h2>
<p>Let’s set up the test for our <code>POST</code> method first:</p>
<pre><code class="lang-markdown">## Create products [POST /api/products]
Create a new product

+ name (string) - The product name
+ description (string) - The product description
+ price (float) - The product price
+ attributes (string) - The product attributes

+ Request (application/json)
    + Body

            {
                &quot;name&quot;: &quot;Blue widget&quot;,
                &quot;description&quot;: &quot;A blue widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;
            }

+ Response 201 (application/json)
    + Body

            {
              &quot;id&quot;: 2,
              &quot;name&quot;: &quot;Blue widget&quot;,
              &quot;description&quot;: &quot;A blue widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>Note we specify the format of the parameters that should be passed through, and that our status code should be 201, not 200 - this is arguably a more correct choice for creating a resource. Be careful of the whitespace - I had some odd issues with it. Next, we add our route:</p>
<pre><code class="lang-php">$app-&gt;post(&#39;/api/products&#39;, &#39;ProductController@store&#39;);
</code></pre>
<p>And the <code>store()</code> method in the controller:</p>
<pre><code class="lang-php">    public function store(Request $request)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;name&#39; =&gt; &#39;required|string&#39;,
            &#39;description&#39; =&gt; &#39;required|string&#39;,
            &#39;price&#39; =&gt; &#39;required|numeric&#39;,
            &#39;attributes&#39; =&gt; &#39;string&#39;,
        ]);

        // Create product
        $product = new $this-&gt;product;
        $product-&gt;name = $request-&gt;input(&#39;name&#39;);
        $product-&gt;description = $request-&gt;input(&#39;description&#39;);
        $product-&gt;price = $request-&gt;input(&#39;price&#39;);
        $product-&gt;attributes = $request-&gt;input(&#39;attributes&#39;);

        // Save product
        $product-&gt;save();

        // Send response
        return response()-&gt;json($product, 201);
    }
</code></pre>
<p>Note that we validate the attributes, to ensure they are correct and that the required ones exist. Running Dredd again should show the route is now in place:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 69ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47316 [200]: /api/products
pass: GET /api/products/1 duration: 18ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47318 [200]: /api/products/1
pass: POST /api/products duration: 42ms
complete: 3 passing, 0 failing, 0 errors, 0 skipped, 3 total
complete: Tests took 575ms
[Mon Aug  8 15:17:35 2016] 127.0.0.1:47322 [201]: /api/products
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/cb5971cf-180d-47ed-abf4-002378941134
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Next, we’ll implement <code>PATCH</code>. This targets an existing object, but accepts parameters in the same way as <code>POST</code>:</p>
<pre><code class="lang-markdown">## Update existing products [PATCH /api/products/1]
Update an existing product

+ name (string) - The product name
+ description (string) - The product description
+ price (float) - The product price
+ attributes (string) - The product attributes

+ Request (application/json)
    + Body

            {
                &quot;name&quot;: &quot;Blue widget&quot;,
                &quot;description&quot;: &quot;A blue widget&quot;,
                &quot;price&quot;: 5.99,
                &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;
            }

+ Response 200 (application/json)
    + Body

            {
              &quot;id&quot;: 2,
              &quot;name&quot;: &quot;Blue widget&quot;,
              &quot;description&quot;: &quot;A blue widget&quot;,
              &quot;price&quot;: 5.99,
              &quot;attributes&quot;: &quot;{\&quot;colour\&quot;: \&quot;blue\&quot;,\&quot;size\&quot;: \&quot;Small\&quot;}&quot;,
              &quot;created_at&quot;: &quot;*&quot;,
              &quot;updated_at&quot;: &quot;*&quot;
            }
</code></pre>
<p>We add our new route:</p>
<pre><code class="lang-php">$app-&gt;patch(&#39;/api/products/{id}&#39;, &#39;ProductController@update&#39;);
</code></pre>
<p>And our <code>update()</code> method:</p>
<pre><code class="lang-php">    public function update(Request $request, $id)
    {
        // Validate request
        $valid = $this-&gt;validate($request, [
            &#39;name&#39; =&gt; &#39;string&#39;,
            &#39;description&#39; =&gt; &#39;string&#39;,
            &#39;price&#39; =&gt; &#39;numeric&#39;,
            &#39;attributes&#39; =&gt; &#39;string&#39;,
        ]);

        // Get product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Update it
        if ($request-&gt;has(&#39;name&#39;)) {
            $product-&gt;name = $request-&gt;input(&#39;name&#39;);
        }
        if ($request-&gt;has(&#39;description&#39;)) {
            $product-&gt;description = $request-&gt;input(&#39;description&#39;);
        }
        if ($request-&gt;has(&#39;price&#39;)) {
            $product-&gt;price = $request-&gt;input(&#39;price&#39;);
        }
        if ($request-&gt;has(&#39;attributes&#39;)) {
            $product-&gt;attributes = $request-&gt;input(&#39;attributes&#39;);
        }

        // Save product
        $product-&gt;save();

        // Send response
        return response()-&gt;json($product, 200);
    }
</code></pre>
<p>Here we can’t guarantee every parameter will exist, so we test for it. We run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 74ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47464 [200]: /api/products
pass: GET /api/products/1 duration: 19ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47466 [200]: /api/products/1
pass: POST /api/products duration: 36ms
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47470 [201]: /api/products
[Mon Aug  8 15:27:14 2016] 127.0.0.1:47474 [200]: /api/products/1
pass: PATCH /api/products/1 duration: 34ms
complete: 4 passing, 0 failing, 0 errors, 0 skipped, 4 total
complete: Tests took 2579ms
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/eae98644-44ad-432f-90fc-5f73fa674f66
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>One last method to implement - the <code>DELETE</code> method. Add this to <code>apiary.apib</code>:</p>
<pre><code class="lang-markdown">## Delete products [DELETE /api/products/1]
Delete an existing product

+ Request (application/json)

+ Response 200 (application/json)
    + Body

            {
                &quot;status&quot;: &quot;Deleted&quot;
            }
</code></pre>
<p>Next, add the route:</p>
<pre><code class="lang-php">$app-&gt;delete(&#39;/api/products/{id}&#39;, &#39;ProductController@destroy&#39;);
</code></pre>
<p>And the <code>destroy()</code> method in the controller:</p>
<pre><code class="lang-php">    public function destroy($id)
    {
        // Get product
        $product = $this-&gt;product-&gt;findOrFail($id);

        // Delete product
        $product-&gt;delete();

        // Return empty response
        return response()-&gt;json([&#39;status&#39; =&gt; &#39;deleted&#39;], 200);
    }
</code></pre>
<p>And let’s run Dredd again:</p>
<pre><code class="lang-bash">$ dredd
info: Configuration &#39;./dredd.yml&#39; found, ignoring other arguments.
info: Using apiary reporter.
info: Starting server with command: php -S localhost:3000 -t public/
info: Waiting 3 seconds for server command to start...
info: Beginning Dredd testing...
pass: GET /api/products duration: 66ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48664 [200]: /api/products
pass: GET /api/products/1 duration: 19ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48666 [200]: /api/products/1
pass: POST /api/products duration: 45ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48670 [201]: /api/products
pass: PATCH /api/products/1 duration: 24ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48674 [200]: /api/products/1
pass: DELETE /api/products/1 duration: 27ms
complete: 5 passing, 0 failing, 0 errors, 0 skipped, 5 total
complete: Tests took 713ms
[Mon Aug  8 15:57:44 2016] 127.0.0.1:48678 [200]: /api/products/1
complete: See results in Apiary at: https://app.apiary.io/public/tests/run/a3e11d59-1dad-404b-9319-61ca5c0fcd15
info: Sending SIGTERM to the backend server
info: Backend server was killed
</code></pre>
<p>Our REST API is now finished.</p>
<h2 id="generating-html-version-of-your-documentation">Generating HTML version of your documentation</h2>
<p>Now we have finished documenting and implementing our API, we need to generate an HTML version of it. One way is to use <code>aglio</code>:</p>
<pre><code class="lang-bash">$ aglio -i apiary.apib -o output.html
</code></pre>
<p>This will write the documentation to <code>output.html</code>. There’s also scope for choosing different themes if you wish.</p>
<p>You can also use Apiary, which has the advantage that they’ll create a stub of your API so that if you need to work with the API before it’s finished being implemented, you can use that as a placeholder.</p>
<h2 id="summary">Summary</h2>
<p>The Blueprint language is a useful way of documenting your API, and makes it simple enough that it’s hard to weasel out of doing so. It’s worth taking a closer look at <a href="https://apiblueprint.org/">the specification</a> as it goes into quite a lot of detail. It’s hard to ensure that the documentation and implementation remain in sync, so it’s a good idea to use Dredd to ensure that any changes you make don’t invalidate the documentation. With Aglio or Apiary, you can easily convert the documentation into a more attractive format.</p>
<p>You’ll find the source code for this demo API <a href="https://github.com/matthewbdaly/demoapi">on Github</a>, so if you get stuck, take a look at that. I did have a fair few issues with whitespace, so bear that in mind if it behaves oddly. I’ve also noticed a few quirks, such as Dredd not working properly if a route returns a 204 response code, which is why I couldn’t use that for deleting - this <a href="https://github.com/apiaryio/dredd/issues/468">appears to be a bug</a>, but hopefully this will be resolved soon.</p>
<p>I’ll say it again, Dredd is not a substitute for proper unit tests, and under no circumstances should you use it as one. However, it can be very useful as a way to plan how your API will work and ensure that it complies with that plan, and to ensure that the implementation and documentation don’t diverge. Used as part of your normal continuous integration setup, Dredd can make sure that any divergence between the docs and the application is picked up on and fixed as quickly as possible, while also making writing documentation less onerous.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Broadcasting events with Laravel and Socket.io]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/05/14/broadcasting-events-with-laravel-and-socket-dot-io/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/05/14/broadcasting-events-with-laravel-and-socket-dot-io/">
        </link>
        <updated>2016-05-14T20:00:00Z</updated>
        <summary type="html"><![CDATA[<p>PHP frameworks like Laravel aren’t really set up to handle real-time events properly, so if you want to build a real-time app, you’re generally better off with another platform, such as Node.js. However, if that only forms a small part of your application, you may still prefer to work with PHP. Fortunately it’s fairly straightforward to hand off the real-time aspects of your application to a dedicated microservice written using Node.js and still use Laravel to handle the rest of the functionality.</p>
<p>Here I’ll show you how I built a Laravel app that uses a separate Node.js script to handle sending real-time updates to the user.</p>
<h2 id="events-in-laravel">Events in Laravel</h2>
<p>In this case, I was building a REST API to serve as the back end for a Phonegap app that allowed users to message each other. The API includes an endpoint that allows users to create and fetch messages. Now, in theory, we could just repeatedly poll the endpoint for new messages, but that would be inefficient. What we needed was a way to notify users of new messages in real time, which seemed like the perfect opportunity to use Socket.io.</p>
<p>Laravel comes with a simple, but robust system that allows you to broadcast events to a Redis server. Another service can then listen for these events and carry out jobs on them, and there is no reason why this service has to be written in PHP. This makes it easy to decouple your application into smaller parts. In essence the functionality we wanted was as follows:</p>
<ul>
<li>Receive message</li>
<li>Push message to Redis</li>
<li>Have a separate service pick up message on Redis</li>
<li>Push message to clients</li>
</ul>
<p>First off, we need to define an event in our Laravel app. You can create a boilerplate with the following Artisan command:</p>
<pre><code class="lang-bash">$ php artisan make:event NewMessage
</code></pre>
<p>This will create the file <code>app/Events/NewMessage.php</code>. You can then customise this as follows:</p>
<pre><code class="lang-php">&lt;?php

namespace App\Events;

use App\Events\Event;
use App\Message;
use Illuminate\Queue\SerializesModels;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;

class NewMessage extends Event implements ShouldBroadcast
{
    use SerializesModels;

    public $message;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct(Message $message)
    {
        // Get message
        $this-&gt;message = $message;
    }

    /**
     * Get the channels the event should be broadcast on.
     *
     * @return array
     */
    public function broadcastOn()
    {
        return [&#39;room_&#39;.$this-&gt;message-&gt;room_id];
    }
}
</code></pre>
<p>This particular event is a class that accepts a single argument, which is an instance of the <code>Message</code> model. This model includes an attribute of <code>room_id</code> that is used to determine which room the message is posted to - note that this is returned in the <code>broadcastOn()</code> method.</p>
<p>When we want to trigger our new event, we can do so as follows:</p>
<pre><code class="lang-php">use App\Events\NewMessage;
Event::fire(new NewMessage($message));
</code></pre>
<p>Here, <code>$message</code> is the saved Eloquent object containing the message. Note the use of <code>SerializesModels</code> - this means that the Eloquent model is serialized into JSON when broadcasting the event.</p>
<p>We also need to make sure Redis is set as our broadcast driver. Ensure the Composer package <code>predis/predis</code> is installed, and set <code>BROADCAST_DRIVER=redis</code> in your <code>.env</code> file. Also, please note that I found that setting <code>QUEUE_DRIVER=redis</code> in <code>.env</code> as well broke the broadcasting system, so it looks like you can’t use Redis as both a queue and a broadcasting system unless you set up multiple connections.</p>
<p>Next, we need another server-side script to handle processing the received events and pushing the messages out. In my case, this was complicated by the fact that we were using HTTPS, courtesy of Let’s Encrypt. I installed the required dependencies for the Node.js script as follows:</p>
<pre><code class="lang-bash">$ npm install socket.io socket.io-client ioredis --save-dev
</code></pre>
<p>Here’s an example Node.js script for processing the events:</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);
var pkey = fs.readFileSync(&#39;/etc/letsencrypt/live/example.com/privkey.pem&#39;);
var pcert = fs.readFileSync(&#39;/etc/letsencrypt/live/example.com/fullchain.pem&#39;)

var options = {
  key: pkey,
  cert: pcert
};

var app = require(&#39;https&#39;).createServer(options);
var io = require(&#39;socket.io&#39;)(app);

var Redis = require(&#39;ioredis&#39;);
var redis = new Redis();

app.listen(9000, function() {
    console.log(&#39;Server is running!&#39;);
});

function handler(req, res) {
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    res.writeHead(200);
    res.end(&#39;&#39;);
}

io.on(&#39;connection&#39;, function(socket) {
    //
});

redis.psubscribe(&#39;*&#39;, function(err, count) {
    //
});

redis.on(&#39;pmessage&#39;, function(subscribed, channel, message) {
    message = JSON.parse(message);
    console.log(&#39;Channel is &#39; + channel + &#39; and message is &#39; + message);
    io.emit(channel, message.data);
});
</code></pre>
<p>Note we use the <code>https</code> module instead of the <code>http</code> one, and we pass the key and certificate as options to the server. This server runs on port 9000, but feel free to move it to any arbitrary port you wish. In production, you’d normally use something like Supervisor or systemd to run a script like this as a service.</p>
<p>Next, we need a client-side script to connect to the Socket.io instance and handle any incoming messages. Here’s a very basic example that just dumps them to the browser console:</p>
<pre><code class="lang-javascript">var url = window.location.protocol + &#39;//&#39; + window.location.hostname;
var socket = io(url, {
  &#39;secure&#39;: true,
  &#39;reconnect&#39;: true,
  &#39;reconnection delay&#39;: 500,
  &#39;max reconnection attempts&#39;: 10
});
var chosenEvent = &#39;room_&#39; + room.id;
socket.on(chosenEvent, function (data) {
  console.log(data);
});
</code></pre>
<p>Finally, we need to configure our web server. I’m using Nginx with PHP-FPM and PHP 7, and this is how I configured it:</p>
<pre><code class="lang-nginx">upstream websocket {
    server 127.0.0.1:9000;
}

server {
    listen         80;
    server_name example.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name example.com;
    ssl on;
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;
    client_max_body_size 50M;
    server_tokens off;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection &quot;1; mode=block&quot;;

    root /var/www/public;
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip on;
        gzip_proxied any;
        gzip_types text/plain text/css application/javascript application/x-javascript text/xml application/xml application/xml-rss text/javascript text/js application/json;
        expires 1y;
        charset utf-8;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /.well-known {
        root /var/www/public;
        allow all;
    }

    location /socket.io {
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_http_version 1.1;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $host;
        proxy_pass https://websocket;
    }
}
</code></pre>
<p>Any requests to <code>/socket.io</code> are proxied to port 9000, where our chat handling script is listening. Note that we allow the HTTPS connection to be upgraded to a WebSocket one.</p>
<p>Once that’s done, you just need to restart your PHP application and Nginx, and start running your chat script, and everything should be working fine. If it isn’t, the command <code>redis-cli monitor</code> is invaluable in verifying that the event is being published correctly.</p>
<h2 id="summary">Summary</h2>
<p>Getting this all working together did take quite a bit of trial and error, but that was mostly a matter of configuration. Actually implementing this is pretty straightforward, and it’s an easy way to add some basic real-time functionality to an existing Laravel application.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Writing faster Laravel tests]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/04/04/writing-faster-laravel-tests/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/04/04/writing-faster-laravel-tests/">
        </link>
        <updated>2016-04-04T19:55:15Z</updated>
        <summary type="html"><![CDATA[<p>Nowadays, Laravel tends to be my go-to PHP framework, to the point that we use it as our default framework at work. A big part of this is that Laravel is relatively easy to test, making practicing TDD a lot easier.</p>
<p>Out of the box running Laravel tests can be quite slow, which is a big issue - if your test suite takes several minutes to run, that’s a huge disruption. Also, Laravel doesn’t create a dedicated test database - instead it runs the tests against the same database you’re using normally, which is almost always not what you want. I’ll show you how to set up a dedicated test database, and how to use an in-memory SQLite database for faster tests. This results in cleaner and easier-to-maintain tests, since you can be sure the test database is restored to a clean state at the end of every test.</p>
<h2 id="setup">Setup</h2>
<p>Our first step is to make sure that when a new test begins, the following should happen:</p>
<ul>
<li>We should create a new transaction</li>
<li>We should empty and migrate our database</li>
</ul>
<p>Then, at the end of each test:</p>
<ul>
<li>We should roll back our transaction to restore the database to its prior state</li>
</ul>
<p>To do so, we can create custom <code>setUp()</code> and <code>tearDown()</code> methods for our base <code>TestCase</code> class. Save this in <code>tests/TestCase.php</code>:</p>
<pre><code class="lang-php">&lt;?php

class TestCase extends Illuminate\Foundation\Testing\TestCase
{
    /**
     * The base URL to use while testing the application.
     *
     * @var string
     */
    protected $baseUrl = &#39;http://localhost&#39;;
    /**
     * Creates the application.
     *
     * @return \Illuminate\Foundation\Application
     */
    public function createApplication()
    {
        $app = require __DIR__.&#39;/../bootstrap/app.php&#39;;
        $app-&gt;make(Illuminate\Contracts\Console\Kernel::class)-&gt;bootstrap();
        return $app;
    }

    public function setUp()
    {
        parent::setUp();
        DB::beginTransaction();
        Artisan::call(&#39;migrate:refresh&#39;);
    }

    public function tearDown()
    {
        DB::rollBack();
        parent::tearDown();
    }
}
</code></pre>
<p>That takes care of building up and tearing down our database for each test.</p>
<p>EDIT: Turns out there’s actually a much easier way of doing this already included in Laravel. Just import and add either <code>use DatabaseMigrations;</code> or <code>use DatabaseTransactions;</code> to the <code>TestCase</code> class. The first will roll back the database and migrate it again after each test, while the second wraps each test in a transaction.</p>
<h2 id="using-an-in-memory-sqlite-database-for-testing-purposes">Using an in-memory SQLite database for testing purposes</h2>
<p>It’s not always practical to do this, especially if you rely on database features in PostgreSQL that aren’t available in SQLite, but if it is, it’s probably worth using an in-memory SQLite database for your tests. If you want to do so, here’s some example settings you might want to use in <code>phpunit.xml</code>:</p>
<pre><code class="lang-xml">        &lt;env name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt;
        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
        &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;
</code></pre>
<p>This can result in a very significant speed boost.</p>
<p>I would still recommend that you test against your production database, but this can be easily handed off to a continuous integration server such as Jenkins, since that way it won’t disrupt your workflow. </p>
<p>During TDD, you’ll typically run your tests several times for any change you make, so if they’re too slow it can have a disastrous effect on your productivity. But with a few simple changes like this, you can ensure your tests run as quickly as possible. This approach should also be viable for Lumen apps.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[My experience using PHP 7 in production]]></title>
        <id>https://matthewdaly.co.uk/blog/2016/03/18/my-experience-using-php-7-in-production/</id>
        <link href="https://matthewdaly.co.uk/blog/2016/03/18/my-experience-using-php-7-in-production/">
        </link>
        <updated>2016-03-18T19:42:37Z</updated>
        <summary type="html"><![CDATA[<p>In the last couple of weeks I’ve been working on a PHP web app. Nothing unusual there, except this was the first time we’d used PHP 7 in production. We discussed the possibility a while back, and eventually decided that for certain projects we’d use PHP 7 without waiting another year or so (or maybe longer) for a version of Debian stable with it by default. I wanted to talk about how our experience has been using it in production.</p>
<h2 id="background">Background</h2>
<p>We’ve never really had a fixed stack that we work with at work before until recently - it was largely based on personal preferences and experience. For many jobs, especially content-based sites, we generally used WordPress - it has its issues, but it does fine for a lot of work. For more complex websites, I tended to use CodeIgniter because I’d learned it during my previous job and knew it fairly well, but I was not terribly happy with it - it’s a bit too basic and simplistic, as well as being somewhat behind the times, and I only really kept using it through inertia. For mobile app backends, I tended to use Django, partly for the admin interface, and partly because Django REST Framework makes it easy to build a REST API quickly and easily in a way that wasn’t viable with CodeIgniter.</p>
<p>This state of affairs couldn’t really continue. I love Python and Django, but I was the only one at work who had ever used Python, so in the event I got hit by a bus there would have been no-one who could have taken over from me. As for CodeIgniter, it was clearly falling further and further behind the curve, and I was sick of it and looking to replace it. Ideally we needed a PHP framework as both myself and my colleague knew it.</p>
<p>I’d also been playing around with Laravel on a few little projects, but I didn’t get the chance to use it for a new web app until autumn last year. Around the same time, we hired a third developer, who also had some experience using Laravel. In addition, the presence of Lumen meant that we could use that for smaller apps or services that were too small to use Laravel. We therefore decided to adopt Laravel as our default framework - in future we’d only use something else if there was a particular justification for it. I was rather sad to have to abandon Django for work, but pleased to have something more modern than CodeIgniter for PHP projects.</p>
<p>This also enabled us to standardize our new server builds. Over the last year or so I’ve been pushing to automate what we can of our server setup using Ansible. We now have two standard stacks that we plan to use for future projects. One is for WordPress sites and consists of:</p>
<ul>
<li>Debian stable</li>
<li>Apache</li>
<li>MySQL</li>
<li>PHP 5.6</li>
<li>Memcached</li>
<li>Varnish</li>
</ul>
<p>The other is for Laravel or Lumen web apps or APIs and consists of:</p>
<ul>
<li>Debian stable</li>
<li>Nginx</li>
<li>PHP 7</li>
<li>PostgreSQL</li>
<li>Redis</li>
</ul>
<p>It took some time to decide what we wanted to settle on, and indeed we had a mobile app backend that went up around Christmas time that we wrote with Laravel, but deployed to Apache with PHP 5.6 because when we first pushed it up PHP 7 wasn’t out yet. However, given that Laravel 5 already had good support for PHP 7, we decided we’d consider it for the next app. I tend to use PostgreSQL rather than MySQL these days because it has a lot of nifty features like JSON fields and full text search, and using an ORM minimises the learning curve in switching, and Redis is much more versatile than Memcached, so they were vital parts of our stack.</p>
<h2 id="our-first-php-7-app">Our first PHP 7 app</h2>
<p>As it happened, we had a Laravel app in the pipeline that was ideal. In the summer of last year, we were hired to make an existing site responsive. In the end, it turned out not to be viable - it was built with Zend Framework, which none of us had ever touched before, and the front end used a lot of custom widgets and fields tied together with RequireJS. The whole thing was rather unwieldy and extremely difficult to maintain and develop. In the end, we decided to tell the client it wasn’t worth developing further and offer to rewrite the whole thing from scratch using Laravel and AngularJS, with Browserify used to handle JavaScript modules - the basic idea was quite simple, it was just the implementation that was overly complex, and AngularJS made it possible to do the same kind of thing with a fraction of the code, so a rewrite in only a few weeks was perfectly viable.</p>
<p>I’d already built a simple prototype to demonstrate the viability of a from-scratch rewrite using Laravel and Angular, and once the client had agreed to the rewrite, we were able to work on this further. As the web app was going to be particularly useful on mobile devices, I wanted to ensure that the performance was as good as I could possibly make it. By the time we were looking at deploying it to a server, three months had passed since PHP 7 had been first released, and I figured that was long enough for the most serious issues to be resolved, and we could definitely do with the very significant speed boost we’d get from using PHP 7 for this app.</p>
<p>I use Jenkins to run my unit tests, and so I decided to try installing PHP 7 on the Jenkins server and using that to run the tests. The results were encouraging - nothing broke as a result of the switch. So we therefore decided that when we deployed it, we’d try it with PHP 7, and if it failed, we’d switch to PHP 5.6.</p>
<p>I opted to use FPM with Nginx rather than Apache and <code>mod_php</code> as since the web app was purely custom we didn’t really need things like <code>.htaccess</code>, and while the amount of static content was limited, Nginx might well perform better for this use case. The results are fairly encouraging - the document for the home page is typically being returned in under 40ms, with the uncached homepage taking around 1.5s in total to load, despite having to load several external fonts. In its current state, the web app scores a solid 93% on YSlow, which I’m very happy with. I don’t know how much of that is down to using PHP 7, but choosing to use it was definitely a good call. I have had absolutely zero issues with it during that time.</p>
<h2 id="summary">Summary</h2>
<p>As always, you should bear in mind that your needs may not be the same as mine, and it could well be that you need something that PHP 7 doesn’t yet provide. However, I have had a very good experience with PHP 7 in production. I may have had to jump through a few more hoops to get it up and running, and there may be some level of risk associated with using PHP 7 when it’s only been available for three months, but it’s more than justified by the speed we get from our web app. Using a configuration management system like Ansible means that even if you do have to jump through some extra hoops, it’s relatively easy to automate that process so it’s not as much of an issue as you might think. For me, using PHP 7 with a Laravel app has worked as well as I could have possibly hoped.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Setting ETags in Laravel 5]]></title>
        <id>https://matthewdaly.co.uk/blog/2015/06/14/setting-etags-in-laravel-5/</id>
        <link href="https://matthewdaly.co.uk/blog/2015/06/14/setting-etags-in-laravel-5/">
        </link>
        <updated>2015-06-14T20:29:52Z</updated>
        <summary type="html"><![CDATA[<p>Although I’d prefer to use Python or Node.js, there are some times when circumstances dictate that I need to use PHP for a project at work. In the past, I used CodeIgniter, but that was through nothing more than inertia. For some time I’d been planning to switch to Laravel, largely because of the baked-in PHPUnit support, but events conspired against me - one big project that came along had a lot in common with an earlier one, so I forked it rather than starting over.</p>
<p>Recently I built a REST API for a mobile app, and I decided to use that to try out Laravel (if it had been available at the time, I’d have gone for Lumen instead). I was very pleased with the results - I was able to quickly put together the back end I wanted, with good test coverage, and the <code>tinker</code> command in particular was useful in debugging. The end result is fast and efficient, with query caching in place using Memcached to improve response times.</p>
<p>I also implemented a simple middleware to add ETags to HTTP responses and compare them on incoming requests, returning a <code>304 Not Modified</code> status code if they are the same, which is given below:</p>
<pre><code class="lang-php">&lt;?php namespace App\Http\Middleware;

use Closure;

class ETagMiddleware {

    /**
     * Implement Etag support
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        // Get response
        $response = $next($request);

        // If this was a GET request...
        if ($request-&gt;isMethod(&#39;get&#39;)) {
            // Generate Etag
            $etag = md5($response-&gt;getContent());
            $requestEtag = str_replace(&#39;&quot;&#39;, &#39;&#39;, $request-&gt;getETags());

            // Check to see if Etag has changed
            if($requestEtag &amp;&amp; $requestEtag[0] == $etag) {
                $response-&gt;setNotModified();
            }

            // Set Etag
            $response-&gt;setEtag($etag);
        }

        // Send response
        return $response;
    }

}
</code></pre>
<p>This is based on <a href="https://www.nickv.codes/blog/etags-in-laravel-4/">a solution for Laravel 4 by Nick Verwymeren</a>, but implemented as Laravel 5 middleware, not a Laravel 4 filter. To use this with Laravel 5, save this as <code>app/Http/Middleware/ETagMiddleware.php</code>. Then add this to the <code>$middleware</code> array in <code>app/Http/Kernel.php</code>:</p>
<pre><code class="lang-php">        &#39;App\Http\Middleware\ETagMiddleware&#39;,
</code></pre>
<p>It’s quite simple to write this kind of middleware with Laravel, and using something like this is a no-brainer for most web apps considering the bandwidth it will likely save your users.</p>
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[Running the PHP development server with Laravel]]></title>
        <id>https://matthewdaly.co.uk/blog/2012/12/15/running-the-php-development-server-with-laravel/</id>
        <link href="https://matthewdaly.co.uk/blog/2012/12/15/running-the-php-development-server-with-laravel/">
        </link>
        <updated>2012-12-15T00:26:00Z</updated>
        <summary type="html"><![CDATA[<p>One thing that I’ve really never liked about PHP is the requirement to install a full-blown web server, so I was pleased when PHP 5.4 shipped with a built-in development server. However, it seems like no PHP framework has yet embraced this to the extent that their counterparts for languages like Python have.</p>
<p>I’ve recently decided that CodeIgniter is no longer fulfilling what I need from my main go-to PHP framework, and I’ve been looking at Laravel as a likely replacement. It occurred to me that I could create an Artisan task to run the development server quite easily, and after a little tinkering, I put this together, which worked well:</p>
<pre><code class="lang-php">&lt;?php

class Runserver_Task {

    public function run($arguments)
    {   
        $port = !isset($arguments[0]) ? 8000: $arguments[0];
        echo &#39;Running PHP development server on port &#39;.$port.&#39;...&#39;;
        passthru(&#39;php -S localhost:&#39;.$port.&#39; -t &#39;.getcwd().&#39;/public&#39;);
    }   
}
?&gt;
</code></pre>
<p>Once this is in place, you can just run <code>php artisan runserver</code> to run the development server, and hit <kbd>Ctrl-C</kbd> to stop it, giving you an experience much like that with Django. Note this requires PHP 5.4 or greater. You also have the option of specifying a different port eg <code>php artisan runserver 7000</code> for port 7000.</p>
]]></summary>
    </entry>
</feed>